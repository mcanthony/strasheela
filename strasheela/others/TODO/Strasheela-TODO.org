#+CATEGORY: Strasheela

#+BABEL: :noweb yes :results silent :exports none

* Strasheela release

** Finish regular temperament definition (e.g., doc incomplete)

   see [[file:~/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/HarmonisedScore/source/Score.oz::class%20RegularTemperamentMixinForNote][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/Score.oz::class RegularTemperamentMixinForNote]]

** Heuristic constraints support

*** Add heuristic defs to functor H

 see constraint ideas in TODO section in that functor

# OK - port Jacopos heuristic constraints from JBS-constraints to Strasheela (avoid too much repetition, though: generalise)

# OK - port OMClouds constraints as heuristics to Strasheela
   
*** Heuristic "global constraints"
    
    See 

*** Revise SDistro.heuristicValueOrder

#    - OK Allow to randomise solution, but with support for recomputation

    - Efficiency: ParamPos accessed multiple times (below accessed again, somehow store this info instead)

    - Consider making SDistro.heuristicValueOrder the default ordering

*** Allow for randomised heuristic constraint definitions 

    - randomisation with recomputation support

*** Some heuristic constraints depend on variable ordering (e.g., Distinct)

    How to address this problem?

**** Distict (i.e. AllDifferent)

 Problem: effective implementation depends of variable ordering: for
 every visited parameter of a certain parameter sequence the
 constraint always takes all parameters values that are already
 determined into account.

 I would need alternative to Score.apply_H in order to do that (should
 not add heuristic to all params involved, but only to always only the
 one that is still undetermined when the heuristic is actually
 used. Also SDistro.heuristicVariableOrdering would require revision,
 because I should not need to "search" for current parameter then, but
 have a different format where the current parameter is given extra or
 its position in params list is stored as well)

*** Revise Score.apply_H doc

*** Show in example that heuristic constraints can be applied to arbitrary contexts

    even contexts that are undetermined in CSP definition, e.g., simultaneous notes if rhythm is undetermined
    E.g., use Smapping.forSimultaneousPairs


** Finish def of ResolveDissonances_ChordDegree
   [[file:~/oz/music/Strasheela/strasheela/strasheela/examples/Harmony-Examples/Schoenberg-TheoryOfHarmony.oz::proc%20ResolveDissonances_ChordDegree%20Notes%20Args%20Args%20unused][file:~/oz/music/Strasheela/strasheela/strasheela/examples/Harmony-Examples/Schoenberg-TheoryOfHarmony.oz::proc ResolveDissonances_ChordDegree Notes Args Args unused]]

   e.g., 
   - documentation
   - generalise such that it constraints chords not only notes, so it can be used for non-homophonic music too (resolution in "wrong" octave OK, but that should actually happen more rarely?)


* Strasheela applications and examples

** Critical Listening exercises generator for intervals, harmonies, etc.

   Use new Strasheela-PWGL/OpenMusic interface for creating exercises which students can use on their own

  - Interval identification
    - Melodic as well as harmonic
    - Different instruments rather than only piano
    - Matching similar intervals 
      - Harmonic categories: perfect/imperfect consonance; mild/sharp dissonance
      - Melodic categories: similar size
      - Idea: play one interval and then (after rest) 3-4 other intervals in same or different category, different range, perhaps even with different instruments -- students should say which of the later interval(s) is/are similar to first interval 
      - Note: students may have more problems with terminology than actual listening -- this exercise eliminates terminology problem

  - Chord identification
    - Melodic as well as harmonic
    - Different instruments (including mix of orchestral instruments)
    - ? Matching similar chords? (Similar dissonance degree)

  - ?? Some exercise for cadences


  This program would take into account that
  - Students may have more difficulties with terminology than with the actual listening process -- these exercises can eleminate the terminology problem
  - Learnign supported by making students aware of similarities between sets of all intervals
  - Leaning supported by more varied exercises
  - Explicit practising of "dimensions" (harmonic and melodic similarities, register, and orchestration)

  A proper research paper then would also report how this application worked in class (e.g., somehow measure improvement of student learning)
  

* Strasheela Bugs

** Out.recordToVS does not always return VS

The following results in false

{VirtualString.is {Out.recordToVS HS.dbs.scala.db.chordDB}}

** Bugs in procs for tranversing partially determined scores, e.g., SMapping.mapSimultaneousPairs and SMapping.forSimultaneousPairs

** TODO !! Pattern.useMotifs: arg 'workOutEven' is ignored (behaves as if always set to true)
   
   see test at 
   [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Pattern/testing/Pattern-test.oz::%25%25%20end%20can%20be%20incomplete%20motif][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Pattern/testing/Pattern-test.oz::%% end can be incomplete motif]]

   source
   [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Pattern/Pattern.oz::proc%20{UseMotifs%20Xs%20Motifs%20Args}][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Pattern/Pattern.oz::proc {UseMotifs Xs Motifs Args}]]

** Replace FD.reified.distance -- does not propagate enough and can thus be completely ineffective 

FD.reified.distance is often used in Strasheela, and may be the cause for various strange bugs (i.e. non-effecting constraint applications)   

This only works on Torsten's machine ...

#+begin_src sh
cd ~/oz/music/Strasheela/strasheela/strasheela & ./scripts/find-all.sh FD.reified.distance
#+end_src

Example: this should clearly result in 0 and not {FD.int 0#1}

#+begin_src oz :results output
{Browse {FD.reified.distance 64 62 '>:' 3}}
#+end_src

Improved GUtils.reifiedDistance -- check carefully whether it is really better!


#+begin_src oz :results output
{Browse {GUtils.reifiedDistance 64 62 '>:' 3}}
#+end_src

** TODO BUG: getOffsetTimeInSeconds  no dependency to tempo curve or time shift function defined yet, depends on type of temporal container

** TODO BUG: tempo setting affects Csound and MIDI output differently

%% BUG: MIDI tempo not OK

declare
%% set playback tempo
{Init.setTempo 70.0}
%% Create test score
MyTestScore = {Score.makeScore
	       seq(items:[note(duration:2
			       pitch:60
			       amplitude:80)
			  note(duration:2
			       pitch:64
			       amplitude:60)
			  note(duration:2
			       pitch:67
			       amplitude:50)
			  note(duration:6
			       pitch:72
			       amplitude:100)
			 ]
		   startTime:0
		   timeUnit:beats(4))
	       unit}


%% Just in case: wait until 
{MyTestScore wait}


%% Csound output 
{Out.renderAndPlayCsound MyTestScore
 unit(file:myTestScore)}

%% MIDI output
{Out.midi.renderAndPlayMidiFile MyTestScore
 unit(file:myTestScore)}


** Random value ordering: it appears largest domain value is never selected directly

** Fix bugs

   HS.rules.maxRepetitions

   HS.rules.expressEssentialChordPCs


* Strasheela design and development 				 :STRASHEELA:

** DONE Move Strasheela sources to GitHub		       :SOON:ARCHIVE:
   CLOSED: [2012-06-07 Thu 11:00]

*** Todo for transfer

**** DONE Open questions
     CLOSED: [2012-06-01 Fri 01:56]

     - How to exclude certain files from including them into git repository (how to hide them by default)
       File types: *.ozf
       Solution: include a file .gitignore in the top-level Strasheela directory that lists file types to ignore etc
       cf. file:~/emacs/org-mode/.gitignore
       http://help.github.com/ignore-files/


***** .gitignore

*~
*.ozf


**** Learn Git etc.

     Just had a little look -- very promising after my previous experience with Subversion and my tools with that

***** Git

      http://git-scm.com/book

***** Git emacs interface

      Use magit (version 1.1.1 already installed)

      Get started
      M-x magit-status

      Tutorial video
      http://vimeo.com/2871241    

      Cheatsheet
      http://daemianmack.com/magit-cheatsheet.html

      Manual
      http://magit.github.com/magit/magit.html

***** Github


**** DONE Transfer Strasheela subversion repository to git
     CLOSED: [2012-06-01 Fri 01:57]

       http://help.github.com/import-from-subversion/

***** !! svn2git -- preferred approach

      *Strasheela git repository at file:~/oz/music/Strasheela/strasheela-git*


      svn2git is designed to provide a complete svn import. Unlike git-svn, it will create proper git tags from your svn “tags”.

      https://github.com/nirvdrum/svn2git


cd /Users/torsten/oz/music/Strasheela/strasheela      
/Users/torsten/.gem/ruby/1.8/bin/svn2git http://strasheela.svn.sourceforge.net/svnroot/strasheela 

     *NOTE:* 

     Later changes to the svn repository can be added 

cd /Users/torsten/oz/music/Strasheela/strasheela && svn2git --rebase

     Changes to the git repository can also be added back to the online svn repository
     but "... working with Git-based remote versions of your projects concurrently with a Subversion server isn’t a good idea"
     http://git-scm.com/book/en/Git-and-Other-Systems-Git-and-Subversion#Committing-Back-to-Subversion

cd /Users/torsten/oz/music/Strasheela/strasheela
git svn dcommit

***** git-svn: one-way transfer quasi with git itself 

     This seems to work fine:

cd /Users/torsten/oz/music/Strasheela/strasheela-git      
git svn clone http://strasheela.svn.sourceforge.net/svnroot/strasheela strasheela.git


***** Info: no help from Sourceforge

     - See which tools Sourceforge offers to move svn repository to git
       -> seemingly none: I have to do the transfer and then use git from then on

***** Idea: have a local git repository				    :ARCHIVE:


      SubGit
      http://blog.tfnico.com/2011/12/git-svn-mirror-product-subgit.html
      -> Only works with local svn repository (or SubGit runs on server)


      
**** DONE Upload Strasheela git repository to GitHub
     CLOSED: [2012-06-01 Fri 01:57]


*** What stays at Sourceforge

    - Releases and their downloads
    - Website
    - Mailing lists
    - Apps: Track, 	Piwik..
    - ...


*** What moves to GitHub

    - The application sources and their development


*** General Info

**** Advantages of GitHub

     - !! More likely collaboration of other developers
     - Better user interface and navigation than Sourceforge
     - Distributed versioning system 
       - Off-line commits, and more often commits
       - More easy to fork
     - Lets see... if I can use both svn and git alongsise..


**** GitHub info

     - Storage limited to 300 MB (?)
       -> not a problem even with my current mp3s (repository currently ~65 MB)


** TODO [#A] Try to clean up score script parameters -- simplify if possible! :NEXT:ARCHIVE:

   Do this in a git branch, just to make sure...

*** Still missing

    - Args of top-level container
    - Args (rargs) of mixins

**** Cannot be done						    :ARCHIVE:

     [At least not without some extrem effort, like writing some extra parser...]

     - consider whether I can have a function like GetSources, which would return where each feature has been defined
       - Problem: I have no name
       - Idea: Can I return the file and position in that file to the def source code?
	 ... unfortunately, for dynamically generated funs Debug.procedureCoord returns the pos of the fun that generated the fun we are interested in, but ignores where that generating fun was called

	 Example
	 {Debug.procedureCoord Segs.makeCounterpoint_PatternMotifs}



*** Old

**** Brainstorming

     General goal: clean up [inherited] argument lists of score scripts, or alternatively document them better (e.g., can I somehow automatically document all args?)


**** Revise defs in ScoreCore.oz

     MakeConstructor
     MakeItems MakeItems_iargs MakeContainer MakeSim MakeSeq
     DefSubscript DefMixinSubscript

     *Note: pointer into master branch*
     See [[file:~/oz/music/Strasheela/strasheela/strasheela/source/ScoreCore.oz::fun%20{MakeConstructor%20Constructor%20Defaults}][file:~/oz/music/Strasheela/strasheela/strasheela/source/ScoreCore.oz::fun {MakeConstructor Constructor Defaults}]]


**** Revise contribution Segs

     *Note: pointer into master branch*
     See [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Segments/Segments.oz][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Segments/Segments.oz}]]


**** !! Finally, revise all calls to these defs

     - Revise all calls within Strasheela sources
     - Revise all calls of composition projects that are work in progress
     - Mark older/recent composition projects: they should use Strasheela version 0.10.1
       (last release before these changes)


** TODO Finish Scala chord/scale parser			       :NEXT:ARCHIVE:

   
   BUG:
    - # and * are unrecognised characters. Seemingly these are special regular expressions chars, but how to deal with that?
     ... delay further development until I have network access again

      [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/ScalaImport/test.oz::%25%25%20Test%20scanner][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/ScalaImport/test.oz::%% Test scanner]]

   [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/ScalaImport/ScalaScanner.oz::\gumpscannerprefix%20'scala'][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/ScalaImport/ScalaScanner.oz::\gumpscannerprefix 'scala']]

   [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/ScalaImport/ScalaParser.oz::%25%25%25%20-*-oz-gump-*-][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/ScalaImport/ScalaParser.oz::%%% -*-oz-gump-*-]]
   
   [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/ScalaImport/ScalaChords-12ET.par]]



** TODO Revise Melody definition				       :NEXT:

   - Try to simplify definition, e.g.,
     - Revise definition of pre-defined constraints -- simplify 
   - ...


   See [[file:~/Compositions/Orgel-StPeter-Koeln/Strasheela-source/Score.oz::proc%20{Melody%20Args%20?MyScore}][file:~/Compositions/Orgel-StPeter-Koeln/Strasheela-source/Score.oz::proc {Melody Args ?MyScore}]]

   

** TODO Revise Counterpoint_NParts definition			       :NEXT:

   See [[file:~/Compositions/Orgel-StPeter-Koeln/Strasheela-source/Score.oz::fun%20{Counterpoint_NParts%20Args}][file:~/Compositions/Orgel-StPeter-Koeln/Strasheela-source/Score.oz::fun {Counterpoint_NParts Args}]]

** TODO Finish chord and scale databases for 12-TET		       :NEXT:

   Database file [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/databases/Scala.oz]]

   Chords
   [[file:~/Downloads/scala-22-pc-linux/chordnam.par]]

   Scales
   [[file:~/Downloads/scala-22-pc-linux/modenam.par]]
   [[file:~/Downloads/scala-22-pc-linux/melathat.par]] (these are seemingly a subset of the above)


** TODO Add chord dissonance degree measure(s) to ScalaDB.oz	       :NEXT:

   *Partly done using Partch's one-footed bridge*
   Improve that by improving interval data (e.g., by using Erlich's Harmonic Entropy instead)


   How urgent is this? 
   I should somehow automate this, as it would take too long otherwise
   -> computer value in question for every interval (basically pitch class), then I can easily do this processing in Strasheela

*** Translate intervals of 12-TE chord specs into ratios

    Simplistic approach
    - Start with JI scale for 12-ET, e.g.,  
      1/1 16/15 9/8 6/5 5/4 4/3 45/32 3/2 8/5 5/3 16/9 15/8 2/1
    - For every interval of given chord select the corresponding JI interval (always from 1/1)


*** Use the intervals to compute some dissonance degree

**** Evaluate methods before deciding for any

     E.g., compare what they output for 9/8 vs 5/4
     - Barlow's harmonicity value for 9/8 is slightly higher than that for 5/4 -- is that useful for my purposes?


**** ! Erlich's Harmonic Entropy -- could that be used for chords directly?

     Harmonic entropy is the simplest possible model of consonance. It asks the question, "how confused is my brain when it hears an interval?"

     In principle, harmonic entropy is suited also for chords, not only intervals. However, this generalisation has not been done so far. Erlich: "Unlike roughness, tonalness is not merely concerned with pairwise interactions of tones but three-way and higher interactions as well. A mathematical model for it is out of my grasp at the moment." http://sonic-arts.org/td/erlich/entropy.htm

     short article
     http://www.soundofindia.com/showarticle.asp?in_article_id=1905806937

     *Encyclopaedia of Tuning*
     !! http://sonic-arts.org/td/erlich/entropy.htm

     Encyclopedia of Microtonal Music Theory 
     http://www.tonalsoft.com/enc/h/harmonic-entropy.aspx


     Paul Erlich's Paper
     http://sethares.engr.wisc.edu/paperspdf/HarmonicEntropy.pdf

     Harmonic entropy list
     http://launch.groups.yahoo.com/group/harmonic_entropy/messages


**** Todo Results

     Read directly from graph (I used the JI values, not the tempered intervals)
     .. I opened a gif file in OpenOffice

      1/1   | 
      16/15 | 
      9/8   | 
      6/5   | 
      5/4   | 
      4/3   | 
      45/32 | 
      3/2   | 
      8/5   | 
      5/3   | 
      16/9  | 
      15/8  | 
      2/1   | 


**** ! Partch's one-footed bridge

     Value taken with [lineal in mm] from Genesis of a Music, p. 155

      1/1   | no data
      16/15 | 5
      9/8   | 10
      6/5   | 19
      5/4   | 19 (20?)
      4/3   | 27
      45/32 | ? (0 in graph?)
      3/2   | 27
      8/5   | 19
      5/3   | 19
      16/9  | 10
      15/8  | 5 
      2/1   | 38

**** ! Euler's Gradus Suavitatis

     Results could be more or less useful for my purposes. The problem is only that 9/8, 6/5, and 8/5 all result in the same value G=8

***** Results

      Values obtained at website http://www.mathematik.com/Piano/index.html
      Should I perhaps manually simply "tune" these values for my purposes?

      1/1   | 1
      16/15 | 11
      9/8   | 8
      6/5   | 8
      5/4   | 7
      4/3   | 5
      45/32 | 14
      3/2   | 4
      8/5   | 8
      5/3   | 7
      16/9  | 9
      15/8  | 10
      2/1   | 2


      Manually tuned values (raised 9/8 by 0.5)
      
      1/1   | 1
      16/15 | 11
      9/8   | 8.5
      6/5   | 8
      5/4   | 7
      4/3   | 5
      45/32 | 14
      3/2   | 4
      8/5   | 8
      5/3   | 7
      16/9  | 9
      15/8  | 10
      2/1   | 2


      Note that values with octave added differ..

***** Method

     Use Scala:

     To see Euler's Gradus Suavitatis for the pitches, do SET ATTRIBUTE GRADUS.
This number is one higher than the sum of one less than the constituent
primes. Each prime is counted as many times as it occurs in the number. For
instance the Gradus of 6 is 1 + (2 - 1) + (3 - 1) = 4. What is shown with SHOW
DATA, the Gradus Suavitatis of a whole scale, is the Gradus of the E.C.
(Exponens Consonantiae). One property is G(ab) = G(a) + G(b) - 1  (G instead
of the usual capital Gamma). 

     

**** Vogel's harmonic complexity value -- can only be computed for a scale


***** Method

     Use Scala:

     To see Vogel's harmonic complexity value for rational intervals, do SET
ATTRIBUTE VOGEL. It is the sum of the constituent prime factors except 2,
where each one is counted as many times as it occurs, added to the number of
factors of 2. So the value for 7/6 = 7/3x2 is 7+3+1 = 11. To see Vogel's
harmonic complexity value of a scale, do SHOW DATA. It is the arithmetic mean
of Vogel's values for the integer multiples (all values under denominator 1)
of each note. To see these integer multiples, do SET ATTRIBUTE MULTIPLE.

A similar harmonic complexity value is Rudolf Wille's k value. To obtain it,
the ratios are brought under denominator 1 (see SET ATTRIBUTE MULTIPLE),
factors of 2 are removed and the maximum taken. Then k = (max - 1) / 2.
To see Wille's k value of a scale, do SHOW DATA.


**** Clarence Barlow's harmonicity value			    :ARCHIVE:

     Results are not really suitable my purposes as dissonance degree values
     - value for  9/8 is slightly higher than that for 5/4, and 6/5 is even lower
     - all interesting values are very close to each other

***** Results

      Values taken from The Ratio Book, p. 7

      1/1   | infinit 
      16/15 | -0.076531
      9/8   | 0.12
      6/5   | -0.099338
      5/4   | 0.119048
      4/3   | -0.214286
      45/32 | todo 
      3/2   | 0.272727
      8/5   | -0.106383
      5/3   | 0.110294
      16/9  | -0.107143
      15/8  | 0.082873
      2/1   | 1.0

***** Method

     Use Scala:

     To see Clarence Barlow's harmonicity value for rational intervals do SET
ATTRIBUTE HARMON. It depends on which and how many primes are in the ratio. 
The 'indigestibility factor' of a positive number is defined as the sum of
n * 2 * (p-1)^2 / p where p is one of the prime factors of the number and n
its count of occurrence in the number. For example the indigestibility of 9
is 2 * 2 * 2^2 / 3 = 5 1/3. It has the addition property I(ab) = I(a) + I(b).
The harmonicity of a ratio p/q is defined as 
sgn(I(p) - I(q)) / (I(p) + I(q)) where the sgn function is +1 when I(p) is
larger than I(q) and -1 if I(q) is greater. p and q should have no factors
in common.
     
The given attribute only gives Barlow's harmonicity if the prime weights have
the initial values. Another value will be given if they are changed with the
command SET HARMCONST.


**** Combine measures of multiple intervals for chord

     - compute values for each interval (all combinations)
     - computer arithmetic mean (or another mean?) of these values -- I should not linearly combine them..

       Problem: this approach does not take into account that intervals support each other, e.g., to perceive a certain root. The same intervals arrange in an otonal or utonal chord result in the same combined measure, but this is not true perceptionally.

     This is all too simplistic -- I would ideally take the interaction of all partials into account. Hm..
  
     


** TODO Extend harmony model by support for voicing (pitch class octaves) :SOON:

   Order / "octavation" of pitch classes in chord important and currently ignored by my harmony model 

   Extension (not replacement) of existing model would add additional constraints depending on harmony declarations how pitch classes should be arranged in octaves, e.g.,
   - Require PC1 to be octave above PC2
   - Require PC3 to be doubled in octave 1 and 2 above

   For example of such harmonies in database see [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/databases/Scala.oz::Chords%20%3D%20chords(][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/databases/Scala.oz::Chords = chords(]]


** TODO Extend my harmony model so that chord definitions can take intervals beyond an octave into account :SOON:

   The notion of pitch classes (i.e. only intervals less than an octave) is clearly simplifying the true notion of chords perceptually

   Examples:
   - Many chords in the Scala database go beyond an octave
   - In Jazz harmony, the "octavtion" of chords is important in the spacing 

     
*** Rethink my harmonic model -- the link between a chord def in a database and the arrangement of sim pitches in the score


*** Refactor implementation of my harmony model

*** Revise my chord databases

    E.g., [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/databases/ScalaDB.oz]]


** TODO Define melody score script (flexible CSP template)	       :NEXT:

   See [[file:~/Compositions/Z-published/2011/Anders-TempzinerModulationen/WritingProcess/Strasheela-source/Score.oz::proc%20{Melody%20Args%20?MyScore}][file:~/Compositions/Z-published/2011/Anders-TempzinerModulationen/WritingProcess/Strasheela-source/Score.oz::proc {Melody Args ?MyScore}]]



   - Simplify the application of arbitrary additional constraints

   - Clean up code, e.g.,
     - remove dependencies to composition specific things, like FokkerAndCarillo.richNote
     - very simple default motifs (or no motifs at all)
     - revise proc name (Melody to general)
   
   - Somewhat generalise that definition

   - ? Simplify the definition of constraints applied with args (wrap all those if-statements into some abstraction)
     -> consider removing that option completely


** TODO Define counterpoint script with arbitrary number of parts      :NEXT:
   
   Define a top-level CSP template comparable to the top-level of "Orjan's library

   Generalise [[file:~/Compositions/Z-published/2011/Anders-TempzinerModulationen/WritingProcess/Strasheela-source/Score.oz::fun%20{CP_3Part%20Args}][file:~/Compositions/Z-published/2011/Anders-TempzinerModulationen/WritingProcess/Strasheela-source/Score.oz::fun {CP_3Part Args}]]

   Music representation is sim with arbitrary number of parts (def with cleaned-up melody script), seq of chords, scales, and measure objects

   Allow that user controls end time, that can be before the last actual score object in internal music representation (consider to even stop the search when score is long enough)
   Advantage: number of notes flexible (and difficult to use non-existing notes option is not needed any more). See [[file:~/oz/music/Strasheela/strasheela/strasheela/examples/Rhythm-Examples/RhythmicMotifsFitIntoMetricStructure.oz::%25%25%20For%20Hans%20Tutschku][file:~/oz/music/Strasheela/strasheela/strasheela/examples/Rhythm-Examples/RhythmicMotifsFitIntoMetricStructure.oz::%% For Hans Tutschku]]

   - Simplify the application of arbitrary additional constraints

   - Clean up code
     - remove dependencies to composition specific things

   - ? Simplify the definition of constraints applied with args (wrap all those if-statements into some abstraction)
     -> consider removing that option completely
   

   - Document in CTT functor the more suitable option with user-defined endtime before actual end, and point to this script as an example


** TODO Add support for grace notes				       :NEXT:

   Duration value 0 
   
   Note: with option that score can last longer than the actually used score the non-existing notes option is not needed any more. See [[file:~/oz/music/Strasheela/strasheela/strasheela/examples/Rhythm-Examples/RhythmicMotifsFitIntoMetricStructure.oz::%25%25%20For%20Hans%20Tutschku][file:~/oz/music/Strasheela/strasheela/strasheela/examples/Rhythm-Examples/RhythmicMotifsFitIntoMetricStructure.oz::%% For Hans Tutschku]]
   So, ignore CTT ...

   
   Consider defining in Measure.oz special accent constraint for notes with duration > 0 following 1 or more grace notes

   NOTE: I need to revise all output procs (MIDI, fomus..) which currently ignore all notes with duration 0


*** Old								    :ARCHIVE:

   Consider some way to distinguish between option that notes are either grace notes or "not existing" (CTT), e.g.,
   - Grace notes are always before some note with duration > 0, while "non-existing" notes are at the end of a container
   - Def some global switch (in Init.oz) to generally enable or disable grace note support


** Revise defaults for fomus 

   By default properly output
   - grace notes (note dur = 0, notated at "small" eighth notes with Fomus grace parameter, see http://fomus.sourceforge.net/doc.html/Grace-Notes-_0028File_0029.html#Grace-Notes-_0028File_0029)
   - chord seqs
   - scales
   - measures 


** TODO [#A] Define interface to integrate Strasheela into OpenMusic or PWGL :NEXT:

   see [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/PW_OM_Interface/Brainstorming.org]]

*** TODO Fix that OzServer compiler or runtime errors result in a blocking (e.g., block OpenMusic)

    Partial success: OzServer does not block anymore but instead returns 'error' for fed expressions
    
    However, once and error occurred nothing else than 'error' is returned, even for later computations without problems

*** TODO Extend Lisp->Oz data translation to correspond to existing Lisp-> translations 

    Perhaps this is already the case :)

*** TODO Increment OzServer port number automatically (again)

    Avoids simply some problems of users who do not know what they are doing here :)

*** TODO Fix setting of Lisp variable *is-server-running?* 
    
    Currently this variable often contains a wrong value when the OzServer crashed etc

    This is difficult to fix, but once I did this properly then I can actually automatically start the OzServer and users do not need to do that manually any more -- will help users like my students..


** TODO Define ENP score -> Strasheela score			       :NEXT:

   See file:~/PWGL-User/0-TorstensOtherStuff/StrasheelaInterface/ENP2Strasheela.lisp


   
** TODO [#A] Define Strasheela score transformations (instead of plain generation as so far) :NEXT:

   Remember importance of transformations stressed by Tristan Murail in Interview in Hirs' OpenMusic book
   
   See [[file:~/oz/music/Strasheela/strasheela/strasheela/testing/ScoreCore-test.oz::%25%25][file:~/oz/music/Strasheela/strasheela/strasheela/testing/ScoreCore-test.oz::%%]]
   and [[file:~/oz/music/Strasheela/strasheela/strasheela/source/ScoreCore.oz::fun%20{TransformScore2%20MyScore%20Args}][file:~/oz/music/Strasheela/strasheela/strasheela/source/ScoreCore.oz::fun {TransformScore2 MyScore Args}]]
   and [[file:~/oz/music/Strasheela/strasheela/strasheela/examples/ScoreTransformations/ScoreTransformations.oz]]

   Define these transformations in Strasheela with higher-order programming
   Faster to do in Strasheela (and also likely more expressive), so I can focus on their musical use

  See ScoreCore.oz:
  TransformScore TransformScore2
  ? CopyScore CopyScore2

  *I started to define these transformations in ENP after all*
  See ENP doc and defs in Transformations section below

*** Transformations

    Transformation examples 
    
**** TODO Code examples and collect them in Transformations.oz example file   

     see [[file:~/oz/music/Strasheela/strasheela/strasheela/examples/ScoreTransformations/ScoreTransformations.oz]]


**** ? Refactor Score.transform (and method toInitRecord) 

     Arg clauses: 


**** Transform all notes by the same function (mapping)

     Implemented by Score.transformScore (define a clause with test isNote)

     Application examples
       - Transpose the pitch by a constant summand or factor
       - Stretch/shrink durations by a constant summand or factor

       - "Scatter" pitches, but keep the harmony by transposing individual notes or small groups of notes (e.g., non-harmonic notes and the consecutive harmonic note) by a random number of octaves up or down

       - ...


***** ENP 

#+begin_src lisp 
  (def-plug-in transpose-score ((self score) :score-transformations)
    (let ((interval (capi:prompt-for-number "Transposition interval:" :min 1 :initial-value 72)))
      (do-notes (note self) 
                (setf (midi note) (+ (midi note) interval)))))
#+end_src

      Stretch/shrink durations: use Kilian's examples in PWGL quantisation library KSQuant2 (?)
      - involves quantisation
      

**** Transform (or remove) notes with a certain feature, e.g.,

     Implemented by Score.transformScore (define a clause with refined test)

     Feature examples
       - Some parameter (duration, pitch, articulation...) has a certain value or is above/below a certain value, e.g.,
	 - Lengthen all durations that exceed a given thresh-hold by a given summand or factor

       Concrete application examples	  
       - Transpose all notes with a certain duration or more up by a certain interval
       - Transform individual notes that meet certain criteria into chords, e.g.,
	 - Implement transformations inspired by sound processing techniques (e.g., ring modulation, frequency modulation..) by adding the respective notes
       - Transform chords into figurations


**** Remove notes with a certain feature, e.g.,

     Implemented by Score.transformScore (define a clause with refined test that returns a pause/rest object)

     Concrete application examples	  
       - Remove notes that are below a certain pitch threshold (substitute with a rest) 


***** ENP 

      =enp-delete (<score> <object>)=
      a method defined for different classes of <object>: note, voice, beat, measure, part, expression ...


#+begin_src lisp 
;; remove note without substituting
  (def-plug-in delete-notes-below-60 ((self score) :score-transformations)
    (do-notes (note self) 
              (when (< (midi note) 60)
                (enp-delete self note))))
#+end_src      

      
      =(change-rtm-object <orig-object> is-rest)=
      transforms an object (chord or note) into a rest 

      NOTE: after calling this function call =(bring-up-to-date <score> 0.0)=

      =(change-rtm-object <orig-object> is-tied)=
      transforms an object (chord or note) into an object tied over to its previous object (test that there is a previous object)

      =(change-rtm-object <orig-object> <integer>)=
      transforms unit length an object (chord or note) (i.e., "sub-beats" of object)
      I.e., makes it longer/shorter

      
#+begin_src lisp 
  ;; change note/chord into a rest
    (def-plug-in change-notes-below-60-into-rests ((self score) :score-transformations)
      (do-chords (chord self) 
                (when (some #'(lambda (note) (< (midi note) 60)) (notes chord))
                  (change-rtm-object chord is-rest))))
#+end_src      



**** Todo: Transform all notes that meet certain test by same function, where one (or more) function argument(s) change(s) for different notes

     The changes are given as, e.g., 

       - BPF where the value depends on the note's start time (or position in a part)
       - A list of values where the index is the note's position in a part
       - A pattern -- can I somehow have Common Music pattern (possibly form an older Common Music version) important into PWGL/OpenMusic?
       - A function (e.g., a random function)

       Concrete examples: 
       - "Tilt" or otherwise deform the whole score (or certain parts) in pitch, where the pitch change is given as a BPF
       - "Scatter" pitches, but keep the harmony by transposing individual notes or small groups of notes (e.g., non-harmonic notes and the consecutive harmonic note) by octaves up/down, so that the contour of local max/min is controlled by a BPF
       - Transform pitch of score controlled by a special BPF for each of its parts


**** Todo: Transform all notes that meet certain test by same function, where one (or more) function argument(s) depend on the note's list of predecessors/successors (and possibly also some BPF etc as above)

       Concrete examples	  
       - Transpose all notes with a certain duration or more up so that they form local maxima (higher than both predecessor and successor)


**** !! Todo: Transform (or remove) notes with a certain feature, where the feature test function expects an additional arg, e.g., given as BPF, list, PWGL circ-list, pattern or function

       Concrete examples: 
       - Notes that exceed a certain duration are somehow transformed, but the duration threshold changes over time

	 
***** ENP
      
      =(ccl::e <object> <expression-keyword> &rest)= 
      <object> is chord or note
      <expression-keyword> is, e.g., :accent, :slur, ... (can be any expression defined in ENP doc Appendix E)

      returns true if <object> has given type of expression

      Example
      =(ccl:e mynote :accent)=


      =(ccl::e <object> :bpf :id <bpf-id-string>)= 
      
      Returns true if there is a BPF "bpf name" attached to object

 
      =(ccl::e <object> :bpf :sample :at (<object> | <time in sec>) [:id <bpf-id-string>])= 
      <object> is chord or note
      

      Example 
      =(ccl::e my-note :bpf :sample :at my-note :id "bpf name")=

      returns BPF value of BPF "bpf name" at start time of my-note


****** ENP plug-in

#+begin_src lisp 
  (def-plug-in transpose-notes-below-60-with-BPF ((self score) :score-transformations)
    (do-notes (my-note self) 
              ;; no BPF ID given -- uses the first BPF defined for this note
              (let ((interval (ccl::e my-note :bpf :sample :at my-note)))
                (setf (midi note) (+ (midi note) interval)))))
#+end_src

****** ! How to add BPF into score

       - Select chords (not notes) over which BPF should be situated
       - Filter chords out: press c
       - Add expression: press e
       - Type BPF, press return
       - Double-click BPF and then double-click points to add
       - Finishing: press ENTER (not return)

       - Naming BPF: control-click ...
       - You can add BPFs 
	 - make different BPFs active: short cut TAB
	 - show multiple lanes: short cut s (NOTE: do not edit BPFs in that mode)
	 
	
       Note: you can set BPF properties etc. in context menu




**** Todo: Other rough ideas

     - Diminution: e.g., as proposed by Stockhausen's Ausmultipizieren, or (other) fractal techniques substituting, e.g., long notes by certain phrases (ornamentations)
     - Augmentation: e.g., as proposed by Stockhausen, leaving out certain detail 
     - Granular synthesis: short fragments of score (grains) extracted and somehow arranged in time


**** Todo: how can I transform a score depending on another?

     Rough ideas first
     - Convolution (possibly in theory, but I should probably reduce data later..)
     - Some interpolation
     - Some mixing (how? control different "levels", i.e. how much they contribute to final result)
     - Other sound processing inspired ideas: ring modulation, FM (?)




*** Todo: Collect more examples in Hirs' OpenMusic book when she discusses work of Murail


*** Platform							    :ARCHIVE:

    Define these transformations in Strasheela with higher-order programming
    (faster to do in Strasheela, so I can focus on their musical use)

    I may later consider to port them to PWGl/OpenMusic


    - I would have liked to use PWGl/OpenMusic instead, but their music representation interfaces are not sufficiently documented (or not powerful enough, if I use their plain "textual" interface -- I would first need to define various accessors etc)
      - Various [simple] score transformations defined in PWGl/OpenMusic: there the result can be easily displayed in score editor, be further processed... 
      - Consider using PWGLs score scripts for defining score transformations
      - Alternatively/additionally define 1 or more higher-order functions in PWGl/OpenMusic for score transformations 
    - I know the Strasheela representation..
    - Potential problem: I then always deal with variables and propagation, which slows down processing?

**** Info on PWGL scripts

     [I could not find any reference for ENP, so be very careful whether you want to use that for anything slightly larger]

     See PWGL-book.pdf (documentation collection), Section 2.3.5, Scripting

     Scripting uses pattern matching syntax, so for defining arbitrary selections other means are necessary.


***** PWGL script questions 

      - Can objects such as notes be added/removed? 
	Yes, see example 2.3.5.4.3, Chopin-Octaves
      - Changing the rhythm tree: see example 2.3.5.4.4, RTM-Modification


***** Slur all note groups that are separated by rests

Hans,

It's a bit tricky using ENP-script in this case... I'd use the code-box and the following piece of code:

(let (group)
 (dolist (voice (collect-enp-objects score :voice))
   (dolist (chord (collect-enp-objects voice :chord))
     (if (rest-p chord)
         (progn
           (when (cdr group)
             (insert-expression (reverse group) expression))
           (setq group NIL))
       (push chord group)))))

Expression is a keyword naming the expression, e.g., :slur

Mika

On 14.5.2012, at 19:06, Tutschku Hans wrote:

What ENP script syntax should be used to slur all note groups, which are separated by rests?
As the position of the rests and the length of the note groups varies, I can't think of a solution
using index variables. And obviously, single notes between rests should not be slurred.

Any help is very much appreciated.

Best, Hans


** TODO Define Strasheela scripts that expect score as input of which variation will be created :NEXT:

   - These scripts will expect various args, as the Segs sub-CSPs (extended scripts), such as constraints to switch on/off certain constraints 

   - Additional args (funs/procs for flexibility) control what to remove from given score or how to simplify it, e.g.,
     - Remove underlying harmony such as score or scale objects (if given)
     - Reduce absolute pitches to scale degrees, matrix pitch contour, or plain pitch contour or.. (i.e. transform determined pitches to variables with given domain, but apply constraint for pitch contour or whatever)
     - Reduce determined durations to ...

   - Make underlying harmony to add an extra arg (by default harmony will be computed from scratch, but (partially) determined harmony can also be given by users)


** DONE [#A] Add =articulation= parameter (FD) per note	       :NEXT:ARCHIVE:
   CLOSED: [2012-06-06 Wed 01:08]
   
   Consider: define mixin class in ScoreCore.oz, and make this part of standard note class

   The value of this parameter expresses differences between articulations affecting the sounding duration of a note. The value can be, e.g., a percentage unit of measurement. The parameter can be used both for notation and for playback. 

   Possible mapping between ranges of percentages and notation (user-definable mappings, defaults defined in Init.oz)

   staccatissimo: ~ 30 %
   staccato: ~ 50 %
   tenuto:
   non-legato (default): 100 
   legato: 110
   ...

   Notating a legato slur: sequence of legato notes, but last note of slur is non-legato  


   Define symbolic articulation outputs for Fomus 

   Define sound synthesis outputs (MIDI, Csound...) with customised note end



** TODO Debug  MIDI output of legato articulation 		       :NEXT:

   arg removeQuestionableNoteoffs of Out.midi.outputMidiFile does not quite work...
   [[file:~/oz/music/Strasheela/strasheela/strasheela/source/MidiOutput.oz::proc%20{OutputMidiFile%20MyScore%20Spec}][file:~/oz/music/Strasheela/strasheela/strasheela/source/MidiOutput.oz::proc {OutputMidiFile MyScore Spec}]]


** TODO Add constrainable =marks= FS per note 			     :NEXT:

   /Similar approach as constrainable =instruments= FS/, see [[*Add%20constrainable%20%3Dinstruments%3D%20FS%20per%20note][Add constrainable =instruments= FS per note]] 

   Consider: define mixin class in ScoreCore.oz, and make this part of standard note class

   Problems:
   - What about marks that require arguments (e.g., added text) -- shall I simply ignore this option?
   - What about marks that mark a group (e.g., piano pedalling -- a single pedalling mark is not sufficient, as I may want to have a long sequence of pedalled notes, but the pedal needs to be raised at times) 
     

   See Fomus supported marks at http://fomus.sourceforge.net/doc.html/Marks.html#Marks

   
   Also fine-tune notation of grace notes with these marks (duration of grace note, whether or not it is slashed, and allow for grace note chords). See also http://fomus.sourceforge.net/doc.html/Grace-Notes-_0028File_0029.html#Grace-Notes-_0028File_0029


** TODO Add constrainable =instruments= FS per note 		     :NEXT:

   Consider: define mixin class in ScoreCore.oz, but to which note classes to add?

   - Per note add FS, where set elements represent instruments that play this note
     - Same note can be played by multiple instruments simultaneously, so set cardiality can be > 1
   - Some user-defineable tuple (global def) defines mapping of FS integers to instrument names
     - Position in tuple is integer
     - Default value of this tuple contains all instruments defined by Fomus
   - Note argument =instruments= expects either FS or list; list contains instrument names (atoms, must be contained in instrument tuple) 


   Consider defining some resonable constraints, e.g.,
   [Leave these ideas as comments in source file, but do not spend much time, if you may not use this at all]
   - Limit number of sim instruments per note: constrain cardiality of =instruments= FS
   - Limit number of changing instrumentation: min number of consecutive notes any instrument must be engaged (e.g., do not have a note only playing a single note of a melody, but always at least three at a time)
   - Careful: limit pitch domain depending on instrument (I better rely on, say, Sibelius to show me this)
   - Careful: limit possible playing techniques (constrainable [articulation] FS) depending on instrument
     Better control this manually?

   - ?? More complex instrumentation/orchestration constraints (e.g., which instruments fuse well...)
     Likely way too complex. I would need some higher level representation (e.g., some extra analytical objects with more abstract information like how well instruments should fuse etc.)
     -> Save this for extra research project, or do such things manually. 


   - Check whether notation of dynamics still works which changing instrumentation within a single "voice" (seq of notes)

     
*** Problem: I better use FD ints instead of FS, because distribution of FS vars separate

    I could instead have several FD ints... 


** TODO Somehow add tempo statement to score 			     :NEXT:

   Idea: Extra tempo objects added to score
   - Tempo objects running in parallel to other objects in temporal score
   - Changing tempi (accell., rit.) are special objects
   - Output of tempo to Fomus, and also Csound/MIDI is strait forward if there is only a single tempo at any time
   TODO: Integrate existing tempo and timing fenvs  


   Alternative idea, based on OpenMusic approach
   - Add tempo FD integer to temporal objects 
     http://repmus.ircam.fr/openmusic/dev-resources/containers
     If tempo defaults to 60, then I would not at all break compatibility with older Strasheela versions

     However, in contrast to OM, the time unit in Strasheela is always constant, and so would the tempo be. Is that useful? (I cannot have variable time unit or tempo visible within the CSP, because then the result of the temporal accessors could be non-integers)



** TODO [Difficult] Generalise accessors hasTemporalPredecessor, hasTemporalSuccessor :SOON:

   also getTemporalPredecessor, getTemporalPredecessors, getTemporalSuccessor, getTemporalSuccessors, 
   getPredecessorsUpToRest, getSuccessorsUpToRest

   Design goal: such accessors should work over container boundaries 

   Problem:
   - Current definition is for positional and not temporal predecessor/successor and I want to keep it like that (does not block at undetermined score).
   - It would be rather strait forward to say that the predecessor for a note in a seq of seqs, where the note is the first item in a subseq, is the last note in the preceeding seq
   - However, other cases are not so easy
     - What if the corresponding predecessor of a note is container? Should I return the container or its last contained note? 
     - If I generalise these defs, how should I handle simultaneous containers? Only access predecessors of a first object in a container if the container of the container is a sequential? But these are positional accessors, and I should not mix in temporal concerns..

  Hm...     



** Implement morpology (analysis) constraints (proposed by P Aralla etc.)

   See draft at [[file:~/oz/music/Strasheela/tmp/Morphology.oz::%25%25][file:~/oz/music/Strasheela/tmp/Morphology.oz::%%]]


** Revise music representation to allow for efficient distro stratey for pattern motifs with rests (note offset time > 0) :ARCHIVE:

*** Current situation and problem

    A left-to-right distro strategy is often preferrable to avoid redundant work. Also, if a pattern motif constraint is present, the motif indices should be determined early (i.e. before other note parameters effected, e.g., note durations) for an efficient search.

    However, with pattern motifs a left-to-right strategy is currently not possible if pattern motifs also determined note offset times and thus note offset times are undetermined in the problem definition. The problem is that a left-to-right distro strategy needs to recognise parameters of left-most items, and it currently does so by checking whether the start time of the item is determined. If offset times are undetermined, then start times are undetermined as well and the left-most items cannot be identified.   


*** Possible solutions

**** Solution 1

     Check whether end time of predecessor is determined. The problem with this approach is that it does not work for nested scores (predecessors can only be accessed within the same container). 

     It would be possible to extend the definition for accessing predecessors beyond container boundaries (useful in general). However, such definition is difficult (if a sim with 3 seqs is preceeded by a sim with 2 seqs then which note is the predecessor of the first note in the first seq of the second sim?)

     However, for the present problem I would not need an answer for the problem below. If some note is the first note in a container, simply the preceeding container can be returned as predecessor and its start time can be used.

     Perhaps I should def such an accessor directly in the left-to-right distro as aux def:

#+begin_src oz :results output
  
  /** %% Returns the end time of the predecessor of X. If X is top level then result is nil. If X is first element in a sequential container or X is element in a simultaneous container then result the end time of the item preceeding the container. If X is a later element in a sequential container, then the predecessors end time is returned.
  %% */
  %% TODO:
  %%
  %% - revise def (sim/seq distinction unfinished)
  %% - add to a variant of left-to-right distro (leave the orig left-to-right distro, not to unnecessarily break any other CSPs)
  %% - ?? update Mov3_SegA_Melody and it's solver calls (allow for undet offset time again and use new distro)
  fun {GetPredecessorEndTime X}
     C = {X getTemporalContainer($)}
  in
     if C == nil then nil % i.e. top-level 
     else
        if {C isSimultaneous($)} orelse {X getPosition($ C)} == 1
        then {GetPredecessorEndTime C}
           %% X is in seq at a later position
        else {{X getPosRelatedItem($ ~1 C)} getEndTime($)}
        end
     end
  end
#+end_src


**** Solution 2
     
     Extend the set of timing parameters by a parameter that binds (StartTime - OffsetTime), and constrains this parameter implicitly in the defs of sim and seq.

     Problemchen: doing so would blow up all CSPs by a considerable number of unused variables, which are always automatically determined by propagation.

     


** Chord/scale inversion support

   - Pairs of chords/scale objects: add inversion constraint 
   - Make sure that chord/scale databases always contain an inversion of each chord/scale in database
   - Consider to (automatically) add to chord/scale database a feature with the index of the inversion of the chord/scale in question


** TODO Simplify modulation: apply modulation constraints automatically :NEXT:

   Traverse seq of scale objects. For every pair of scales
   - get modulation chord (1st of sim chords of 2nd scale)
   - get the predecessors of this chord -- no depends on arg to modulation constraint
     - these will be the neutral chords


** User-Guided search with percentage of previous solution


Manually controlling the search process by saying that a given percentage of the solution of a CSP is the same as in a given previous solution.
Using method partiallyUnify (currently).



** TODO

  - Redef item method partiallyUnify as proc in ScoreDistribution.oz
    - Proc PartiallyUnify (better name?) needs to expect one fully determined score object (usually from a pickled score) and the actual score from the current CSP
    - Parameters of both scores are first sorted in the order of the current distribution strategy (expect exactly same arg as distro strategy, and reuse distro strategy defs), before the /percentage/ parameters are chosen
      - For this sorting, parameters must be determined, so matTrans all parameters of both scores (which passed test) into pairs [DeterminedScoreParam NewScoreParam], and then sort according by looking at all DeterminedScoreParam
  - Remove method partiallyUnify again (?)
  - def some abstract to "bootstrap" the incremental improvement, by creating a score first (e.g., when given percentage is 0)
  - allow for creating multiple solutions and then to select which to continue (by giving path name extensions)


NOTE: partiallyUnify does not yet work as expected

#+begin_src oz :results output

declare
{GUtils.setRandomGeneratorSeed 0}
MyOldScore = {Out.unpickleScore unit(file:test)}
proc {MyScript MyNewScore}
   MyNewScore = {Score.makeSeq unit(iargs: unit(n: 5
						duration: fd#(1#8)
						pitch: fd#(60#72))
				    timeUnit: beats
				    startTime: 0)}
   {Score.init MyNewScore}
   %% BUG: even with 100 percent "copies" are not equal
   {MyNewScore partiallyUnify(MyOldScore 80
			      test: fun {$ X}
				       {X isPitch($)} orelse
				       {X isTimeInterval($)}
				    end
			     )}
   % {MyNewScore unify(MyOldScore)} % OK
end
[MyScore] = {SDistro.searchOne MyScript
	     unit(value: random)}
{MyScore wait}
{Out.renderFomus MyScore unit(file:test2)}
{Out.pickleScore MyScore unit(file:test2)}

{MyScore isDet($)}

{MyScore toInitRecord($)}

{MyScore map($ toInitRecord test: isParameter)}


{Out.renderFomus {Out.unpickleScore unit(file:test)}
 unit(file:test3)}


{MyOldScore collect($ test: FullTest)}

           
#+end_src


** Accent constraints
   :PROPERTIES:
   :ID:       FCEF953D-4903-4E26-8E2C-1988F46D0C34
   :END:

   Control various musical aspects that emphasise an accent.
   Inspired by Berry, Wallace. 1987. Structural Functions in Music. Courier Dover Publications. Chapter on Rhythm.

*** TODO Further accent constraints from [Berry, 1987] 

    - Large skip into accent, in particular to local max/min, in particular upwards [Berry, 1987, p. 339, point 2]
    - Succession of skips (or intervals in same direction?), in particular upwards, cf. anacrusis [Berry, 1987, p. 339, point 3]

      There are more, see in particular [Berry, 1987, p. 342ff]

  
*** TODO Ideas for further accent constraints 

    Remember: an accent constraint is a function expecting a note/item and returning a rating FD int.

    Many ideas for accent constraints are listed on p. 339ff of Berry, Wallace (1987). /Structural Functions in Music/. Courier Dover Publications. 


**** !!?? Sum of accumulated accent constraint ratings of all notes starting at the same time


**** TODO [#A] Has Anacrusis					    :ARCHIVE:

     Multiple notes "lead" to argument note. This is a very important accent constraint, but it is difficult to formalise.

***** Main problem and solution: how to formalise this score context?

      - How many preceding notes should be included in the score context?
	- I could go for the minimum: 1-2 notes to have the condition fulfilled
	- I could require more notes for marking the accent stronger (may need some constraint that forces such accents)

      Pragmatic solution: 
      - Rated accent constraint: the more notes fulfil the condition the higher the rating
      - The number of notes considered should be user-definable (i.e., fun Make_HasAnacrusis with relevant args returns accent constraint)

      Alternative solution
      - Anacrusis context option: go back up to the last previous note with offset time > 0

       	
***** Features of an anacrusis

      - Primarily/all intervals between notes before in one direction (in particular upwards)
      - Usually notes of anacrusis are shorter than the accent, at least they should not be longer
      - Commonly the notes of the anacrusis are of uniform duration
	- Exception: embellished anacrusis (example of Richard Strauss in /Structural Functions in Music/, p. 420 (endnote g)
	- ?? Alternative: durations get shorter towards accent


***** Implementation

      - Different context options can be choosen by optional arg
	- Simple version: all elements of this score context fulfill anacrusis features 
	- Simple version: the last N elements of this score context fulfill anacrusis features, N is resulting rating 
      - List of constraints (reified procs) decribes features of anacrusis

#+begin_src oz :results output
  
  /** %% Make_HasAnacrusis returns an accent constraint, i.e. a function execting a note/item N and returning a rating FD int. The resulting function returns a positive rating for N preceeded by an anacrusis, and 0 otherwise.
  %%
  %% Args:
  %% context (record function, default predecessorsUpToRest): This argument specifies the score context that potentially forms an anacrusis of N. If 'predecessorsUpToRest', then the notes before N up to any rest (offset time or pause object) are taken into account (within the same temporal container). If predecessors(I), then the I (an int) notes before N are taken into account (within the same temporal container). The context can also be defined by a unary function expecting N and returning the items as a list.
  %% ratingPs (list of constraints {P Xs ?Rating}, default nil): This argument specifies how the quality (rating) of an anacrusis is measured. Each ratingP is a function that expects a list of notes starting with N, then its predecessor and so forth. Each function returns a rating (an FD int). The resulting accent constraint rating is the minimum rating of any ratingP (subject to requirements, see below). Example constraint: N predecessors are of equal length (Anacrusis_FirstNEvenDurations).
  %% requirements (list of reified constraints {P Xs B}, default nil): This argument specifies requirements that must be met by the score context if it should count at all as an anacrusis. Each requirement is a function that expects a list of notes starting with N, then its predecessor and so forth. Each function returns a 0/1-int. If any requirement returns 0 then the accent constraint returns 0 for this note. If all requirements returns 1, then the value resulting from the ratingPs is returned as rating. Example constraint: N longer than its predecessor (Anacrusis_LongerThanPrevious).
  %%
  %% Note: if neither ratingPs nor requirements are given then the accent constraint returns the rating 1 for all notes.
  %% */
  fun {Make_HasAnacrusis Args}
     Defaults = unit(context: predecessorsUpToRest
                     ratingPs: nil
                     requirements: nil)
     As = {Adjoin Defaults Args}
     proc {$ N ?Rating}
        Context = if {IsProcedure As.context}
                  then {As.context N}
                  else case {Label As.context} of
                          predecessorsUpToRest then {N getPredecessorsUpToRest($)}
                       [] predecessors then {N getTemporalPredecessors($ As.context.1)}
                       end
                  end
        FeatsRating = {FD.decl}
        RequirementsB = {FD.int 0#1}
     in
        Rating = {FD.decl}
        FeatsRating =: case As.ratingPs of nil then 1
                       else {Pattern.min {Map As.ratingPs fun {$ F} {F Context} end}}
                       end
        RequirementsB =: {Pattern.allTrueR {Map As.requirements fun {$ F} {F Context} end}}
        Rating =: FeatsRating * RequirementsB
     end
  end
  
  
  
  /** %% [anacrusis requirement] The duration of the 1st note in Ns is longer then the 2nd.
  %% */
  fun {Anacrusis_LongerThanPrevious Ns}
     ({Ns.1 getDuration($)} >: {Ns.2.1 getDuration($)})
  end
  
  
  local
     fun {ShorterThanAccentRs Ns}
        N1 = Ns.1
     in
        {Map Ns.2 fun {$ N2} ({N2 getDuration($)} <: {N1 getDuration($)}) end}
     end   
  in
     /** %% [anacrusis requirement] B=1 <-> All durations of notes in Ns (a list of notes) are shorter than the accent (the first note in Ns).
     %% */
     Anacrusis_ShorterThanAccent = {MakeRequirement ShorterThanAccentRs}
     /** %% [anacrusis ratingP] The first Rating (an FD int) durations of notes in Ns (a list of notes) are shorter than the accent (the first note in Ns).
     %% */
     Anacrusis_FirstNShorterThanAccent = {MakeRatingP ShorterThanAccentRs}
  end
  
  local
     fun {NoLongerThanAccentRs Ns}
        N1 = Ns.1
     in
        {Map Ns.2 fun {$ N2} ({N2 getDuration($)} =<: {N1 getDuration($)}) end}
     end   
  in
     /** %% [anacrusis requirement] B=1 <-> All durations of notes in Ns (a list of notes) are no longer than the accent (the first note in Ns).
     %% */
     Anacrusis_NoLongerThanAccent = {MakeRequirement NoLongerThanAccentRs}
     /** %% [anacrusis ratingP] The first Rating (an FD int) durations of notes in Ns (a list of notes) are no longer than the accent (the first note in Ns).
     %% */
     Anacrusis_FirstNNoLongerThanAccent = {MakeRatingP NoLongerThanAccentRs}
  end
  
  local
     fun {PossibilyShorterTowardsAccentRs Ns}
        {Pattern.map2Neighbours {Map Ns.2 {GUtils.toFun getDuration}}
         fun {$ D1 D2} (D1 =<: D2) end}
     end   
  in
     /** %% [anacrusis requirement] B=1 <-> All notes in Ns (a list of notes) except the first (the accent) have the same duration among themselves or they become shorter towards the accent.
     %% */
     Anacrusis_PossibilyShorterTowardsAccent = {MakeRequirement PossibilyShorterTowardsAccentRs}
     /** %% [anacrusis ratingP] The first Rating (an FD int) notes in Ns (a list of notes) except the first (the accent) have the same duration among themselves or they become shorter towards the accent.
     %% */
     Anacrusis_FirstNPossibilyShorterTowardsAccent = {MakeRatingP PossibilyShorterTowardsAccentRs}
  end
  
  local
     fun {EvenDurationsRs Ns}
        {Pattern.map2Neighbours {Map Ns.2 {GUtils.toFun getDuration}}
         fun {$ D1 D2} (D1 =: D2) end}
     end   
  in
     /** %% [anacrusis requirement] B=1 <-> All notes in Ns (a list of notes) except the first (the accent) have the same duration.
     %% */
     Anacrusis_EvenDurations = {MakeRequirement EvenDurationsRs}
     /** %% [anacrusis ratingP] The first Rating (an FD int) notes in Ns (a list of notes) except the first (the accent) have the same duration.
  %% */
     Anacrusis_FirstNEvenDurations = {MakeRatingP EvenDurationsRs}
  end
  
  
  local
     fun {UpwardPitchIntervalsRs Ns}
        {Pattern.map2Neighbours {Map Ns {GUtils.toFun getPitch}}
         fun {$ P1 P2} {Pattern.directionR P1 P2 2} end}
     end   
  in
     /** %% [anacrusis requirement] B=1 <-> All interval directions between the pitches of notes in Ns (a list of notes) are upwards.
     %% */
     Anacrusis_UpwardPitchIntervals = {MakeRequirement UpwardPitchIntervalsRs}
     /** %% [anacrusis ratingP] The first Rating (an FD int) interval directions between the pitches of notes in Ns (a list of notes) are all upwards.
     %% */
     Anacrusis_FirstNUpwardPitchIntervals = {MakeRatingP UpwardPitchIntervalsRs}
  end
  
  local
     fun {SameDirectionPitchIntervalsRs Ns}
        {Pattern.map2Neighbours
         {Pattern.map2Neighbours {Map Ns {GUtils.toFun getPitch}}
          fun {$ P1 P2} {Pattern.direction P1 P2} end}
         fun {$ Dir1 Dir2} (Dir1 =: Dir2) end}
     end   
  in
     /** %% [anacrusis requirement] B=1 <-> All interval directions between the pitches of notes in Ns (a list of notes) move in the same direction (upwards, downwards or repetition).
     %% */
     Anacrusis_SameDirectionPitchIntervals = {MakeRequirement SameDirectionPitchIntervalsRs}
     /** %% [anacrusis ratingP] The first Rating (an FD int) interval directions between the pitches of notes in Ns (a list of notes)  move all in the same direction (upwards, downwards or repetition).
     %% */
     Anacrusis_FirstNSameDirectionPitchIntervals = {MakeRatingP SameDirectionPitchIntervalsRs}
  end
  
  
  
  
  
  
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%
  %%% Anacrusis aux defs 
  %%%
  
  
  /** %% Expects a reified constraint {P Ns ?Bs} that expects a list of notes and returns a list of 0/1-ints. MakeRequirement returns an anacrusis requirement procedure (see doc of Make_HasAnacrusis).
  %% */
  fun {MakeRequirement P}
     fun {$ Ns Rating} {Pattern.allTrue {P Ns}} end
  end
  /** %% Expects a reified constraint {P Ns ?Bs} that expects a list of notes and returns a list of 0/1-ints. MakeRatingP returns an anacrusis ratingP procedure (see doc of Make_HasAnacrusis).
  %% */
  fun {MakeRatingP P}
     fun {$ Ns Rating}
        Rating = {FD.decl}
        Rating = {Pattern.firstNTrue {P Ns}}
     end
  end
  
  
  
#+end_src



**** Accent constraints that look at larger context of notes

     *Is this already covered by Anacrusis? Do I also need to look at larger context "behind" a given note?*

     - E.g., highest note of a bar, or a phrase etc. is particular important

     - Problem: how to formalise this score context?
       for a pragmatic solution see [[*%5B#A%5D%20Has%20Anacrusis][Has Anacrusis]]


**** ? Longest note within a phrase (surrounded by rests)

**** ?? Starts with chord/scale change

     Wallace Berry claims that chord changes are irrelevant for accents, but in case of a slower harmonic rhythm I would not readily agree. 

     Scale change marks definitely an accent  


**** ?? Has Ornament

     Idea is similar to anacrusis. Implementation irrelevant as long as I have not somehow introduced ornaments such as grace notes or trills in the music representation.

     
**** ??? HasDynamicAccent

     With a reasonably intelligent representation of dynamics and articulations such an accent constraint could be defined.
     Such accent constraint would primarily useful for higher-level accents (i.e. not simply on a level of regular measures)

     Note: the dynamics support of Fomus could be useful in this respect


*** TODO 

    - !! Finalise definition NoteAtMetricPosition (or clearly document what is missing)

    - Further accent constraints:
      - Semitone leading to accent
      - ? Only steps form an anacrusis preceeing the accent
      - ? Only intervals in the same direction, except for the last two intervals, but these are steps
      - ?? Syncopation at beat level
      - Add rest (pause object or offset time) after accent to its duration 

    - Application examples
      - !! Write these examples as scetches for organ composition
      - ?? Fomus output: revise rating display. Add accumulated accent constraint rating to notes as additional param and display that value in music notation
	- Easy reuse: add note param within Accent_If
    - Further anacrusis constraints:
      - Only steps
      - Direction of all intervals except the but-last two are upwards, and the last two intervals are steps

**** Old 

    - OK Test with rests (offset times)
    - OK Predefine accent constraints
    - OK: Copy these definitions into the functor Measure.
    - OK Documentation: add ideas for further accent constraints; see my notes on paper and Structural Functions in Music, p. 339ff

    - OK Examples in extra ./examples/ file (including output defs)
    - OK Update list of changes
    - OK Upload to SVN repository


*** !! Output defs

#+srcname: output
#+begin_src oz :results output
  
  %%
  %% The Fomus output also prints accent ratings > 0 for notes that inherited the accent rating mixing 
  %%
  
  declare
  
  /** %% [Note markup function] Expects two Fomus markup records (e.g., unit(marks: ['x "x"']), the value returned by MakeNonChordTone_FomusMarks) and returns a single record with those marks combined.  
  %% */
  %% TODO: save in core Output.oz or contributions/anders/HarmonisedScore/source/Output.oz
  fun {AppendFomusMarks Mark1 Mark2}
     Ms1 = {Value.condSelect Mark1 marks nil} 
     Ms2 = {Value.condSelect Mark2 marks nil}
  in
     %% TMP:
     {Browse AppendFomusMarks#{Adjoin unit(marks: {Append Ms1 Ms2})
      {Adjoin Mark1 Mark2}}}
     {Adjoin unit(marks: {Append Ms1 Ms2})
      {Adjoin Mark1 Mark2}}
  end
  
  
     /** %% [markup function] Expects a VS and returns a Fomus markup record.
     %%
     %% Args:
     %% 'where' (default 'x'): atom in Fomus syntax where to position the VS (e.g., 'x', 'x^', 'x_' or 'x!', see http://fomus.sourceforge.net/doc.html/Articulation-Markings-_0028File_0029.html#Articulation-Markings-_0028File_0029). 
  %% */
  %% TODO: save in core Output.oz or contributions/anders/HarmonisedScore/source/Output.oz
     fun {VsToFomusMarks VS Args}
        Default = unit(where: 'x')
        As = {Adjoin Default Args}
     in
        if {Not {IsVirtualString VS}}
        then raise noVS(VS) end
           unit % never returned 
        else unit(marks: [As.where#" \""#VS#"\""])
        end
     end
     
  LilyHeader 
  = {VirtualString.toString
      {Out.listToLines
     ["\\paper {"
     " indent=0\\mm"
     " line-width=180\\mm" 
     " oddFooterMarkup=##f"
     " oddHeaderMarkup=##f"
     " bookTitleMarkup=#ff"
     " scoreTitleMarkup=##f"
      " }"
      ""
      "\\layout {"
      "\\context {"
      "\\Voice \\remove \"Note_heads_engraver\""
      "\\remove \"Forbid_line_break_engraver\""
      "\\consists \"Completion_heads_engraver\""
      "}"
      "} "
      ""
  %     "\\score{\n{\n"
     ]}}
  
  proc {RenderFomus MyScore Args}
     %% TMP (replace by new method addToInfoRecord)
     %% TODO: make this optional
     {MyScore
      addInfo(fomus('lily-file-header': LilyHeader
                    'lily-exe-args': '("--png" "--pdf" "-dbackend=eps" "-dno-gs-load-fonts" "-dinclude-eps-fonts")'
                    % 'lily-exe-args': '("--format=png" "--format=pdf")'
                    % 'lily-exe-args': '("-dbackend=eps")'
                   ))}
     {Out.renderFomus MyScore
      {Adjoin unit(eventClauses:
                      [ %% for HS notes
                       {HS.out.makeNoteToFomusClause
                        unit(% getPitchClass: midi
                             table: ET31.out.fomusPCs_DoubleAccs
                             % table:ET31.out.fomusPCs_Quartertones
                             getSettings:
                                fun {$ N}
                                   TextMarks = {VsToFomusMarks {N getAccentRating($)}
                                                unit(where: 'x')}
                                in
                                   {AppendFomusMarks TextMarks {HS.out.makeNonChordTone_FomusMarks N}}
                                end)}
                        %% for plain notes
                        Measure.isAccentRatingMixin
                        #fun {$ N PartId}
                            TextMarks = if {N getAccentRating($)} > 0
                                        then {VsToFomusMarks {N getAccentRating($)}
                                                    % 'ar:'#{N getAccentRating($)}
                                              unit(where: 'x^')}
                                        else unit
                                        end
                         in
                            {Out.record2FomusNote {Adjoin TextMarks
                                                   unit(part:PartId
                                                        time:{N getStartTimeInBeats($)}
                                                        dur:{N getDurationInBeats($)}
                                                        pitch:{N getPitchInMidi($)})}
                             N}
                         end
                        %% chords
                       {HS.out.makeChordToFomusClause
                        unit(% getPitchClass: midi
                             table: ET31.out.fomusPCs_DoubleAccs
                             getSettings:HS.out.makeChordComment_FomusForLilyMarks)}
                        %% scales
                       {HS.out.makeScaleToFomusClause
                        unit(% getPitchClass: midi
                             table: ET31.out.fomusPCs_DoubleAccs
                             getSettings:HS.out.makeScaleComment_FomusForLilyMarks)}
                       {Measure.out.makeUniformMeasuresToFomusClause unit(explicitTimeSig: false)}])
       Args}}
  end
  
  
  {Explorer.object
   add(information
       proc {$ I X}
          if {Score.isScoreObject X}
           then 
              FileName = out#{GUtils.getCounterAndIncr}
           in
              {Out.renderAndPlayCsound X
               unit(file: FileName
                    title:I)}
             {RenderFomus X unit(file: FileName)}
           end
       end
       label: 'to Csound and Fomus (with measures and accent ratings)')}
  
  {Explorer.object
   add(information
       proc {$ I X}
          if {Score.isScoreObject X}
           then 
              FileName = out#{GUtils.getCounterAndIncr}
           in
             {RenderFomus X unit(file: FileName)}
           end
       end
       label: 'to Fomus (with measures and accent ratings)')}
  
#+end_src



*** General constraint applicator				    :ARCHIVE:

#+srcname: applicator
#+begin_src oz :results output
  
  declare    
  
  /** % [0/1 Constraint] Returns 0/1-integer whether Time (FD int) is between the start and end time of X (an temporal item), including its start but note the end time.
  %% */
  proc {AtTimeR X Time ?B}   
     {FD.conj ({X getStartTime($)} =<: Time) (Time <: {X getEndTime($)}) B}
  end
  
  /** % [0/1 Constraint] Same as AtTimeR, but the time frame of X takes also the potential rest introduced by its offset time into account.
  %% */
  proc {AtTimeR2 X Time ?B}        
     StartX = {FD.decl}
  in
     StartX =: {X getStartTime($)} - {X getOffsetTime($)} 
     {FD.conj (StartX =<: Time) (Time <: {X getEndTime($)}) B}
  end
   
  /** %% With Accent_If various musical aspects and parameters can be constrained so that the resulting music expresses the underlying metric structure (simultaneous measure objects). This constraint is inspired by the chapter on rhythm in Berry, Wallace. 1987. Structural Functions in Music. Courier Dover Publications. 
  %% The start time of N coincides with the given "position" in a simultaneous measure (e.g., the measure's start or any accentuated beat), if given a list of given conditions is fulfilled well enough. These conditions (AccentConstraints) are a list of unary functions: the input is N and the return value is a rating of N (an FD int), where 0 means condition not fulfilled and higher values mean that the condition is increasingly better fulfilled. The sum of the return values of all conditions must be equal or exceed a given threshold (arg minRating) in order to trigger that the start time of N is constrained to a certain metric position. Predefined accent constraints include IsLongerThanSurrounding and IsHigherThanSurrounding (see their documentation for further details).
    %%
    %% Args:
    %%
    %% metricPosition (FD int or atom, default 'accent'): if N sufficiently meets the conditions, then its start time is constrained to this "position" in the measure. The following values are supported.
    %%   measureStart: N starts with a measure
    %%   accent: N starts with a strong beat (depends on the measure definition)
    %%   beat: N starts with a beat
    %%   an FD int: N starts at a specified time within a measure (e.g., if 0 then N starts on measure start, if 1 it starts on measure start + 1 etc.). Should not be larger than the measure duration.
    %%
  %% minRating (FD int, default 1): Minimum accumulated rating of accent constraint outputs. If the sum of the return values of all accent constraints are equal or exceed a minRating, then in order the start time of N is constrained to the metric position metricPosition.
    %%
    %% strictness (atom, default 'note'): Must the constrained be fulfilled for all notes meeting the criteria or for all given metric positions? There are three different cases.
    %%   note: every note/item meeting the accent criteria are on a specified metric position, but there can also be such metric positions without notes meeting such criteria
  %%   position: every note at a specified metric position must meet the accent criteria, but there can also be such notes at other positions
  %%   noteAndPosition: every note/item meeting the accent criteria in on a specified metric position and vice versa
  %% NOTE: no value of strictness enforces that there actually is a note at any metric position specified in metricPosition. Use the constraint NoteAtMeasurePosition for this purpose.
    %%
    %% toplevel (default false): The container in which N is contained that should be considered the top level for finding the simultaneous measure object (if false, then the whole score is searched). This argument is for optimisation purposes only.
    %%
  %% measureTest (default Measure.isUniformMeasures): A Boolean function that returns true for the relevant measure objects. (currently only works with uniform measures?)
  %%
  %% rating (an FD int): this argument is bound to the accumulated rating of accent constraint outputs for N. This variable can that way be constrained outside the call of Accent_If (e.g., to constrain the accent structure of some musical section, the number of occurances of some minumum rating or the minimum sum of ratings over multiple notes can be constrained).
  %%
  %% */
  %% 
    proc {Accent_If N AccentConstraints Args}
       Defaults = unit(metricPosition: accent 
                       minRating: 1
                       %% The following is likely too complicated, and not quite worth the effort
                      % %% Minimum number of accent constraints involved. Note: must be =< than {Length AccentConstraints}. If < than {Length AccentConstraints}, then an accent constraint is applied if at least the given number of AccentConstraints return a value > 0 for N.
                      % minConstraints: 1
                       strictness: note
                       measureTest: Measure.isUniformMeasures
                       toplevel: false
                       rating: _)
       As = {Adjoin Defaults Args}
       Relation = case As.strictness of
                     note then FD.impl
                  [] position then proc {$ B1 B2 B3} {FD.impl B2 B1 B3} end
                  [] noteAndPosition then FD.equi
                  end
    in
       thread
          SimMeasure = {N findSimultaneousItem($ test:As.measureTest toplevel:As.toplevel)}
          MeasureConstraint
          = if {FD.is As.metricPosition}
            then
               proc {$ N ?B}
                  B = ({FD.modI {N getStartTime($)} {SimMeasure getMeasureDuration($)}}
                       =: As.metricPosition)
               end
            else 
               case As.metricPosition of
                  measureStart then proc {$ N ?Result}
                                       {SimMeasure onMeasureStartR(Result {N getStartTime($)})}
                                    end
               [] accent then proc {$ N ?Result}
                                 {SimMeasure onAccentR(Result {N getStartTime($)})}
                              end
               [] beat then proc {$ N ?Result}
                               {SimMeasure onBeatR(Result {N getStartTime($)})}
                            end
               end
            end
          ConstraintRating = {FD.decl}
       in
          ConstraintRating = As.rating
          ConstraintRating = {FD.sum {Map AccentConstraints
                                      proc {$ Constraint ?Rating}
                                         Rating = {FD.decl}    % just in case...
                                         {Constraint N Rating}
                                      end}
                              '=:'}
          {Relation (ConstraintRating >=: As.minRating)
           {MeasureConstraint N}
           1}
       end
    end
  
  
    /** %%
    %% Measure (a Measure.uniformMeasures instance) 
    %% Args:
    %% metricPosition (FD int or atom, default 'accent'):
    %%   measureStart: one or more element of Notes starts with Measure
    %%   accent: one or more element of Notes starts with any accent of Measure
    %%   beat: one or more element of Notes starts with any beat
    %%   an FD int: one or more element of Notes starts at a specified time within a measure (e.g., if 0 then N starts on measure start, if 1 it starts on measure start + 1 etc.). Should not be larger than the measure duration.
    %%
    %% allowRestsAtMetricPosition (Boolean, default false): if true, then instead a note start there can be a rest at the metric positions in question introduced by a note's offset time > 0. 
    %%
    %% ?? Note: constraint application delayed until Measure is fully determined.
    %% */
    %% TODO:
    %% - some mini language that allows to specify a subset of positions or -- even better -- some pattern of the total number of metric positions in question.
    proc {NoteAtMetricPosition MyMeasure Notes Args}
       Defaults = unit(metricPosition: accent
                       allowRestsAtMetricPosition: false)
       As = {Adjoin Defaults Args}
       %% list of the start times of all individual measures in MyMeasure
       MeasureStarts = {List.number {MyMeasure getStartTime($)}
                        {MyMeasure getEndTime($)}
                        {MyMeasure  getMeasureDuration($)}}
    in
       if {FD.is As.metricPosition}
       then
          skip %% TODO:
       else
          %% ?? TODO: revise: only use sim notes of Measure -- can I do that
          %% All I want is that any propagator that can never be met is removed -- probably done automatically anyway
          case As.metricPosition of
             measureStart
          then {ForAll MeasureStarts
                proc {$ MyStart}
                   thread
                      SimNotes = {LUtils.cFilter Notes
                                  fun {$ N}
                                     AtTimeR_Proc = if As.allowRestsAtMetricPosition
                                                    then AtTimeR
                                                    else AtTimeR2
                                                    end
                                  in 
                                     {AtTimeR_Proc N MyStart} == 1
                                  end}
                   in
                      if SimNotes \= nil
                      then
                         {FD.sum {Map SimNotes
                                  fun {$ N} ({N getStartTime($)} =: MyStart) end}
                          '>:' 0}
                      end
                   end
                end}
          [] accent then %% TODO:
             skip
             % {FS.int.match {Measure getAccentsFS($)}
             % Accents}
             
          [] beat then %% TODO:
             skip
             % {FS.int.match {Measure getBeatsFS($)}
             %  Beats}
             
             % {FS.forAllIn {Measure getBeatsFS($)}
             %  proc {$ MyBeat} end}
             
          end
       end
    end
    
#+end_src
    


*** Application examples

**** Example with only a single simple accent constraint	    :ARCHIVE:

#+begin_src oz :results output
    
  %%
  %% Example with only a single simple accent constraint:
  %% Notes that are at least of duration quarter note count as accentuated notes.
  %% Every accented note must be on a metric accent of 5/4, but there can be metric accents without such notes. 
  %% (which is by default the 1st and 4th beat).
  %% 
      
  declare
  Beat = 4
  proc {MyScript MyScore}
     MyScore = {Score.make sim([seq([note note note note note note note note
                                     note note note note note note note note])
                                seq([measure(n: 8
                                             beatNumber: 5
                                             beatDuration: Beat)])]
                               startTime:0
                               timeUnit:beats(Beat))
                add(note: fun {$ _}
                             {Score.make2 note(duration: {FD.int [2 4]}
                                               pitch: {FD.int 60})
                              unit(note:Measure.note)}
                          end
                    measure: Measure.uniformMeasures)}
     %% 
     {ForAll {MyScore collect($ test:isNote)}
      proc {$ N}
         {Measure.accent_If N [{Measure.make_HasAtLeastDuration Beat}] 
          %% BUG: strictness position can result in matching metric positions that are not expressed by matching note, but this happens seemingly rarely. 
          unit(strictness: note % note position noteAndPosition
               metricPosition: accent % Beat*2 beat accent measureStart
              )}
      end}      
  end
  
  {GUtils.setRandomGeneratorSeed 0}
  {SDistro.exploreOne MyScript
   unit(order:leftToRight
        value:random)}
  
  /*
  
  declare
  {GUtils.setRandomGeneratorSeed 0}
  [MyScore] = {SDistro.searchOne MyScript
               unit(order:leftToRight
                    value:random)}
  
  {MyScore toInitRecord($)}
  
  ,*/
  
#+end_src


**** Test with rests						    :ARCHIVE:

#+begin_src oz :results output
   
  declare
   Beat = 4
    
  /** %% Definition of a simple accent constraint. An accent constraint expects a note (an item) and returns a rating, where higher values mean that the accent constraint's condition is met better by N. In this simple case, IsAtLeastQuarterNote returns 1 for a note with a note value of a beat or more and 0 otherwise.  
  %% */
   fun {IsAtLeastQuarterNote N}
      ({N getDuration($)} >=: Beat)
   end
     
   {GUtils.setRandomGeneratorSeed 0}
     {SDistro.exploreOne
      proc {$ MyScore}
         MyScore = {Score.make sim([seq([note note note note note note note note
                                         note note note note note note note note]
                                        offsetTime: {FD.int [0 Beat Beat+(Beat div 2)]})
                                    seq([measure(n: 8
                                                 beatNumber: 5
                                                 beatDuration: Beat)])]
                                  startTime:0
                                  timeUnit:beats(Beat))
                    add(note: fun {$ _}
                                 {Score.make2 note(duration: {FD.int [(Beat div 2) Beat]}
                                                   pitch: {FD.int 60}
                                                  offsetTime: {FD.int [0 Beat Beat+(Beat div 2)]})
                                  unit(note:Measure.note)}
                              end
                        measure: Measure.uniformMeasures)}
         %% 
         {ForAll {MyScore collect($ test:isNote)}
          proc {$ N}
             {Measure.accent_If N [IsAtLeastQuarterNote] % Measure.isLongerThanSurrounding
              unit(strictness: noteAndPosition % note position noteAndPosition
                   metricPosition: measureStart % Beat*2 beat accent measureStart
                  )}
          end}
         %% Restrict total sum of offset times 
         %% Without heuristic constraints, most rests will be in the beginning (a relevant heursitic constraint would require also distributing the offset times)
         Beat*5 >: {LUtils.accum {MyScore map($ getOffsetTime test:isNote)}
                    FD.plus}
      end
      unit(order:leftToRight
           value:random)}
     
#+end_src


**** TODO Example with upbeat: suitable offset time of the seq containing the notes


**** TODO Example with reasonably low minRating of Accent_If, but additionally some ratings are constrained to be higher (with Pattern.howManyTrue where how many is at least a certain value)

     Potential problem: those higher ratings are all clustered at the end of the example, because search fixes only the end


**** TODO Revise: IsLongerThanSurrounding_Rated

#+begin_src oz :results output
  
  declare
  Beat = 4
    
  {GUtils.setRandomGeneratorSeed 0}
    {SDistro.exploreOne
     proc {$ MyScore}
        MyScore = {Score.make sim([seq([note note note note note note note note
                                        note note note note note note note note])
                                   seq([measure(n: 8
                                                beatNumber: 3 % 4 5
                                                beatDuration: Beat)])]
                                 startTime:0
                                 timeUnit:beats(Beat))
                   add(note: fun {$ _}
                                {Score.make2 note(duration: {FD.int [1 2 4]}
                                                  pitch: {FD.int 60}
                                                  offsetTime: {FD.int [0 1 2 4]}
                                                 )
                                 unit(note: Measure.note)}
                             end
                       measure: Measure.uniformMeasures)}
     %% NOTE: 1st note with forced accent rating. Otherwise, its rating may be unconstrained and thus some random value
     {{MyScore collect($ test:isNote)}.1 getAccentRating($)} = 0
        %% 
        {ForAll {MyScore collect($ test:isNote)}.2 % !! NOTE: skip 1st note! 
         proc {$ N}
            {Measure.accent_If N [Measure.isLongerThanSurrounding_Rated] 
             unit(strictness: note % note position noteAndPosition
                  metricPosition: beat % Beat*2 beat accent measureStart
                  minRating: 2
                 )}
         end}
        %% no syncopations at beat level
        {ForAll {MyScore collect($ test:isNote)}.2 % !! NOTE: skip 1st note! 
         proc {$ N}
            thread 
               M = {N getSimultaneousItems($ test: Measure.isUniformMeasures)}.1
            in
               0 = {M beatSyncopationR($ {N getStartTime($)} {N getEndTime($)})}
            end
         end}
        %% There should be notes at specified metric positions
        % {ForAll {MyScore collect($ test:Measure.isUniformMeasures)}
        %  proc {$ M}
        %     {Measure.noteAtMetricPosition M {MyScore collect($ test:isNote)}
        %      unit(metricPosition: measureStart
        %           allowRestsAtMetricPosition: true)}
        %  end}
        %% Restrict total sum of offset times 
        %% Without heuristic constraints, most rests will be in the beginning (a relevant heursitic constraint would require also distributing the offset times)
        Beat >: {LUtils.accum {MyScore map($ getOffsetTime test:isNote)}
                 FD.plus} 
     end
     unit(order:leftToRight
          value:random)}
    
#+end_src


**** Example with anacrusis					    :ARCHIVE:

Simple case

#+begin_src oz :results output
       
  declare
  Beat = 4
  proc {MyScript MyScore}
     Ns
  in
     MyScore = {Score.make sim([seq([note note note note note note note note
                                     note note note note note note note note]
                                    offsetTime: {FD.int 12#19})
                                seq([measure(n: 8
                                             beatNumber: 5
                                             beatDuration: Beat)])]
                               startTime:0
                               timeUnit:beats(Beat))
                add(note: fun {$ _}
                             {Score.make2 note(duration: {FD.int [1 2 4]}
                                                pitch: 60)
                              unit(note:Measure.note)}
                          end
                    measure: Measure.uniformMeasures)}
     Ns = {MyScore collect($ test:isNote)}
     %% 
     {ForAll Ns
      proc {$ N}
         {Measure.accent_If N [{Measure.make_HasAnacrusis
                                unit(ratingPs: [Measure.anacrusis_FirstNEvenDurations]
                                     requirements: [Measure.anacrusis_AccentLonger])}] 
          unit(strictness: note % note position noteAndPosition
               metricPosition: beat % Beat*2 beat accent measureStart
              )}
      end}
     %% NOTE: 1st note with forced accent rating. Otherwise, its rating may be unconstrained and thus some random value
     {Ns.1 getAccentRating($)} = 0
  end
  
  {GUtils.setRandomGeneratorSeed 0}
  {SDistro.exploreOne MyScript
   unit(order:leftToRight
        value:random)}
  
#+end_src

Additional constraints: 
 - pitch affects anacrusis as well
 - require a minimum number of higher accent ratings
 - ensure that the 1st note is not syncopated


#+begin_src oz :results output
        
    declare
    Beat = 4
    proc {MyScript MyScore}
       Ns Measures
    in
       MyScore = {Score.make sim([seq([note note note note note note note note
                                       note note note note note note note note]
                                      offsetTime: {FD.int 12#19})
                                  seq([measure(n: 8
                                               beatNumber: 5
                                               beatDuration: Beat)])]
                                 startTime:0
                                 timeUnit:beats(Beat))
                  add(note: fun {$ _}
                               {Score.make2 note(duration: {FD.int [1 2 4]}
                                                 pitch: {FD.int 60#72}
                                                )
                                unit(note:Measure.note)}
                            end
                      measure: Measure.uniformMeasures)}
       Ns = {MyScore collect($ test:isNote)}
       [Measures] = {MyScore collect($ test:Measure.isUniformMeasures)}
       %% 
       {ForAll Ns
        proc {$ N}
           {Measure.accent_If N [{Measure.make_HasAnacrusis
                                  unit(requirements: [Measure.anacrusis_AccentLonger]
                                       ratingPs: [Measure.anacrusis_FirstNPossibilyShorterTowardsAccent
                                                  Measure.anacrusis_FirstNUpwardPitchIntervals])}] 
            unit(strictness: note % note position noteAndPosition
                 metricPosition: beat % Beat*2 beat accent measureStart
                )}
        end}
       %% Num1+Num2 notes have at least an accent rating of 3
       local
          Num1 = 1
          Num2 = 2
          L = {Length Ns}
          Ns1 Ns2
       in
  %%  Make search cheaper by explicitly constraining that a certain amount of higher accent ratings is in certain sections of Ns 
          {List.takeDrop Ns (L div 2) Ns1 Ns2}
          {Pattern.howManyTrue {Map Ns1
                                fun {$ N} {N getAccentRating($)} >=: 3 end}
           Num1}
          {Pattern.howManyTrue {Map Ns2
                                fun {$ N} {N getAccentRating($)} >=: 3 end}
           Num2}
       end
       %% NOTE: 1st note with forced accent rating. Otherwise, its rating may be unconstrained and thus some random value
       {Ns.1 getAccentRating($)} = 0
       %% 1st note is *not* syncopated
       {Measures beatSyncopationR(0 {Ns.1 getStartTime($)} {Ns.1 getEndTime($)})} 
    end
    
    
    {GUtils.setRandomGeneratorSeed 0}
    {SDistro.exploreOne MyScript
     unit(order:leftToRight
          value:random)}
    
    /*
    
    declare
    {GUtils.setRandomGeneratorSeed 0}
    [MyScore] = {SDistro.searchOne MyScript
                 unit(order:leftToRight
                      value:random)}
    
    {MyScore toInitRecord($)}
    
    ,*/
    
    
    /*
    
    declare
    MyScore = {MyScript}
    
    */
    
    
    
#+end_src


TODO:
 - OK Option: longer note at end of phrase (which will not be accent-syncopated)
 - OK In addition to anacrusis, pitch skips are taken into account in the metric rating
 - Add rhythmic imitation with  texture constraints
   - That should in the end be outside the sub-script...
 - ?? Turn into a sub-script with args: using Score.defSubscript? Are its args confusing?
 - [Postpone for now] Add some overall pitch contour: some pattern on the local pitch maxima
   - NOTE: very expensive constraint; consider adding constraint to determine local max (e.g., using Pattern.localMaxR or Pattern.contour
   - Problem with doing so: local max likely have > 0 accent rating, and I cannot predetermine where these should be. I could slighly help by requiring that higher accent ratings mean local max and no others are local max. Would that be too strict?
   - Idea for solution: use contour imitation with  texture constraints, that would add further knowledge on local max


TODO for further examples
 - A few notes have offset time, separating phrases (necessary if I create longer note sequences than just phrases)
   - Option 1: Set some minimum number of notes between notes with positive offset times 
   - Option 2: Try better distribution with heuristic constraint that sets high likelyhood of offsetTime = 0
 - Add pattern motifs 
   - Add further note values


TODO for a longer example
 - shift metric accents at some stage and later shift it back to "default" of underlying measure

#+begin_src oz :results output
      
%%
%% Note: combining anacrusis constraints with other accent constraints can result in very expensive search (is there a bug?)     
%%

    declare
    Beat = 4
    %% NOTE: when turning into a sub-CSP, put measure def outside
    proc {RhythmicPhrase ?MyScore}
       %% The defaults can later be overwritten by some sub-CSP arguments
       Defaults = unit(%% of note's seq
                       offsetTimeDomain: 12#19
                       durDomain: [1 2 4] % for all but the last note
                       lastDurDomain: [8] % last note's domain
                      )
       MyPart Ns
       Measures
    in
       MyPart = {Score.makeSeq unit(iargs: unit(constructor: Measure.note
                                                n: 16
                                                pitch: fd#(60#72))
                                    offsetTime: {FD.int Defaults.offsetTimeDomain})}
       MyScore = {Score.make
                  sim([MyPart
                       seq([measure(n: 8
                                    beatNumber: 5
                                    beatDuration: Beat)])]
                      startTime:0
                      timeUnit:beats(Beat))
                  add(measure: Measure.uniformMeasures)}
       Ns = {MyPart collect($ test:isNote)}
       [Measures] = {MyScore collect($ test:Measure.isUniformMeasures)}
       %% 
       {ForAll Ns
        proc {$ N}
           {Measure.accent_If N
            %% List of accent constraints
            [% Measure.isSkip
             %% Note: makes search clearly more expensive
             % Measure.isHigherThanSurrounding_Rated
             {Measure.make_HasAnacrusis
              unit(requirements: [Measure.anacrusis_AccentLonger]
                   ratingPs: [Measure.anacrusis_FirstNPossibilyShorterTowardsAccent
                              Measure.anacrusis_FirstNUpwardPitchIntervals])}] 
            unit(strictness: note % note position noteAndPosition
                 metricPosition: beat % Beat*2 beat accent measureStart
                )}
        end}
       %% Dur domains
       {ForAll {LUtils.butLast Ns}
        proc {$ N} {N getDuration($)} = {FD.int Defaults.durDomain} end}
       {{List.last Ns} getDuration($)} = {FD.int Defaults.lastDurDomain}
       %% Num1+Num2 notes have at least an accent rating of 3
       local % FIXME: tmp setting 0
          Num1 = 1 % 0
          Num2 = 2 % 0
          L = {Length Ns}
          Ns1 Ns2
       in
          %%  Make search cheaper by explicitly constraining that a certain amount of higher accent ratings is in certain sections of Ns 
          {List.takeDrop Ns (L div 2) Ns1 Ns2}
          {Pattern.howManyTrue {Map Ns1
                                fun {$ N} {N getAccentRating($)} >=: 3 end}
           Num1}
          {Pattern.howManyTrue {Map Ns2
                                fun {$ N} {N getAccentRating($)} >=: 3 end}
           Num2}
       end
       %% NOTE: 1st note with forced accent rating. Otherwise, its rating may be unconstrained and thus some random value
       {Ns.1 getAccentRating($)} = 0
       %% 1st note is *not* beat syncopated, nor is the last accent syncopated
       {Measures beatSyncopationR(0 {Ns.1 getStartTime($)} {Ns.1 getEndTime($)})}
       {Measures accentSyncopationR(0 {{List.last Ns} getStartTime($)}
                                    {{List.last Ns} getEndTime($)})}
       %% Intervals between local maxima are steps (no repetition) that
       %% ?? form an arch
       %% NOTE: very expensive constraint; consider adding constraint to determine local max (e.g., using Pattern.localMaxR or Pattern.contour
       %% Problem with doing so: local max likely have > 0 accent rating, and I cannot predetermine where these should be. I could slighly help by requiring that higher accent ratings mean local max and no others are local max.
           % {Pattern.constrainLocalMax {MyScore map($ getPitch test:isNote)}
           %  Pattern.increasing
           %  % proc {$ Xs}
           %  % end
           % }
       %%
       %% Rhythmic imitation within the same voice
  %% This seems to be also very expensive. 
  %% Would be a good idea to have arg timeRange instead of numericRange to ensure that metric position works
       {Segs.texture Segs.homophonic MyPart [MyPart]
         unit(numericRange: [2#3]
              offsetTime: 20)}
    end
        
        
    {GUtils.setRandomGeneratorSeed 0}
    {SDistro.exploreOne RhythmicPhrase
     unit(order:leftToRight
          value:random)}
        
    /*
        
    declare
    {GUtils.setRandomGeneratorSeed 0}
    [MyScore] = {SDistro.searchOne RhythmicPhrase
                 unit(order:leftToRight
                      value:random)}
        
    {MyScore toInitRecord($)}
        
    ,*/
        
        
    /* %% TMP
      
        
    declare
    MyScore = {RhythmicPhrase}
        
    {MyScore toInitRecord($)}
      
    declare
    MyMeasure = {MyScore find($ Measure.isUniformMeasures)}
      
        
      
    ,*/
#+end_src



**** TODO Further anacrusis cases

TODO:
 - OK Option: longer note at end of phrase (which will not be accent-syncopated)
 - OK In addition to anacrusis, pitch skips are taken into account in the metric rating
 - Add rhythmic imitation with  texture constraints
   - That should in the end be outside the sub-script...
 - ?? Turn into a sub-script with args: using Score.defSubscript? Are its args confusing?
 - [Postpone for now] Add some overall pitch contour: some pattern on the local pitch maxima
   - NOTE: very expensive constraint; consider adding constraint to determine local max (e.g., using Pattern.localMaxR or Pattern.contour
   - Problem with doing so: local max likely have > 0 accent rating, and I cannot predetermine where these should be. I could slighly help by requiring that higher accent ratings mean local max and no others are local max. Would that be too strict?
   - Idea for solution: use contour imitation with  texture constraints, that would add further knowledge on local max


TODO for further examples
 - A few notes have offset time, separating phrases (necessary if I create longer note sequences than just phrases)
   - Option 1: Set some minimum number of notes between notes with positive offset times 
   - Option 2: Try better distribution with heuristic constraint that sets high likelyhood of offsetTime = 0
 - Add pattern motifs 
   - Add further note values


TODO for a longer example
 - shift metric accents at some stage and later shift it back to "default" of underlying measure


**** TODO Demonstrate usefulness of NoteAtMetricPosition (or disallowing any syncopations)


**** TODO Example with pattern motifs

#+begin_src oz :results output
  
  %% BUG:
  %% Segs.makeCounterpoint_PatternMotifs_OffsetDuration causes error. There is some unexpecting nil. Perhaps missing sim chord objects o.ae.?
  
  declare
  Beat = 4
  {Init.setNoteLengthsRecord Beat nil}
     
   {GUtils.setRandomGeneratorSeed 0}
     {SDistro.exploreOne
      proc {$ MyScore}
         MyScore = {Score.make sim([{Segs.makeCounterpoint_PatternMotifs_OffsetDuration
                                     unit(rargs: unit(motifSpecs:[[[d4 d8 '_'] [0 d8 '+'] [0 d2 '+']]
                                                                  [[d4 d4 '_'] [0 d2 '-']]]))}
                                    seq([measure(n: 8
                                                 beatNumber: 5
                                                 beatDuration: Beat)])]
                                  startTime:0
                                  timeUnit:beats(Beat))
                    add(measure: Measure.uniformMeasures)}
         %% 
         {ForAll {MyScore collect($ test:isNote)}
          proc {$ N}
             {Measure.accent_If N [TODO] % Measure.isLongerThanSurrounding
              unit(strictness: noteAndPosition % note position noteAndPosition
                   metricPosition: measureStart % Beat*2 beat accent measureStart
                  )}
             %% Simplify CSP, only rhythmic constraints...
             {N getPitch($)} = 60
          end}
         %% Restrict total sum of offset times 
         %% Without heuristic constraints, most rests will be in the beginning (a relevant heursitic constraint would require also distributing the offset times)
         Beat*5 >: {LUtils.accum {MyScore map($ getOffsetTime test:isNote)}
                    FD.plus}
      end
      unit(order:leftToRight
           value:random)}
     
#+end_src




**** TODO [#A] Combining multiple levels of accents		       :WAIT:

     [Interesting and very important musically, but postpone this for now]

Multiple calls of that share the same accent constraints, but differ in the minimum rating required and in the metric positions for these ratings: higher-level positions for higher ratings. The accent constraints are only applied once, and all calls of Measure.accent_If share the resulting ratings.

TODO: first need new optional arg for Measure.accent_If that prevents accent constraint application (for optimisation only). Or, perhaps better, I define some variant of Measure.accent_If that that not expect accent constraints as args, but the ratings (this constraint would be called internally in Measure.accent_If as well).


**** TODO [#A] Higher-than-measure-level accents 		       :WAIT:

     [Interesting and very important musically, but postpone this for now]

TODO: It would be good to somehow have a way to define accents beyond the measure-level. Such definition would expect a list of (uniform) measures and a list of measure indices that receive higher level accents (accents at such higher level should always be defined manually, and not simply repeat, say, every 4 measures, yes?)  


**** TMP


#+begin_src oz :results output
  
  
  declare
  MyMeasure = {Score.make2 measure(n: 2
                                   beatNumber: 5
                                   beatDuration: 4)
               unit(measure: Measure.uniformMeasures)}
  MyScore = {Score.make sim([seq([note note note(offsetTime: 4) note note note note note])
                             seq([MyMeasure])]
                            startTime:0
                            timeUnit:beats(4))
             add(note: fun {$ Args}
                          {Score.make2 {Adjoin note(duration: {FD.int [2 4]}
                                                    pitch: {FD.int 60})
                                                    Args}
                           unit}
                       end)}
  LastNote = {List.last {MyScore collect($ test:isNote)}}
  FirstNote = {MyScore collect($ test:isNote)}.1
  
      
  {MyScore toInitRecord($)}
  
  
  
  {LastNote getTemporalPredecessors($ 3)}
  
  {LastNote getPredecessorsUpToRest($)}
  
  {FirstNote getTemporalSuccessors($ 5)}
  
  {FirstNote getSuccessorsUpToRest($)}
  
  
  
#+end_src


*** Constraints supporting accents				    :ARCHIVE:

#+srcname: AccentConstraints2
#+begin_src oz :results output


#+end_src
    
#+srcname: AccentConstraints
#+begin_src oz :results output
  declare
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%
    %%% Aux defs
    %%%
    
      /** %% If X is not nil then apply F and return the result. Otherwise return 1. 
      %% */
      fun {ApplyIfNotnilOrTrue X F}
         if X == nil then 1
         else {F X}
         end
      end
      /** %% If X is not nil then apply F and return the result. Otherwise return 0. 
      %% */
      fun {ApplyIfNotnilOrFalse X F}
         if X == nil then 0
         else {F X}
         end
      end
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%
    %%% Duration related accent constraints
    %%%
  
  
      /** %% Returns an accent constraint (a function execting a note/item and returning a rating FD int). This resulting function returns 1 for notes with a duration of Dur or longer and 0 otherwise.
      %% */
      fun {Make_HasAtLeastDuration Dur}
         fun {$ N}
            ({N getDuration($)} >=: Dur)
         end
      end
      
      
      /** %% B=1 <=> Note N is longer than both its preceeding and its succeeding note. If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.
    %% TODO: ?? take offset times into account: a note with an offset time > 0 has "no predecessor". If the successor has an offset time > 0 then it has "no successor".
      %% */
      fun {IsLongerThanDirectNeighbours N}
         fun {IsShorter N2} 
            ({N2 getDuration($)} <: {N getDuration($)})
         end
      in
         {FD.conj {ApplyIfNotnilOrTrue {N getTemporalPredecessor($)} IsShorter}
          {ApplyIfNotnilOrTrue {N getTemporalSuccessor($)} IsShorter}}
      end
      
      /** %% B=1 <=> Note N is longer than the preceeding note and not shorter than succeeding note. If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.
    %% TODO: ?? take offset times into account: a note with an offset time > 0 has "no predecessor". If the successor has an offset time > 0 then it has "no successor".
      %% */
      fun {IsLongerThanPredecessor N}
         fun {IsShorter N2} 
            ({N2 getDuration($)} <: {N getDuration($)})
         end
         fun {IsNotLonger N2} 
            ({N2 getDuration($)} =<: {N getDuration($)})
         end
      in
         {FD.conj {ApplyIfNotnilOrTrue {N getTemporalPredecessor($)} IsShorter}
          {ApplyIfNotnilOrTrue {N getTemporalSuccessor($)} IsNotLonger}}
      end
      
      /** %% The higher the value of Rating, the more N is accented by its duration compared to its preceeding note.
      %% Rating=1: N is longer than its predecessor, or if there exists no predecessor.
      %% Rating=2: N is at least 2 times as long as its predecessor.
      %% Rating=3: N is at least 4 times as long as its predecessor.
      %% Rating is 0 otherwise. Rating is also 0 if N is shorter than its succeeding note.
      %% */
    %% TODO: take offset times into account
      proc {IsLongerThanPredecessor_Rated N ?Rating}
         Pre = {N getTemporalPredecessor($)}
         NDur = {N getDuration($)}
      in
         Rating = {FD.int 0#3}
         Rating = {ApplyIfNotnilOrTrue Pre
                    fun {$ Pre}
                       PreDur = {Pre getDuration($)}
                    in
                       (NDur >: PreDur) + (NDur >=: PreDur * 2) + (NDur >=: PreDur * 4)
                    end} * {ApplyIfNotnilOrTrue {N getTemporalSuccessor($)}
                            fun {$ N2} 
                               ({N2 getDuration($)} =<: NDur)
                            end}
      end
      
      
      /** %% The higher the value of Rating, the more N is accented by its duration compared to its surrounding notes.
    %% 
    %% Note: The rating of the first note in a temporal container is limited to the range [1,2]. 
      %% */
      %% TODO:
      %% - better fun name
      %% - doc
      %%
      %% - ?? Take also multiple predecessors/successors into account? `
      %% 
      %% [??Outdated comment?] simplified version, see my notes
      %% TODO:
      %% - make more flexible, see my notes 
      proc {IsLongerThanSurrounding_Rated N ?Rating}
         Rating = {FD.decl}
         Rating =: {IsLongerThanDirectNeighbours N} + {IsLongerThanPredecessor_Rated N}
      end
      
      
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%
  %%% Pitch related accent constraints
  %%%
      
          
      /** %% B=1 <=> Note N's pitch is higher than both its preceeding and its succeeding note. If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.
    %% TODO: ?? take offset times into account: a note with an offset time > 0 has "no predecessor". If the successor has an offset time > 0 then it has "no successor".
      %% */
      fun {IsHigherThanDirectNeighbours N}
         fun {IsLower N2} 
            ({N2 getPitch($)} <: {N getPitch($)})
         end
      in
         {FD.conj {ApplyIfNotnilOrTrue {N getTemporalPredecessor($)} IsLower}
          {ApplyIfNotnilOrTrue {N getTemporalSuccessor($)} IsLower}}
      end
      
      /** %% B=1 <=> Note N's pitch is higher than the preceeding note and not lower than succeeding note. If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.
    %% TODO: ?? take offset times into account: a note with an offset time > 0 has "no predecessor". If the successor has an offset time > 0 then it has "no successor".
      %% */
      fun {IsHigherThanPredecessor N}
         fun {IsLower N2} 
            ({N2 getPitch($)} <: {N getPitch($)})
         end
         fun {IsNotHigher N2} 
            ({N2 getPitch($)} =<: {N getPitch($)})
         end
      in
         {FD.conj {ApplyIfNotnilOrTrue {N getTemporalPredecessor($)} IsLower}
          {ApplyIfNotnilOrTrue {N getTemporalSuccessor($)} IsNotHigher}}
      end
      
      /** %% The higher the value of Rating, the more N is accented by its pitch compared to its preceeding note.
      %% Rating=1: N is higher than its predecessor, or if there exists no predecessor.
      %% Rating=2: N is at least 2 times as high as its predecessor.
      %% Rating=3: N is at least 4 times as high as its predecessor.
      %% Rating is 0 otherwise. Rating is also 0 if N is lower than its succeeding note.
      %% */
    %% TODO: take offset times into account
      proc {IsHigherThanPredecessor_Rated N ?Rating}
         Pre = {N getTemporalPredecessor($)}
         NPitch = {N getPitch($)}
      in
         Rating = {FD.int 0#3}
         Rating = {ApplyIfNotnilOrTrue Pre
                    fun {$ Pre}
                       PrePitch = {Pre getPitch($)}
                    in
                       (NPitch >: PrePitch) + (NPitch >=: PrePitch * 2) + (NPitch >=: PrePitch * 4)
                    end} * {ApplyIfNotnilOrTrue {N getTemporalSuccessor($)}
                            fun {$ N2} 
                               ({N2 getPitch($)} =<: NPitch)
                            end}
      end
      
      
      /** %% The higher the value of Rating, the more N is accented by its pitch compared to its surrounding notes.
    %% 
    %% Note: The rating of the first note in a temporal container is limited to the range [1,2]. 
      %% */
      %% TODO:
      %% - better fun name
      %% - doc
      %%
      %% - ?? Take also multiple predecessors/successors into account? `
      %% 
      %% [??Outdated comment?] simplified version, see my notes
      %% TODO:
      %% - make more flexible, see my notes 
      proc {IsHigherThanSurrounding_Rated N ?Rating}
         Rating = {FD.decl}
         Rating =: {IsHigherThanDirectNeighbours N} + {IsHigherThanPredecessor_Rated N}
      end
      
#+end_src




** Texture constraints

*** TODO 

    - See todos in source file [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Segments/Segments.oz::proc%20{Texture%20Dependency%20LeadingPart%20DependantParts%20Args}][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Segments/Segments.oz::proc {Texture Dependency LeadingPart DependantParts Args}]]

*** Overall constraint format					    :ARCHIVE:

**** Main defs

#+srcname: MakeTextureConstraint
#+begin_src oz :results output 
  
  declare
  
  /** %% Texture constraints restrict the independence between parts/voices. Dependence examples are homorhythm (simultaneous notes have the same start time and duration), heterorhythm (simultaneous notes have similar start times and durations), contrarhythm (simultaneous notes have different same start times or durations), homodirectional texture, various degrees of imitation (dependencies like, e.g., homorhythmic and homodirectional texture with a time offset) and many more possibilities. Texture constraints are inspired by Berry, Wallace (1987). Structural functions in music. Courier Dover Publications.
  
  %% A texture constraint applies a Dependency (a constraint, see below) between certain notes in a LeadingPart (a container) and certain notes in a DependantParts (a container). DependantParts can be either a single container or a list of container; in the latter case a dependency is applied to multiple parts (e.g., for a fully homophonic texture apply the dependency Homophonic to one voice as LeadingPart and a list with the remaining voices as DependantParts).
  
  %% A Dependency is a procedure with the following interface.
  
  {MyDependency Note1 Note2 Args}
  
  %% A Dependency defines a constraint between Note1, a note from the LeadingPart, and Note2, a note from the DependantPart. By default, Note1 and Note2 are simultaneous notes (see the argument offsetTime below for other cases). For example, homophony can be defined by constraining that the start times and durations of Note1 and Note2 are equal. Constraints that require more complex score contexts (e.g., the note succeeding Note1 in LeadingPart) are defined by accessing such contexts from the given notes (e.g., using methods like getTemporalSuccessor). The Dependency argument Args contains values for all optional arguments in the Args argument of a texture constraint (see below). Various dependencies are predefined (e.g., Homophonic, and HomoDirectional), and users can freely define their own.
  %%
  %% The argument Args of a texture constraint supports the following optional arguments.
  %%
  %% offsetTime (default 0): Using this argument, various forms of imitation can be defined. The dependency constraint is applied to a note in DependantPart that starts the specified amount of offset later than the respective note in LeadingPart.
  %% Remember that negative offset times are not allowed (if you would need them, simply swap the arguments LeadingPart and DependantPart).
  %% In case DependantParts is a list of containers, then a list of individual offset times can be given.
  %%
  %% timeRange: TODO
  %%
  %% numericRange (default nil): Specifies the positions of the affected notes in LeadingPart. For example, the numeric range [1#3 5#6] affects the notes at position 1-3 and 5-6 in LeadingPart and their simultaneous notes in DependantPart (if offsetTime is the default). numericRange is based on SMapping.forNumericRange, and supports all its index integers notations.
  %%
  %% Note that further arguments can be provided, which are then forwarded to the dependency constraints. For example, a transposition dependency may use a transposition argument which would then be included in the Args record for Texture. 
  %% In case DependantParts is a list of containers, then a list of individual values can be given to any argument.
  %%
  %%
  %% */
  %% TODO:
  %% * Generalise (or multiple versions?):
  %%  - Add an arg like processNoteLists: true OR false (false is the default). If true, then instead of processing one note of LeadingPart at a time, lists of notes are taken (as specified by numericRange). This is useful for constraining non-overlapping score contexts. For example, a dependency where a sequence of pitches are repeated (or transposed) without retaining their order (as Feldman does) can only be defined that way. By specifying an extra argument for this instead of generalising the whole definition, only specific dependency definitions need to deal with such cases, while others can rely on processing of individual notes. 
  %%  - Using SMapping.forNumericRange is only an option, another is SMapping.forTimeRange
  %%  - ?? Sim items is only an option, another is notes at same position
  %%  - ?? Is is correct to only constrain notes? Should that be more general?
  proc {Texture Dependency LeadingPart DependantParts Args}
     Defaults = unit(numericRange: nil %% TODO: ?? move this arg elsewhere (strucurally different)? I may want to keep it if I add support for SMapping.forTimeRange
                     offsetTime: 0)
     As = {Adjoin Defaults Args}
     proc {ConstrainPart N1 DependantPart Ags}
        DependantNs
     in
        thread
           DependantNs
           = {N1 getSimultaneousItemsOffset($ Ags.offsetTime
                                            toplevel: DependantPart
                                            test: isNote)}
        end
        thread
           {ForAll DependantNs
            proc {$ DependantN} {Dependency N1 DependantN Ags} end}
        end
     end
     fun {DuplicateArgs Ags N}
        {List.mapInd {List.make N}
         fun {$ I _}
            {Record.map Ags
             fun {$ X}
                if {IsList X} then {Nth X I} else X end
             end}
         end}
     end
  in
     {SMapping.forNumericRange {LeadingPart collect($ test:isNote)}
      As.numericRange 
      proc {$ N}
         if {IsList DependantParts}
         then
            {ForAll {LUtils.matTrans
                     [DependantParts {DuplicateArgs As {Length DependantParts}}]}
             proc {$ [DependantPart Ags]}
                {ConstrainPart N DependantPart Ags}
             end}
         else {ConstrainPart N DependantParts As}
         end
      end}
  end
    
  /** %% Multiple applications of Texture can be programmed slightly more concisely and better readable with TextureProgression. The following two code examples are equivalent (first a version using Texture then using TextureProgression).
  
  %% Imitation at the beginning (e.g., Voice2 at time 2 imitates 1st 5 notes of Voice1)
  {Texture MyDependency Voice1 [Voice2 Voice3 Voice1]
   unit(numericRange: 1#5
        offsetTime: [2 4 6])}
  %% Homophonic section
  {Texture Homophonic Voice1 [Voice2 Voice3]
   unit(numericRange: 9#12)}
  
  {TextureProgression
   [%% Imitation at the beginning (e.g., Voice2 at time 2 imitates 1st 5 notes of Voice1)
    (1#5) # unit(MyDependency Voice1 [Voice2 Voice3 Voice1]  
                 offsetTime: [2 4 6])
    %% Homophonic section
    (8#12) # unit(Homophonic Voice1 [Voice2 Voice3])
   ]}
  
  %% */
  proc {TextureProgression Specs}
     {ForAll Specs
      proc {$ NumericRange#Spc}
         Dependency = Spc.1
         LeadingPart = Spc.2
         DependantParts = Spc.3
         Args = {Record.subtractList Spc [1 2 3]}
      in
         {Texture Dependency LeadingPart DependantParts {Adjoin unit(numericRange:NumericRange) Args}}
      end}
  end
  
  /** %% [Dependency for Texture] Results in a homophonic texture.
  %% Note that a truely homophonic texture only results for the default offset time 0, otherwise a time-shifted "homophonic" imitation results.
  %% */
  proc {Homophonic N1 N2 Args}
     {N1 getStartTime($)} + Args.offsetTime = {N2 getStartTime($)}
     {N1 getDuration($)} = {N2 getDuration($)}
  end
  
  /* %% [Dependency for Texture] Results in a heterophonic texture.
  %% Note that a truely heterophonic texture only results for the default offset time 0, otherwise a time-shifted "heterophonic" imitation results.
  %% NOTE: Heuristic constraints only affect parameters that are distributed! Works (probably?) best if end times are distributed (and not durations?).
  %% */
  proc {HeuristicHomophonic N1 N2 Args}
     fun {EqualWithTimeOffset X Y}
        if X + Args.offsetTime == Y
        then 100 % {GUtils.random 100}
        else 0   % {GUtils.random 10}
        end
     end
  in
     % {Score.apply_H H.equal
     %  [{N1 getStartTimeParameter($)} {N2 getStartTimeParameter($)}] 1}
     % {Score.apply_H H.equal
     %  [{N1 getEndTimeParameter($)} {N2 getEndTimeParameter($)}] 1}
     {Score.apply_H EqualWithTimeOffset
      [{N1 getStartTimeParameter($)} {N2 getStartTimeParameter($)}] 1}
     {Score.apply_H EqualWithTimeOffset
      [{N1 getEndTimeParameter($)} {N2 getEndTimeParameter($)}] 1}
     %% just in case (more heuristic constraints do not add computational load :)
     {Score.apply_H H.equal
      [{N1 getDurationParameter($)} {N2 getDurationParameter($)}] 1}
  end
  
  
  /** %% [Dependency for Texture]  Generalised (?) version of "Orjan Sandred's notion of hierarchic rhythm.
  %% If the start time of N1 occurs between start and end of N2 including, then the start time of these notes are equal. In other words, the notes of N2's voice may be shorter than those of N1's voice, but whenever a longer note starts in the latter voice there also starts a note in the former.
  %% */
  %% BUG: can fail, but such minor inconsistencies may actually be good
  %% Problem: overall, rhythm followed too closely -- but I can easily force it otherwise (e.g., more notes in one layer with same overall end time.
  proc {HierarchicHomophonic N1 N2 Args}
     Start1 = {N1 getStartTime($)} + Args.offsetTime
     Start2 = {N2 getStartTime($)}
     End2 = {N2 getEndTime($)}
  in
     {FD.impl {FD.conj
               (Start2 =<: Start1)
               (Start1 =<: End2)}
      (Start1 =: Start2)
      1}
  end
  
  /** %% [Dependency for Texture] Results in a homo-directional texture (i.e. parallel pitch contours).
  %% */
  proc {HomoDirectional N1A N2A Args}
     N1B = {N1A getTemporalSuccessor($)}
     N2B = {N2A getTemporalSuccessor($)}
  in
     if N1B \= nil andthen N2B \= nil
     then
        {Pattern.direction {N1A getPitch($)} {N1B getPitch($)}}
        = {Pattern.direction {N2A getPitch($)} {N2B getPitch($)}}
     end
  end
  
#+end_src

**** Tests and examples

#+begin_src oz :results output
  
declare
  %%
  %% Usage example, implementing a homorhythmic texture
  %%
  
  proc {MyDependency N1 N2 Args} 
     {Segs.homophonic N1 N2 Args}
     % {Segs.hierarchicHomophonic N1 N2 Args}
     % {Segs.heuristicHomophonic N1 N2 Args}
     {Segs.homoDirectional N1 N2 Args}
  end
    
    
   {GUtils.setRandomGeneratorSeed 0}
    {SDistro.exploreOne 
     proc {$ MyScore}
        Voice1 Voice2 Voice3
     in
        MyScore = {Score.make sim([seq(info: fomus(inst: soprano)
                                       handle:Voice1
                                       [note note note note note note note note note note note note]
                                      )
                                   seq(info: fomus(inst: soprano) 
                                       handle:Voice2
                                       [note note note note note note note note note note note note])
                                   seq(info: fomus(inst: soprano) 
                                       handle:Voice3
                                       [note note note note note note note note note note note note])
                                  ]
                                 startTime:0
                                 timeUnit:beats(4))
                   add(note:fun {$ _}
                               {Score.make2 note(duration: {FD.int [1 2 4]}
                                                 pitch: {FD.int 60#72})
                                unit}
                            end)}
        {Segs.textureProgression
         [%% Imitation at the beginning (e.g., Voice2 at time 2 imitates 1st 5 notes of Voice1)
          (1#5) # unit(MyDependency Voice1 [Voice2 Voice3 Voice1]  
                       offsetTime: [2 4 6])
          %% Homophonic ending
          (8#12) # unit(Segs.homophonic Voice1 [Voice2 Voice3])
         ]}
        
        % {Segs.texture MyDependency Voice1 [Voice2 Voice3 Voice1]
        %  unit(numericRange: 1#5
        %       offsetTime: [2 4 6])}      
        % {Segs.texture Segs.homophonic Voice1 [Voice2 Voice3]
        %  unit(numericRange: 9#12)}
        
        % {Segs.texture MyDependency Voice1 Voice2
        %  unit(numericRange: 1#9
        %       offsetTime: 2)}
        
     end
     unit(value: heuristic
          % value:random
          order: leftToRight
         )}
  
#+end_src



#+begin_src oz :results output
  %% TMP test
  
    <<MakeTextureConstraint>>
  
    
    declare
    Voice1 Voice2 Voice3
    MyScore = {Score.make sim([seq(info: fomus(inst: soprano)
                                   handle:Voice1
                                   [note note note note note note note note note note note note]
                                  )
                               seq(info: fomus(inst: soprano) 
                                   handle:Voice2
                                   [note note note note note note note note note note note note])
                               seq(info: fomus(inst: soprano) 
                                   handle:Voice3
                                   [note note note note note note note note note note note note])
                              ]
                              startTime:0
                              timeUnit:beats(4))
               add(note:fun {$ _}
                           {Score.make2
                            note(duration: {FD.int [1 2 4]}
                                 pitch: {FD.int 60#72}
                                )
                            unit}
                        end)}
    {Texture MyDependency Voice1 [Voice2 Voice3 Voice1]
     unit(numericRange: 1#9
          offsetTime: [2 4 6])}      
#+end_src


#+begin_src oz :results output
%% Test
  
#+end_src


    Constraint applied to a container (typically a monophonic part) together with a specification for a time window: constraint is applied to all notes within that container and within that time window
    

Instead of applying a texture constraint to time windows, for now consider using =SMapping.forNumericRange=. Later you should add and the definitions =SMapping.forTimeRange= and =SMapping.mapTimeRange=.




*** "Parameters" to constrain

    - start time and duration
    - "Orjan's hierarchic rhythms (hierarchic homophony): 
      start times of notes with few long notes coincides with certain (important?) start times of a layer with more and shorter notes
    - pitch direction
    - pitch interval
    - pitch class interval
    - scale degree interval
    - ??

    - Inversion of ...



    - Interval between outer voices
    - Number of simultaneous voices/notes

    - Direct relation to dissonance degree -- I don't think I should implement that..



*** !! Always simultaneous events?

    *Decision: relation which notes are dependent notes must be controllable and not hard wired*

    Consider to make time window of dependant parts flexible, so that, e.g., various forms of imitation can be implemented with this constraint as well

    E.g., have a special "parameter" controlling the offset time between parts/voices. Of course, in case there are multiple dependant parts, their offset times can differ. 

    A nice result of this option would be, that I would have some flexible means to increase/decrease the amount of imitation, and also the offset times between imitations 

    Alternative option to find out dependant notes: same position 
    - Advantage: computationally cheap (no searching)
    - Disadvantage: less flexible, e.g., cannot deal with cases of different numbers of notes in related parts
  

*** How to implement similarity (hetero-)			    :ARCHIVE:

    Heuristic constraints? Possibly with a random element (makes recomputation impossible)
     
    Try to avoid modelling it with strict constraints (e.g., using pattern constraints such as HowManyTry) -- inefficient, and unnecessarily strict



*** Higher-level texture constraints 

    Texture development with multiple calls of low-level texture constraints (see [[*Overall%20constraint%20format][Overall constraint format]])

    Could perhaps be implemented with something like a mapping, where for all arguments of the low-level texture constraints a sequence can be specified (and all args are optional) 


    Using the numericRange (or timeRange) notation together with predefined texture dependencies I could relatively concisely define textual developments
    


** !! Heuristic constraints on pitches: store distro strategies in HS.distro

   for [preliminary def] see 
   [[file:~/Compositions/Ethno2-Demo/oz/GlobalDefs.oz]]

   Missing in the def above: pattern motifs and heuristic constraints on pitches are incompatible 
   (pitches determined by propagation instead, no effect of heuristic constraints)

   Also, the somewhat revised distro defs in HS.distro are problematic -- temporal parameters of containers should not be visited early, but should also not be ignored altogether


** Pattern motifs: support for motif start parameter

   This support was already added to the Indian Shruti demo for Ethno2, see 
   file:~/Compositions/Ethno2-Demo/oz/Indian-Shrutis-Demo.oz

   add this functionality somehow to Pattern.useMotifs


** Pattern constraint: {Similar Xs Ys}

   Similar constraints the lists Xs and Ys (lists of FD ints) to be similar to each other
   
   Possible approach: edit distance, http://en.wikipedia.org/wiki/Edit_distance 

   Application idea for motif similarity
   - Def a pattern motif database with, say, 8 motifs
   - Def motifs 1 and 2 by hand
   - Constrain motifs 3, 4, 5 to be similar to motif 1 and motifs 6, 7, and 8 to be similar to motif 2 -- but leave these motifs otherwise undetermined 


** Regular Temperament as pitch (pitch class) representation

*** TODO 

    OK - Doc HS.db.makeRegularTemperament and HS.db.ratioToRegularTemperamentPC
      see [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/Database.oz::fun%20MakeRegularTemperament%20Generators%20GeneratorFactors%20Args][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/HarmonisedScore/source/Database.oz::fun MakeRegularTemperament Generators GeneratorFactors Args]]

    - Mapping of symbolic notation names (nominals and accidentals) to JI ratios, and then to PCs to temperament
      see [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/RegularTemperament/RegularTemperament.oz::TODO%20ASCII%20notation%20for%20Extended%20Helmholtz%20Notation%20or%20Sagittal%20which%20mean%20their%20JI%20interpretation%20and%20which%20are%20then%20rounded%20into%20temperament%20with%20DB%20ratioToRegularTemperamentPC][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/RegularTemperament/RegularTemperament.oz::TODO ASCII notation for Extended Helmholtz Notation or Sagittal which mean their JI interpretation and which are then rounded into temperament with DB ratioToRegularTemperamentPC]]

      - Map each nominal and accidental to a ratio
	Still missing: suitable ASCII representation for EHE notation
      - In RegT.db.makeFullDB, allow to specify a set of possible accidentals to use for a certain temperament 
      - Map nominal/accidental ratios to PCs in current temperament (for some PCs there can be multiple symbolic notations)
      - (as in ET31 etc:) Create tuplet with PCs as features that map to the list of corresponding symbolic notations and the other way round
      - ?? Howto decide which notation to use if a specific PC is mapped to multiple symbolic notations? Write manually some tuple for this mapping, as before?

    - Chord / Scale / Interval databases
      
      - mapping symbolic note names to PCs in temperaments, then use this mapping in database (e.g., with existing ET31 database)
      OK - special chord/scale/interval features like dissonanceDegree: only included in database if given explicitely. In that case, entries without this features are filtered out. Report removals.
      OK - automatically filter out double entries (e.g., different JI database entries could be mapped to same temperament PCs, but then somehow report these removals.
      OK - optionally, extend chord/scale/interval database with extra entries given as args


    - Symbolic pitch notation

      - nominals measured in number of fifth up/down
      - accidentals # and b also measured in number of fifths up/down
      - map nominals internally to PCs with accumulated fifths generator 
	- approximate ratio 3/2 in temperament
	- if error of fifths larger than 11-comma (33#32, quarter tone) then exception: no symbolic notation
      - map all other accidentals to approximated JI accidentals
      - ?? what about quarter-tone accidentals of ET31 DB, should I replace these with 11-comma (33#32) accidental? Would that be too large an error (JI interpretion of accidental and 31-TET interval 38.71)?


    - Revise RegT.transform
      see [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/RegularTemperament/source/DB.oz::fun%20Transform%20MyPitch][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/RegularTemperament/source/DB.oz::fun Transform MyPitch]]

    - Music notation output

      - Simple approach: notate 12-TET approximation, annotated with numeric cent offsets

      - Better approach: use mapping PCs -> symbolic notation (see above). Map each symbolic notation accidental to the corresponding EHE notation code for Lilypond etc.


    - Demonstrating examples
      see [[file:~/oz/music/Strasheela/strasheela/strasheela/examples/RegularTemperaments.oz]]


*** Info

**** Regular temperament usage infos

***** Computing required number of temperament tones for specific chords

	From: 	hmiller@IO.COM
	Subject: 	Re: [tuning] Re: 31TET as as "do it all" (or at least most things) scale
	Date: 	3. Juni 2010 05:17:29 GMT+01:00
	To: 	tuning@yahoogroups.com

One nice thing about regular temperament mappings is that you can easily 
tell how many notes in a chain you'll need if you want 7-limit tetrads 
(with simple arithmetic). Take negri as an example, with a generator 
mapping of <0, -4, 3, -2]. The most negative number in the mapping is -4 
and the most positive number is 3; so you'll need 4 + 1 + 3 = 8 notes in 
a chain for a single 4:5:6:7 or 1/4:5:6:7 chord (-4, -3, -2, -1, 0, 1, 
2, 3). Every additional note in the chain gives you another pair of 
tetrads, so the 10-note MOS has 3 of each (otonal and utonal). With 
scales that repeat at a fraction of an octave, this gives you the number 
of notes in a period, so you'll have to multiply by the number of 
periods in an octave.

**** Advantages and Possibilities 

    - Allows for arbitrary regular temperaments, including high-limit JI
    - Allows for new harmony constraints (e.g., Tenney-distance)
    
    - Dynamic tuning (even with only slightly extended current harmony model)


**** COMMENT 

If I only have a new note mixin class that maps regular temperaments to a pitch class (i.e. still use the existing chord/scale classes etc), then I can already do dynamic tuning within certain limitations.

***** Email Bill Sethares Excerpt

	From: 	sethares@gmail.com
	Subject: 	Re: Comments on paper intended for Perspectives of New Music?
	Date: 	24. April 2010 03:40:54 GMT+01:00
	To: 	torsten.anders@plymouth.ac.uk

I think I have some good news for you then... here's the beauty of the  
"continua" that
Andy Milne and I talk about in our paper. Pick a set of generators and  
fix all but one.
Let this one change, and you get a variety of tunings. As long as you  
stay within some
pretty generous bounds (the "valid tuning range") then you get the  
exact same i,j pairs
for each interval and chord. So for instance, in the syntonic  
continuum, you have both
12-ET and 19-ET (along with a bunch of others). If you choose three  
sets of i,j so as to give you
a major chord in 12-ET, then the exact same i,j also give a major  
chord in 19-ET.
Of course, the exact tuning of the notes changes, but the basic  
relationships of
root-third-fifth are obtained in both ETs. The point is that you don't  
need to redefine
the chords/scales for every tuning separately, you can inherit from  
one tuning to another.

**** Summary

Constrain the relation between generators of regular temperament, their  
factors and a 1200-TET pitch class (i.e. cents)
    
  (Generator1 * I + Generator2 * j + ...) mod 1200 = PitchClass


I would primarily need to write a new mixin for  
note classes which introduces the variables i, j, ... (and possibly  
the generators as variables), new chord/scale/interval databases in  
1200-TET (somehow generalised so that they can be customised for  
different regular temperaments!), and customised music notation for  
1200-TET (again customisable for different regular temperaments).  
Alternatively, I may choose 1200000-TET as pitch resolution (but 1200- 
TET already results in rather large variable domains witch may hamper  
efficiency). Anyway, I could keep several thousand related lines of  
code untouched :)

This idea artificially restricts the model to the octave as a period of a regular temperament with 1 or  
more further generators. However, as a musician I like to work with  
pitches without octave components (pitch classes). And I need pitch classes, e.g., to constrain relation to pitch class set of related chords/scales.

A regular temperament I would certainly implement with this approach  
is JI with some high prime limit. For example, I may use the just  
fifths and commas represented by a music notation such as Extended  
Helmholtz-Ellis as generators. I would then have a representation of  
this notation, which can be constrained.

In the long run, I would consider to introduce variants of the chord  
and scale classes where the pitches are defined directly by regular  
temperament generators and their factors instead of pitch classes. I  
expect this would cause quite some programming problems, and might not  
even possible, but it would be worth a try (I am currently using  
selection constrains -- something like a function NTH as constraint --  
to define the relation, e.g., between a chord index and the  
corresponding untransposed pitch class set. Instead of a pitch class  
set I would then instead have multiple sets of generators and factors  
that are interdependent). It may not be possible, because my language  
does not support a variable domain like set of tuples of integers. But  
it would be worth a try, because it would abstract away chord/scale  
definitions from a single temperament and thus generators could change  
within a piece (as you describe in your CMJ paper "Isomorphic  
Controllers and Dynamic Tuning: Invariant Fingering over a Tuning  
Continuum"), and it would then make also make the generators  
themselves constrainable (effectively the "tuning bend" would be  
constrained). Hm. No idea where that leads :)


**** Examples: Generator & Factor to PC mapping 

***** Meantone

    (Generator1 * I) mod 1200 = PC

    Generator1 = 696 cent (696.578428 cent)
    
    I = 0; PC = 0
    I = 1; PC = 696 // fifth
    I = 2; PC = 191 // maj second
    I = -1; PC = 504 // fourth
    ...

***** 7-limit JI

      (Generator1 * I1 + Generator2 * I2 + Generator3 * I3) mod 1200 = PC

      Generator1 = 702 // 3:2
      Generator2 = 386 // 5:4
      Generator3 = 969 // 7:4

      I1=0; I2=0; I3=0; PC = 0
      I1=0; I2=-1; I3=1; PC = 583 // 7:5
      I1=0; I2=1; I3=-1; PC = 617 // 10:7



**** Another Description: Regular Temperaments as Pitch Representation

***** Current Strasheela approach: ETs:

      Regular temperament with a single generator, represented by an (the ET pitch class) 
      
      1D regular temperament: octave is actually not another generator (period), therefore I can easily define relation between pitch classes and pitch with modulus.

      generator is alpha=2^(1/n)  : n is number of pitches per octave
      
      pitch classes then correspond to 
      alpha^1, alpha^2, alpha^3, ... alpha^n.

      Example 12-TET
      alpha=2^(1/n) = 1.0595    : frequency ratio of 12-TET step

      alpha^12 = 2.0 (the octave) 
      

***** Generalisation: n-D regular temperaments

     Allow for more than one generator, which then together represent a pitch class

     I would then only need some integer formula to map to pitches. However, I likely have no single-integer pitch class anymore..
     
     alpha: first generator
     beta: second generator

****** Using Floats

      alpha^i * beta^j

      In my current approach, beta is fixed to 2.0 (the octave)


      Example: Meantone 

      alpha = 5^(1/4) = 1.495348
      beta = 2.0

      alpha^0 * beta^0 = 1.0      // the root
      alpha^1 * beta^0 = 1.495348 // the fifth
      alpha^2 * beta^0 = 2.2361 // the nineth
      alpha^2 * beta^-1 = 1.118 // the major second
      ...

****** Using Integers

      Can I redefine this with cents (integers) instead of ratios (floats)
      I may even consider millicent...
      
      Mapping from regular temperament to pitches.
      alpha*i + beta*j = pitch

      Example Meantone: 
      alpha = 696 cent (696.578428 cent)
      beta = 1200 cent

      alpha*0 + beta*0 = 0 // the root 
      alpha*1 + beta*0 = 696 // the fifth
      alpha*2 * beta*0 = 1392 // the nineth
      alpha*2 * beta*-1 = 192 // the major second
      ...


      Example 12-TET:
      alpha = 100 cent
      beta = 1200 cent

      alpha*0 + beta*0 = 0 // the root 
      alpha*1 + beta*0 = 100 // the fifth
      alpha*2 * beta^0 = 200 // the nineth
      alpha^1 * beta^1 = 1300 // the minor ninth
      ...


      Example 7-limit JI:
      NOTE: I possibly better use 3:1, 5:1 etc...
      alpha = 1200 cent (2:1)
      beta = 702 cent (3:2)
      gamma = 386 cent (5:4)
      delta = 969 cent (7:4)
      
      alpha*0 + beta*0 + gamma*0 + delta*0 = 0
      alpha*0 + beta*0 + gamma*0 + delta*1 = 969 (7:4)
      alpha*0 + beta*0 + gamma*-1 + delta*1 = 583 (7:5)
      alpha*1 + beta*0 + gamma*1 + delta*-1 = 617 (10:7)


****** NOTE: 

     !!  Only problem: I cannot have negative numbers!  

     There are ways around that using some offset...


     The implementation can perhaps use one of the generalised sum propagators for efficiency
     http://www.mozart-oz.org/documentation/system/node21.html#section.fd.arithmetic



**** Info on Regular Temperaments in general

***** TODO !! Function/mapping of ratios to corresponding cent values for a given regular temperament 

      I would need a function that expects a set of generators that defines a regular temperament (in cent), and a frequency ratio (pitch class, i.e. without octave component) that expresses an interval and returns the approximation of this interval in the regular temperament (in cent).

      I can then define a single large JI chord/interval/scale database and use it for arbitrary regular temperaments (I would only need to prune the database, removing JI chords/scales/intervals whose approximation in the temperament has a too large error, and possible doublicates).

      Idea for simple implementation: compute all pitches of temperament in cent (sorted tuple of integers). Then, given a JI ratios translated into cent simply search for the temperament pitch that is closest. The difference is the error. 

***** TODO Notation for regular temperaments

      Use Extended Helmholtz-Ellis notation

****** Method 1

       - Specify temperted fifth interval in cent (quasi as generator, whether actually a generator of the regular temperament or not)
       	 -> I can then identify automatically all pitches notated quasi as sequence of Phythagorean fifths
       - Optionally, specify further tempered commas with their accidental (Strasheela atom and EHE string for Lilypond)
       	 -> I can then identify automatically all notation variants possible for each pitch

****** Method 2 (can both be used)

       - Define table (tuple) that maps 1200-TET pitch classes (cent values) to (i) Strasheela pair Nominal#Accidental and (ii) corresponding Lilypond code for nominals and accidentals
   
****** Method 3: simple

       If regular temperament is mapped to keys of Halberstadt keyboard, then I can simply notated these keys, quasi a tabulature :)
       This approach likely enough for Ethno2 contest (is using 24 tones then notated quarter tones)


***** Lists of Regular Temperaments 

      Catalog of Linear Temperaments (i.e. rank-2 regular temperaments where one generator is the octave)
      http://x31eq.com/catalog.htm 

      Another list of Linear Temperaments 
      http://www.tonalsoft.com/enc/e/equal-temperament.aspx

      Regular Temperament Finder (online application)
      http://x31eq.com/temper/pregular.html

      http://x31eq.com/temper/net.html
      


****** Graham' list

        From: 	gbreed@gmail.com
	Subject: 	Re: [tuning] The regular mapping paradigm strikes back
	Date: 	1. Mai 2010 10:27:39 GMT+01:00
	To: 	tuning@yahoogroups.com
	Reply-To: 	tuning@yahoogroups.com


Here's the generator for every rank 2 name in my database where the
period is an octave. That is, every TOP-RMS strictly linear
temperament based on consecutive primes. It tried to remove anything
obviously deviant, which would mean it was defined on a
non-consecutive prime limit. I may have missed some. Duplicate names
mean similar mappings for different limits.

38.413 Slender
45.139 Quartonic
77.191 Tertiaseptal
77.709 Valentine
77.881 Valentine
82.505 Nautilus
88.076 Octacot
98.670 Passion
100.838 Ripple
116.633 Miracle
116.675 Miracle
116.747 Miracle
125.608 Negrisept
125.755 Negripent
130.106 Mohajira
146.474 Bohpier
146.545 Bohpier
154.579 Nusecond
158.649 Hemikleismic
158.868 Hystrix
162.747 Porcupine
162.880 Porcupine
163.950 Porcupine
175.434 Sesquiquartififths
176.160 Tetracot
193.201 Luna
193.244 Hemithirds
193.898 Hemiwuerschmidt
228.334 Gorgo
230.336 Gamera
230.762 Gidorah
232.031 Cynder/Mothra
232.193 Cynder
233.930 Guiron
234.459 Rodan
239.977 Penta
251.881 Semaphore
252.635 Semaphore
259.952 Superpelog
260.388 Bug
271.107 Quasiorwell
271.426 Orwell
271.509 Orwell
271.546 Orwell
271.627 Orson
310.144 Myna
310.146 Myna
310.276 Myna
315.181 Parakleismic
315.240 Parakleismic
316.473 Keemun
316.732 Catakleismic
317.007 Hanson
317.121 Countercata
317.656 Keemun
321.847 Superkleismic
321.930 Superkleismic
339.519 Amity
348.119 Vicentino
348.415 Mohajira
348.477 Mohajira
348.558 Mohajira
348.594 Dicot
348.736 Mohajira
348.810 Mohajira
351.477 Hemififths
355.904 Beatles
378.479 Muggles
380.058 Magic
380.352 Magic
380.696 Magic
380.787 Magic
386.863 Grendel
387.383 Wuerschmidt
387.799 Wuerschmidt
425.942 Squares
425.957 Squares
426.276 Squares
427.208 Sidi
441.335 Clyde
443.058 Sensipent
443.383 Sensisept
443.626 Sensi
443.945 Sensisept
456.014 Father
464.845 Semisept
475.543 Vulture
475.636 Vulture
478.431 Mother
489.709 Superpyth
489.922 Superpyth
491.762 Quasisuper
496.746 Dominant
496.961 Undecental
497.384 Kwai
497.441 Cassandra
497.629 Schismatic
497.887 Alt. Cassandra
497.915 Garibaldi
498.243 Pontiac
498.264 Helmholtz
498.427 Dominant
498.444 Schism
498.761 Grackle
499.860 Sharptone
503.031 Meantone
503.358 Meantone
503.505 Meantone
503.566 Meanpop
503.761 Meantone
503.789 Meanpop
506.221 Flattone
516.694 Marvo
520.194 Mavila
526.003 Pelogic
567.594 Liese
568.865 Triton
580.267 Tritonic
580.286 Tritonic
582.452 Neptune

Graham


***** References

      A. Milne, W. A. Sethares, and J. Plamondon, Isomorphic Controllers and Dynamic Tuning - Invariant Fingering Over a Tuning Continuum, Computer Music Journal, Winter 2007

      http://en.wikipedia.org/wiki/Linear_temperament

      http://lumma.org/tuning/gws/regular.html


**** Emails with Bill Sethares    

     [chronological order]

****** Bill 

     From: 	sethares@gmail.com
	Subject: 	Re: Comments on paper intended for Perspectives of New Music?
	Date: 	22. April 2010 18:21:01 GMT+01:00
	To: 	torsten.anders@plymouth.ac.uk

Hi Torsten,

Thanks for the sneak preview of your paper. I read your paper (very  
quickly,
so I may not have understood some things) but I do have a few thoughts.

First, I would suggest that you motivate the work by stating some
concrete problem or problems that you are trying to solve.
As I read the introduction, it kind of sounds like this:
"here are some cool new features I added to my software Strasheela".
While I understand that this may be a personal motivation, you can
probably do better.... for example, you might pose one or more of the  
examples
(that you later on demonstrate) as a problem to be solved, and
then show how the additions to Strasheela help to solve those problems.
This is more a matter of packaging than of content, but I have to say  
that
I was a long way into the paper before I understood what you were
actually doing.

You say in a couple of places that your method is constrained to  
problems
with integer solutions, and that this is why you have not considered  
JI and
the meantone tunings directly, but only via approximation by certain  
ETs. I find this odd.
First, JI is defined by integer ratios, and it's hard to see why you  
can't
consider them in this way. As I understand the setup (and I may be
mistaken here) you use the integers 1,2,3, ... n to represent n-tone- 
equal
temperament, and then solve some kind of constrained optimization  
problem
over this set. So, what you are really doing is to take a generator  
alpha=2^(1/n)
and to consider all powers of alpha in the solution technique:
alpha^1, alpha^2, alpha^3, ... alpha^n.
If you think about the regular tuning paradigm, there is a clear way to
generalize this: have 2 generators! With alpha and beta as generators,
you still have integers to search over: you have the set
alpha^i * beta^j over a set of i in 1, 2, ... n and j in 1, 2, ... m.
In fact, this is what you are already doing, since you are assuming
octave reduction, you have just fixed one of the generators at 2.
This is why it's hard to understand why you have the restriction
to ETs -- using two generators (like you already are) you can get
a lot more tunings, just by using different values. And then of course,
if you can get to 3 or 4 generators, you will have almost every tuning
you've ever heard of...

Here's a possible criticism that you might want to address somewhere.
Suppose a reviewer were to say: algorithmic composition makes sense in
12-ET where we have centuries of knowledge about what the rules are.
But in a new tuning, one in which one doesn't have much experience,
how is it possible to define rules that can lead to sensible music?
In other words, for many people microtonality is an unknown -
in order to use the software, they are going to have to create rules
to constrain the creation of the piece. Isn't the real
problem that we don't know what the rules are?
(I think you do have an answer to this, by the way, but you
have not actually spelled it out).

A detail: I think you misunderstand Darreg's word "xenharmony".
It is not (in his usage) a synonym for microtonality. What he means
is "music that sounds different from what is possible in 12-ET."

Anyway, thanks again for showing it to me and good luck with
placing this in Perspectives!

--Bill Sethares

On Apr 21, 2010, at 8:25 AM, Torsten Anders wrote:

Dear Professor Sethares,

attached please find the draft of a paper describing a computational  
model and application examples for rule-based microtonal music  
composition, intended for publication in Perspectives of New Music.  
I would very much appreciate your comments on this paper, if you are  
interested and have the time (no full formal review necessary).

If at all possibly, please reply before end of May.

Thank you very much indeed!

Yours sincerely,
Torsten Anders

--
Torsten Anders
Interdisciplinary Centre for Computer Music Research
University of Plymouth
Office: +44-1752-586219
Private: +44-1752-558917
http://strasheela.sourceforge.net
http://www.torsten-anders.de

<MicrotonalHarmony.pdf>


****** Torsten 

Sent:  	 23 April 2010 16:58
To: 	
Bill Sethares [sethares@gmail.com]
Cc: 	
Eduardo Miranda
Attachments: 	
Dear Bill Sethares,

Thank you very much indeed for your quick and extremely helpful reply.

> First, I would suggest that you motivate the work by stating some concrete problem or problems that you are trying to solve.

That makes certainly sense.

> If you think about the regular tuning paradigm, there is a clear way to generalize this: have 2 generators!
> With alpha and beta as generators, you still have integers to search over

What a great idea!! When I developed the underlying pitch representation years ago I did not know about regular temperaments, and since then it just did not occur to me that I could do this :)

It would be pretty hard to use the approach you are presenting, because constraining the relation between i and j in alpha^i * beta^j on the one hand, and the resulting pitch on the other hand would leave the integer domain. However, I can simply represent the generators and the pitches of notes in cent (or even millicent if necessary), and then this constraint becomes

  generator1*i + generator2*j + ... = pitch

The only problem is still that I am actually limited to non-negative integers, and I would need negative i's, j's etc as well to move in all directions of the n-dimensional space of a regular temperament. However, there are ways around that using some offset... I will certainly further think about this matter :)

> But in a new tuning, one in which one doesn't have much experience, how is it possible to define rules that can lead to sensible music?

Ah, I see. I will address this question. 

> you misunderstand Darreg's word "xenharmony".

Oops, I look it up.

Again, thank you very very much for your valueable input.

Best wishes,
Torsten

--
Torsten Anders
Interdisciplinary Centre for Computer Music Research
University of Plymouth
http://strasheela.sourceforge.net
http://www.torsten-anders.de


****** Bill 

From: 	sethares@gmail.com
	Subject: 	Re: Comments on paper intended for Perspectives of New Music?
	Date: 	23. April 2010 21:20:19 GMT+01:00
	To: 	torsten.anders@plymouth.ac.uk

Happy to help...

On Apr 23, 2010, at 10:58 AM, Torsten Anders wrote:

Dear Bill Sethares,

Thank you very much indeed for your quick and extremely helpful reply. 

First, I would suggest that you motivate the work by stating some concrete problem or problems that you are trying to solve.

That makes certainly sense.

If you think about the regular tuning paradigm, there is a clear way to generalize this: have 2 generators! 
With alpha and beta as generators, you still have integers to search over 

What a great idea!! When I developed the underlying pitch representation years ago I did not know about regular temperaments, and since then it just did not occur to me that I could do this :) 

It would be pretty hard to use the approach you are presenting, because constraining the relation between i and j in alpha^i * beta^j on the one hand, and the resulting pitch on the other hand would leave the integer domain. However, I can simply represent the generators and the pitches of notes in cent (or even millicent if necessary), and then this constraint becomes 

 generator1*i + generator2*j + ... = pitch

Most things are easier in cents!

The only problem is still that I am actually limited to non-negative integers, and I would need negative i's, j's etc as well to move in all directions of the n-dimensional space of a regular temperament. However, there are ways around that using some offset... I will certainly further think about this matter :) 

I'm not sure I understand the data structures involved, but something about this strikes me
as odd. Even with an n-ET, what you are representing is "all octaves" of a single
generator. Then you have 

generator*i = pitch

So as you go up in octaves, you are wrapping large positive i back to the range 1,n.
As you go down in octaves, you are wrapping negative i back to the range 1,n.
So there is a sense in which you are (probably implicitly) dealing with negative numbers.

If you needed to constrain the optimization itself to positive integers, you could always 
estimate 

generator1*(-20+i) + generator2*(-30+j) + ... = pitch

in which case you are still estimating positive values of the i and j.
Of course, I picked the 20 and 30 out of a hat, but I think you get the idea.

But anyway, maybe this is beyond what you want to do -- it just strikes me
that you're almost all set up for it... and it would  let you directly take care
of a larger variety of tunings...

But in a new tuning, one in which one doesn't have much experience, how is it possible to define rules that can lead to sensible music?

Ah, I see. I will address this question.  

you misunderstand Darreg's word "xenharmony".

Oops, I look it up.

Again, thank you very very much for your valueable input. 

Best wishes,
Torsten

--
Torsten Anders
Interdisciplinary Centre for Computer Music Research
University of Plymouth
http://strasheela.sourceforge.net
http://www.torsten-anders.de


****** Torsten 

	Subject: 	Re: Comments on paper intended for Perspectives of New Music?
	From: 	torsten.anders@plymouth.ac.uk
	Date: 	24. April 2010 00:43:03 GMT+01:00
	To: 	sethares@gmail.com

Dear Bill Sethares,

Thanks you for coming back to this matter.

On 23.04.2010, at 21:20, Bill Sethares wrote:
On Apr 23, 2010, at 10:58 AM, Torsten Anders wrote:
The only problem is still that I am actually limited to non- 
negative integers, and I would need negative i's, j's etc as well  
to move in all directions of the n-dimensional space of a regular  
temperament. However, there are ways around that using some  
offset... I will certainly further think about this matter :)

I'm not sure I understand the data structures involved, but  
something about this strikes me
as odd. Even with an n-ET, what you are representing is "all  
octaves" of a single
generator. Then you have

generator*i = pitch

Sure, any ET is a 1-D regular temperament. However, I quasi treat ETs  
as 2-D regular temperaments, because I want an explicit representation  
of the pitch class and the octave besides the pitch. I am using the  
pitch classes, for example, to constrain the relation between notes  
and the underlying harmony and scale (the pitches of a chord/scale,  
its root and its transposition interval are also all pitch classes),  
the relation between chords and scales (as in diatonic chords), in  
chord inversions the bass is represented by a pitch class etc. I also  
need the pitches (in contrast to pitch classes), e.g., to constrain  
melodic intervals, intervals between parts etc.

So as you go up in octaves, you are wrapping large positive i back  
to the range 1,n.
As you go down in octaves, you are wrapping negative i back to the  
range 1,n.
So there is a sense in which you are (probably implicitly) dealing  
with negative numbers.


If you needed to constrain the optimization itself to positive  
integers, you could always
estimate

generator1*(-20+i) + generator2*(-30+j) + ... = pitch

in which case you are still estimating positive values of the i and j.
Of course, I picked the 20 and 30 out of a hat, but I think you get  
the idea.

Yes, something like this is what I meant with "there are ways around  
using negative numbers using some offset".

But anyway, maybe this is beyond what you want to do -- it just  
strikes me
that you're almost all set up for it... and it would  let you  
directly take care
of a larger variety of tunings...

I would certainly like to have a direct representation of regular  
temperaments, like in the formula above. However, I need to integrate  
this representation in such a way that not only the pitches of single  
notes are represented, but that I can also represent, e.g., properties  
of chords, scales and their interrelation.

As I said, I have to further think about this matter, but here is what  
I am currently contemplating. I am considering whether it would be a  
good idea to constrain the relation between the generators, their  
factors and a 1200-TET pitch class (i.e. cents) as in the following  
formula.

  (generator1*(i) + generator2*(j) + ...) mod 1200 = pitch class

Using this approach I would primarily need to write a new mixin for  
note classes which introduces the variables i, j, ... (and possibly  
the generators as variables), new chord/scale/interval databases in  
1200-TET (somehow generalised so that they can be customised for  
different regular temperaments!), and customised music notation for  
1200-TET (again customisable for different regular temperaments).  
Alternatively, I may choose 1200000-TET as pitch resolution (but 1200- 
TET already results in rather large variable domains witch may hamper  
efficiency). Anyway, I could keep several thousand related lines of  
code untouched :)

I expect you find this idea a bit odd again. It artificially restricts  
the model to the octave as a period of a regular temperament with 1 or  
more further generators. However, as a musician I like to work with  
pitches without octave components (pitch classes). I would loose this  
notion if I do not introduce the modulus in the formula above (e.g., I  
would find it difficult to handle accumulating generators where the  
resulting pitches get distributed over multiple octaves). (And  
personally I am actually not very much interested in temperaments that  
do not repeat at the octave, no idea whether this may change in a few  
years time :)

A regular temperament I would certainly implement with this approach  
is JI with some high prime limit. For example, I may use the just  
fifths and commas represented by a music notation such as Extended  
Helmholtz-Ellis as generators. I would then have a representation of  
this notation, which can be constrained.

In the long run, I would consider to introduce variants of the chord  
and scale classes where the pitches are defined directly by regular  
temperament generators and their factors instead of pitch classes. I  
expect this would cause quite some programming problems, and might not  
even possible, but it would be worth a try (I am currently using  
selection constrains -- something like a function NTH as constraint --  
to define the relation, e.g., between a chord index and the  
corresponding untransposed pitch class set. Instead of a pitch class  
set I would then instead have multiple sets of generators and factors  
that are interdependent). It may not be possible, because my language  
does not support a variable domain like set of tuples of integers. But  
it would be worth a try, because it would abstract away chord/scale  
definitions from a single temperament and thus generators could change  
within a piece (as you describe in your CMJ paper "Isomorphic  
Controllers and Dynamic Tuning: Invariant Fingering over a Tuning  
Continuum"), and it would then make also make the generators  
themselves constrainable (effectively the "tuning bend" would be  
constrained). Hm. No idea where that leads :)

Anyway, these are currently only rough ideas, they may pop up problems  
I did not anticipate.

Again, thank you for your valued input to this matter!

Best regards,
Torsten

--
Torsten Anders
Interdisciplinary Centre for Computer Music Research
University of Plymouth
Office: +44-1752-586219
Private: +44-1752-558917
http://strasheela.sourceforge.net
http://www.torsten-anders.de


****** Bill 

	From: 	sethares@gmail.com
	Subject: 	Re: Comments on paper intended for Perspectives of New Music?
	Date: 	24. April 2010 03:40:54 GMT+01:00
	To: 	torsten.anders@plymouth.ac.uk


I would certainly like to have a direct representation of regular  
temperaments, like in the formula above. However, I need to  
integrate this representation in such a way that not only the  
pitches of single notes are represented, but that I can also  
represent, e.g., properties of chords, scales and their interrelation.

I think I have some good news for you then... here's the beauty of the  
"continua" that
Andy Milne and I talk about in our paper. Pick a set of generators and  
fix all but one.
Let this one change, and you get a variety of tunings. As long as you  
stay within some
pretty generous bounds (the "valid tuning range") then you get the  
exact same i,j pairs
for each interval and chord. So for instance, in the syntonic  
continuum, you have both
12-ET and 19-ET (along with a bunch of others). If you choose three  
sets of i,j so as to give you
a major chord in 12-ET, then the exact same i,j also give a major  
chord in 19-ET.
Of course, the exact tuning of the notes changes, but the basic  
relationships of
root-third-fifth are obtained in both ETs. The point is that you don't  
need to redefine
the chords/scales for every tuning separately, you can inherit from  
one tuning to another.

As I said, I have to further think about this matter, but here is  
what I am currently contemplating. I am considering whether it would  
be a good idea to constrain the relation between the generators,  
their factors and a 1200-TET pitch class (i.e. cents) as in the  
following formula.

(generator1*(i) + generator2*(j) + ...) mod 1200 = pitch class

Using this approach I would primarily need to write a new mixin for  
note classes which introduces the variables i, j, ... (and possibly  
the generators as variables), new chord/scale/interval databases in  
1200-TET (somehow generalised so that they can be customised for  
different regular temperaments!), and customised music notation for  
1200-TET (again customisable for different regular temperaments).  
Alternatively, I may choose 1200000-TET as pitch resolution (but  
1200-TET already results in rather large variable domains witch may  
hamper efficiency). Anyway, I could keep several thousand related  
lines of code untouched :)

I expect you find this idea a bit odd again. It artificially  
restricts the model to the octave as a period of a regular  
temperament with 1 or more further generators. However, as a  
musician I like to work with pitches without octave components  
(pitch classes). I would loose this notion if I do not introduce the  
modulus in the formula above (e.g., I would find it difficult to  
handle accumulating generators where the resulting pitches get  
distributed over multiple octaves). (And personally I am actually  
not very much interested in temperaments that do not repeat at the  
octave, no idea whether this may change in a few years time :)

Not at all odd... I have played around with non-octave music, but  
certainly it's the most popular
interval ever, and I'd hate to have to live without it! But within the  
regular tuning setup, the octave
is no different from any other defining interval: it's just another  
generator. If you happen to pick
it always equal to 2, that's a pretty good choice.


**** OLD

****** Define program for creating regular temperaments, expecting generator and period intervals

       Generator and Period are cent values

       G is generator
       P is period
       N \in 1..max_N
       M \in 1..max_M

       Pitch_i = (G*N) - (P*M) 

       Total number of pitches N*M


       -------

       Python code (Generator and Period are cent values)
       !! implements different formula


       scale = []
       for nSteps in range(stepsPerPeriod):
       root = (nSteps*generator)%period
       for repeat in range(periodsPerOctave):
       scale.append(period*repeat + root)
       scale.sort()
       
       It assumes the generator and period are specified in cents. 
       It also assumes periodsPerOctave is given. If you don't 
       have that you can still get a tuning table for one period.
       
       sorted([(n*generator)%period
       for n in range(stepsPerPeriod)])
       
       You always have to choose the number of steps you want. You 
       may also like the period to be include in the table
       
       sorted([(n*generator)%period
       for n in range(stepsPerPeriod)])+[period]


       

       ------

       See email replies "[tuning] Re: Algorithm for 'unfolding' regular temperaments" in my action folder for details

******* DONE [#B] Ask tuning mailing list for regular temperament algorithm
       	CLOSED: [2008-04-07 Mon 22:14]

       	Guess: rank two regular temperament: 
       	By adding the GENRATOR repeatedly, namely SIZE times, that number of pitches is obtained. These pitches are then again transposed by the PERIOD (commonly 1200 cent) 


** TODO Add support for microtonal music to Fenv.renderAndPlayMidiFile

   [[file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Fenv/Fenv.oz::proc%20RenderAndPlayMidiFile%20MyScore%20Args][file:~/oz/music/Strasheela/strasheela/strasheela/contributions/anders/Fenv/Fenv.oz::proc RenderAndPlayMidiFile MyScore Args]]

*** DONE							    :ARCHIVE:

    Approach: user explicitly specifies for each MIDI chan in score (new arg to Fenv.renderAndPlayMidiFile) over which actual MIDI chans it will be distributed. Number of actual MIDI chans should be max number of sim notes of this score chan. Microtonal notes will then be distributed to given MIDI chans in round-robin fashion, and pitchbind will be added according to score pitch.
    MIDI chans specified zero-based

    ?? Default for unspecified MIDI chans: 
    - use only this chan, i.e. only supported for monophonic voices
    - 'warn': user is warned that this chan only supports monophonic MIDI by default

    Args:
    resolution: pitchbend resolution
    channelDistribution: tuple specifying which score chan is output to which actual chan, e.g. for distributing chan 0 over chans 0-7 do
       	unit(0: [0 1 2 3 4 5 6 7])



*** TODO test microtonal MIDI output

*** TODO 

    If note already has pitchbend fenv, then add offset to this pitchbend fenv such that 0 corresponds to its microtonal pitch

    Use Out.midi.noteToPitchbend to get offset value

    Approach: Change this in Fenv.itemFenvsToMidiCC (i.e. check when Controller==pitchbend and then optionally shift that fenv depending on some new arg to Fenv.itemFenvsToMidiCC), and then also change all defs using it (only defs in Fenv)


** TODO Fenv.renderAndPlayMidi: add Fenv controlling articulation (note length)
   
   ?? Fenv value is note duration factor 
   E.g., 0.8 results in some non-legato, 1.1 is legato, 0.3 is staccato
   
   Or is addition better than multiplication
   I feel multiplication is more flexible, but sometimes I may want to add instead
   ?? can I somehow generise and allow for both options?


** MIDI output: use ports/tracks

   csvmidi seems to support MIDI ports, so I can have > 16 chans in total  

   !! Ports are used as tracks in Cubase??

   ----

   Doc: http://www.fourmilab.ch/webtools/midicsv/    
   /Track, Time, MIDI_port, Number/
   This meta-event specifies that subsequent events in the Track should be sent to MIDI port (bus) Number, between 0 and 255. This meta-event usually appears at the start of a track with Time zero, but may appear within a track should the need arise to change the port while the track is being played. 

   -> I would likely need to refactor MIDI file output such that multiple tracks are output...
     

** Diss resolution
   [[file:Strasheela-Maybe-TODO.org::*Introduce%20some%20generalised%20concept%20of%20resolution%20of%20dissonances][file:Strasheela-Maybe-TODO.org::*Introduce some generalised concept of resolution of dissonances]]


** TODO Create variant for Out.saveScore using pickles

   Some score objects (e.g., Fenvs which contain procs) cannot be translated into text (code), i.e. cannot be "archived". However, they could be picked! 

   On the other hand, pickling not supported for undetermined values. Can I have an approach which works for both cases (translates undetermined vars into text/code which would be compiled into Oz values during loading.)

   Alternative idea for storing Fenvs to textual format: store approximated Fenv (sample Fenv and create envelope from sampling data)


** Define how fenvs of prototype motifs can be variated with motif instance arguments 

   [this is actually a Strasheela TODO..]

   See [[file:MidiOut_toTassman/MusicRepresentationForTassmanPiece.org::*Prototype%20Motif%20Variation][file:MidiOut_toTassman/MusicRepresentationForTassmanPiece.org::*Prototype Motif Variation]]

*** TODO Extend ProtoMotif 'scriptArgs'

    see [[file:MidiOut_toTassman/MusicRepresentationForTassmanPiece.org::*Prototype%20Motif%20Variation][file:MidiOut_toTassman/MusicRepresentationForTassmanPiece.org::*Prototype Motif Variation]]

*** TODO Check my ideas out with simple motif prototype (e.g., with fenvs at different levels) and motif instance args 

     See [[file:MidiOut_toTassman/MusicRepresentationForTassmanPiece.org::*Prototype%20Motif%20Variation][file:MidiOut_toTassman/MusicRepresentationForTassmanPiece.org::*Prototype Motif Variation]]


** TODO Get Oz syntax highlighting at GitHub

   Write Oz lexer for Pygments (using Python)

   *!! Pieter Belmans (pbelmans) used Strasheela and Oz before and has experience with Pygments !!*
   He and may want to help me write a lexer for Oz
   !! A lexer definition by pbelmans (Pieter Belmans) for the GAP language
   http://pbelmans.wordpress.com/2012/04/20/a-pygments-lexer-for-gap/
   https://github.com/pbelmans/gap-pygments-lexer
   (Oz/Strasheela related: http://pbelmans.wordpress.com/category/music/) 


   Doc: Pygments Introduction and Quickstart
   http://pygments.org/docs/quickstart/

   Doc: Write your own lexer
   http://pygments.org/docs/lexerdevelopment/

   Available lexers
   http://pygments.org/docs/lexers/

   Pygments development and source at bitbucket
   https://bitbucket.org/birkenfeld/pygments-main/src
   They have several open pull requests including some lexers 
   
   Full lexers definition sources in 
   https://bitbucket.org/birkenfeld/pygments-main/src/5cc94956e233/pygments/lexers


*** First step: define Lexer that simply highlights Oz keywords 

    I need some full and simple template, then this is actually very easy to define
    -> No, they want lexers that highlight the full syntax, but that should be possible too -- see Roy book, p. 835ff for Oz syntax details (not very much..)
    
    *List of Oz keywords from van Roy book, p. 841 (lated PDF draft)*

andthen default
false feat finally for from fun functor if import in
lazy
local
lock return meth	self mod	skip not	then of	thread or 	true orelse	try prepare 	unit proc
prop raise require 
at attr break case catch choice class collect cond  continue declare
define dis  div do else elsecase  elseif elseof  end
export fail


*** Consider later to refine/extend that lexer

*** Make my Lexer available for the Pygments team and send them pull request

    Add an example file to tests/examplefiles that exercises as much of the syntax as possible
    (And please don't commit on named branches. But I can fix that on my end as well.)


    Note that it can take several weeks until they react (see http://groups.google.com/group/pocoo-libs/browse_thread/thread/fbf52b3da5759d00?pli=1)

Example lexer pull request (with some minor errors)
https://bitbucket.org/birkenfeld/pygments-main/pull-request/61/

Google, e.g., pygments lexer for more examples..


*** Notify GitHub about new Oz lexer





* Strasheela cleanup and refactoring

** Reduce score hierarchy to temporal tree



** Reduce abstract score classes that I did never use

   For example remove ScoreCore.oz classes
   - Modifier
   - Aspect
   - TemporalAspect
   - Container always means temporal container
   

** Move some essential contributions into core of Strasheela 

   - Fenvs
   - ? HS
   - ? Patterns
   - MidiInput.oz -- no that is just not quit up for production yet.. (and I better use the tools of OpenMusic etc. with their buildin quantisation)


* Strasheela doc

** Strasheela tutorial

   [Could become a book in the long term]

   Rewrite tutorial from a music theory and composition point of view
   - Look at constraining various musical aspects such as rhyth (accent constraints), harmony, melody, texture etc.
   - Introduce any formal details of Strasheela within such musical contexts

   see [[file:~/texte/0-Publications/10-Book-ModellingTheoryAndComposition/Anders-ModellingTheoryAndComposition.org]]

*** Format

    Use Worg CCS, but add acknowledgment mentioning CCS authors Bastien Guerry and Sebastian Rose.

    see 
    file:~/oz/music/Strasheela/StrasheelaDoc_Rewrite/doc-source/
  

*** TODO Collect examples for Strasheela tutorial		       :SOON:


** Consider transforming all Strasheela example files into *.org mode files with code blocks, notation outputs, and brief comments -- then I can publish them all online

   Ideally the code blocks could be "folded" in an out in the resulting HTML fil. Such feature would also be useful for other writings of mine with (extensive) code.

   Such "folding" in be realised with CSS / Javascript 
   E.g., see http://www.randomsnippets.com/2008/02/12/how-to-hide-and-show-your-div/
   http://webdesign.about.com/od/dhtml/a/aa101507.htm
   
** Add section with compositions to Strasheela website (and to my own)

   - Also add results of microtonal music "content" for MOTU to my website

   - ? Harmony studies
   - ? Microtonal music "content" for MOTU


* ? Strasheela redesign						    :ARCHIVE:

  ?? Port to Python (Cyton) using Denys Duchier's Gecode bindings for Python
  https://launchpad.net/gecode-python

  Advantage of Python

  - Language more widely known -- more easy to attract other contributors
  - Other computer music developments exist for Python, see 
    http://wiki.python.org/moin/PythonInMusic
  - ?? More modern development tools?
  - Access to many other libraries: GUI...


  


* Other 

** TODO Read Strasheela doc				    :@READ:SOON:EASY:

   know your system, e.g., know all my Patterns 


** Mozart compilation 

   I already pull git sources, see 
   https://github.com/mozart
   

   see instruction at 
   http://gforge.info.ucl.ac.be/plugins/wiki/index.php?FAQ&id=17&type=g
   http://gforge.info.ucl.ac.be/plugins/wiki/index.php?CompilingMozart&id=17&type=g

  - Configuration error of gmp: try deinstalling gmp and instead installing gmp version 4.1.2 (current version at time when Mozart configure script was programed)

** GeOz -- is this still relevant?
   
*** Mail with important info to installation and doc

    [check Mail app for formatted version of this mail]

Dear Gustavo,

I am extremely sorry for the delay (we have 6-month old twins and  
there has been a flu, later your mail got buried under other stuff).

On 04.10.2009, at 11:52, Gustavo Gutierrez wrote:
On Wed, Sep 23, 2009 at 3:10 PM, Torsten Anders <torsten.anders@plymouth.ac.uk 
wrote:
PS: In the long run, I am interested to update Strasheela (http://strasheela.sourceforge.net 
) to use Geoz instead of the "classical" Oz constraint facilities.  
So, I am very much interested in the future of Geoz :)


That's really great, I think we can benefit from trying the new  
mozart implementation with your application. In this way we can  
identify bugs and fix them before releasing. What do you think?

This certainly makes sense and I would like to go for it.  
Unfortunately, I currently have hardly any time for Strasheela  
development at all due to various other duties. If all goes as  
planned, then I will again have time and even co-workers starting  
summer 2010. So, my question is: what is your time schedule for Mozart  
development?

On 04.10.2009, at 11:52, Gustavo Gutierrez wrote:
On Wed, Sep 23, 2009 at 3:10 PM, Torsten Anders <torsten.anders@plymouth.ac.uk 
wrote:
Dear Gustavo,

The question concerning the Oz Explorer vs Gist and Gecode reminded  
me: what is actually the current status of the Geoz project?  
Obviously you frequently submit changes to the mozart-gecode  
branch, but the available public information has not been updated  
for a long time. E.g., here are a few related links which seem to  
be out of date.

http://cic.puj.edu.co/wiki/doku.php?id=grupos:avispa:geoz
http://gna.org/projects/geoz

So, what is the current status? Is the installation process  
documented somewhere (up to date)?

The installation is not documented, however it is not to difficult.  
The only thing needed is an specific version of gecode. The best way  
to do this is try to download the sources and then run configure. It  
will try to find the right gecode version and will inform you about  
anything you need.

I see. So, before actually installing Gecode I just ran the configure  
script on the latest SVN version of mozart-gecode and it told me that  
Gecode version 2.2.0 is required. Will the required Gecode version be  
updated later?

Are the changes of Geoz compared with the "classical" Oz constraint  
facilities documented somehow?

One of the last commits handled this point. If you try to build the  
documentation then you will see some new sections which are intended  
to present this facilities. The documentation is not finished and  
has not been reviewed by anyone so it may contain english errors but  
anything you need I am willing to help.

It is great to hear that you started updating the documentation to  
this effect. I will not attempt building the documentation (too many  
dependencies), but try to study the SGML sources. I just saw that you  
updated files in doc/fdt/. I will try to find out your changes by  
checking the SVN history. For example, I found

http://gforge.info.ucl.ac.be/plugins/scmsvn/viewcvs.php?view=rev&root=mozart&revision=17245
 	
I am particularly interested in the graph constraints -- what is  
the situation there? What version of Gecode is supported?

This is my main current work right now. We have an implementation of  
graph constraints but it is still in gecode and not in mozart. The  
thing is that we need to work a lot on efficiency at the c level  
before bringing the interface to mozart. If you want to try them  
anyway I can point you in the right direction. So far we have a good  
design but the problem we are trying to solve has shown us that  
there is some pending work on handling big graphs. Just to give you  
an impression of what I am talking about, we have a propagator  
between two graph variables and one of them is a graph with around  
11'000.000 edges. This is obviously quite big and we ran out of  
memory.

Wow, these figures are impressive!

Best wishes,
Torsten


*** TODO Install GeOz 
    
    NOTE: development of Gecode/J is discontinued. So, I better stick with Mozart/Oz. But then it would be a good idea to support gustavo getting Gecode running for Oz. E.g., moral support by installing it and asking questions, also finding bugs perhaps..

    First ask  gustavo.ggutierrez@gmail.com whether meanwhile graph constraints are working again

1) Download gecode sources (we don't have support for binary distributions yet) and build them. In the install directory there will be a lib/pkgconfig subdir. Export the shell variable PKG_CONFIG_PATH to /Users/u/install/lib/pkgconfig. For this you need pkg-config installed, if not, download it form http://www.rudix.org/packages.html .

2) With the previous variable exported, the mozart configure will properly detect gecode. Then, just configure mozart (with debug support if you want) and install it.

3) Now, you should have a working installation of the development branch and you can take a look at mozart-gecode/share/examples/gfd for the examples. That will give you and impression of the changes from the user level.

If problems occur ask gustavo.ggutierrez@gmail.com


*** Check out documentation

    The reference doc is updated to reflect the new constraint system
    Wait/ask gustavo.ggutierrez@gmail.com to render the HTML files

*** Check out examples

    How did coding style change? What else did change

    file:/Users/t/oz/mozart/branches/mozart-gecode/mozart/share/examples/gfd/

    possibly create new small-scale examples for testing and to better understand

**** FD constraints (including selection constraints)
**** FS constraints
**** !! Graph constraints
     
     currently broken in Gecode 2.*
     gustavo.ggutierrez@gmail.com said this should be fixed in about 1-2 months time (i.e. mid Oct-Nov)

**** Space combinators 


*** Check out how performance of examples 

    Noticable difference of old version?


   
