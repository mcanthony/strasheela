#+CATEGORY: Strasheela

* Strasheela examples					      :MAYBE:STRASHEELA:
  
** Groove templates					    :MAYBE:

  an example for Olle Romo
  see description in strasheeela support tracker
https://sourceforge.net/tracker/index.php?func=detail&aid=1883454&group_id=167225&atid=842099


** Inventio example 							 :MAYBE:

*** harmonic etc analysis of inventio 1

*** Inventio B: Fuege "BrainImage Data" in CSP ein

?? As parameter or info for motif?

Abstract applied constraint, so the effect is controllable



* Strasheela design					      :MAYBE:STRASHEELA:

** Oz Module.link / Module.apply: why did I need it 			 :MAYBE:

See ~/oz/music/Strasheela/private/test/OtherFunctors/ModuleLinkingTest

why did I ever need ModuleLink instead of Module.link?

Could it be that the problem appeared only when a buffer which loaded some module was re-fed? 
Isn't this a situation which is perfectly normal when you work with multiple non-functor files in the OPI? Shouldn't the default module manager in the OPI behave like the default module manager for functor compilation (which is only a single one, even if called in multiple files -- so no multiple copies of functors/modules are created)

** OutGUI 								 :MAYBE:

** NonmensuralENP->MensuralENP as Lisp def 				 :MAYBE:

see Strasheela/private/WorkInProgress/NonmensuralENP->mensuralENP 



** Extend meter model [[file:~/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/Measure/Measure.oz][Measure.oz]]

   Do this if you actually need it..

*** Extend meter model for changing meter

*** Create example which constrains metric structure 

    Music representation: metric structure runs in parallel to other score objects (like harmonic structure)
    For accessing potentially inaccessible context sim meter use delayed constraint application: filter and test with a reified constraint together with an equality test, e.g.

{ForAll {MyScore filter($ fun {$ X}
			     {IsMeasure X} andthen
			     {MyNote isSimultaneousItemR($ X)} == 1
			  end)}
 MyConstraint}


**** Check "Orjan's library PWMC for ideas: constraint application depending on rhythmical structure

     E.g., 


    - !!?? there was some idea of "Orjan which I wanted to incorporate to Strasheela and for which I needed this delayed constraints approach..? 
      Was it harmony rule depending on metric structure? For example, no non-chord tones on strong beat

    
*** Lilypond output for metric structure				 :MAYBE:



** refactor output means: they are inconsistend, perhaps not general enough etc. :MAYBE:

 - output of 'non-existing' timed items (e.g. notes of duration 0) -- skip

 - !!?? make MakeEvent2CsoundFn more general: Idea Spec is either some
    method (e.g. an accessor) or some unary function which gets
    object as arg.

 - refactor Lilypond output to use the (still to program) score transformation with allows to restructure a Strasheela score hierarchy


** Add a score transformation with allows to restructure a Strasheela score hierarchy in a highle generic way (e.g. for outputting the fixed hierarchies of ENP-notation, Lilypond, MIDI...)

   see [[file:/Users/t/oz/music/Strasheela/private/WorkInProgress/ScoreTransformation/]]



*** Extension: retain hierachic nesting info 

    It would be great if in a transformed and more flat representation the info on the previous hierarchic representation is still retained (e.g. added to item info: 'begin(<marker>)' and 'end(<marker>)'). When the more flat representation is then output (e.g. to lilypond, ENP-notation or MIDI), these markers could be used to somehow retain the old nesting in the output format (e.g. to draw analysis brackets in Lilypond or ENP, or as text events in MIDI out). When the output music is edited, it could later perhaps be loaded into Strasheela again and the old hierarchy could be restored??


** Refactoring 

*** Refactor harmony model

**** Harmony model: Databases as arg for object creation		 :MAYBE:

     Presently there is only a global chord, scale etc database 
     
     I should keep a global database as an option, because this is most suitable for most CSP. Additionally, it should be possible to give the databases to score objects (chords, scales, ..) as optional init argument -- the init arg defaults to the global database.
     
     This refactoring requires that all database accessors expect a score object (chord, scale ..) or its database as argument. 
     Possibly, I leave the old database accessors and setters as is (i.e. without additional object/database arg) for compatibility of the old examples. 
     In that case, I need to define new additional accessors which expect the object/database arg, and the doc of both the new and the old accessors/setters must make these two options using databases very clear.


**** Harmony model: Clean up doc					 :MAYBE:


**** Output to lilypond etc: make extension for outputting specific score information (more) reusable :MAYBE:

E.g. for outputting information such as meter, key, motif boundaries... 


**** !!?? Some means to define rules in a more modular/generic way -- currently, e.g., more complex counterpoint rules, can not be used in other CSP as they rely on the specific score representation (e.g. extensions to Note) :MAYBE:

   -> Better solution: use memoization instead of extending the music representation ad hoc
   However, memoization can be computationally expensive

**** toInitRecord: further cleanup					 :MAYBE:

***** toInitRecord: what to do with init args which get procedures or classes (e.g. classes of harmony model)?

      %% I must exclude procedures and classes as init argument if I export into text files.
      %% Moreover, these will probably not work for pickling: can I pickle a proc which references an object??
      %%
      %% ?? when do I need procedures and classes as init argument: if I what to recreate a CSP (e.g. after hand-editing results). I probably don't need these args for score objects which are fully determined and are only archived..


***** Add correct cases to toInitRecord defs for classes such as HS.score.note etc which expect procedures as init args. I may filter out these args with excluded..

***** use output of toInitRecord together with init classes for saving of score instances into pickles
      
   ?? also output into text file with specified classes: I can introduce a "dictionary" which maps classes to their textual representation...
     
    -> this todo item is probably outdated already: cf. Out.saveScore

**** Music representation consistency: so far, I used class attributes for object parameters etc. However, for the quick definition of subclasses with Score.makeClass I introduced stateless class features for additional parameters etc. This is neither consistent in the class usage (use of different accessors like {X getA} and Y.b) nor does it allow for later score editors.. :MAYBE:

**** ?? remove toPPrintRecord and replace it with highly generic toFullRecord? :MAYBE:
     sorted mainly already?
     OLD: toPPrintRecord: output graph mode using IDs similar to input of MakeScore

**** ?? add textual representation of parameters: currently, parameters are not supported my Score.makeScore :MAYBE:

     should I add parameter support at all? Score.makeScore _does_ work on note-level. I would only need to create single params, e.g., for item init arg addParameters


* Strasheela installation						 :MAYBE:

** [#A] Create test program (executable) which tests a few core Strasheela functionalities and reports results at stdout to the user :MAYBE:

useful for package creators and new users to test whether installation was successful


** [#C] ?? Define Oz GUI application for creating an OZRC file: pathes for applications and directories are then specified in a GUI :MAYBE:


* General Oz todo						      :MAYBE:OZ:


** ozh								    :MAYBE:

*** ozh: add SGML doc

the orig documentation source files for creating, e.g., the HTML doc are still missing in our branch

I meanwhile checked -- it appears this file is not available any more online


*** ?? ozh: add TODO list to wiki

  - better file names for resulting HTML files, and better anchor names (make them persistent): see below
  - better/more flexible layout of doc strings (see below) 
  
*** ozh: update save file and anchor names 

File names and anchor names should be generated from source entries (e.g., file names, class names) instead of generic names like node1.html or class1.html where links from elsewhere into the documentation get if files etc. are added to the source later

*** ozh: Formatting of documentation strings 

The current implementation does not even preserve whitespace after a new line in doc strings. Consequently, the layout of code examples is destroyed.

Even better would be, if some wiki layout is supported (optionally). Does there exist some easy wiki-layout -> HTML application (expecting wikified text snippets and returning corresponding HTML code snippets).   






