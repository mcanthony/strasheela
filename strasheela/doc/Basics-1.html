<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>First Steps in Oz</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
<div id="header">
  <ul class="nav">
    <li class="nav1"><a href="index.html">home</a></li>
    <li class="navn"><a href="https://sourceforge.net/projects/strasheela/">download at sourceforge</a></li>
    <!-- <li class="navn"><a href="IndexOfPages.html">site map</a></li> -->
    <li class="navn"><a href="contact.html">contact</a></li>
  </ul>
  <div id="logo">
    <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=167225&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </div>
</div>
    <h1>First Steps in Oz</h1>
    <!-- Page published by Emacs Muse begins here -->
<div class="contents">
<dl>
<dt>
<a href="#sec1">About this document</a>
</dt>
<dt>
<a href="#sec2">&mdash; First Steps in Oz</a>
</dt>
<dt>
<a href="#sec3">This Tutorial</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec4">Conventions</a>
</dt>
<dt>
<a href="#sec5">BACKGROUND</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec6">Hello World and Comments</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec7">Browse</a>
</dt>
<dt>
<a href="#sec8">Show</a>
</dt>
<dt>
<a href="#sec9">Inspect</a>
</dt>
<dt>
<a href="#sec10">Line comment</a>
</dt>
<dt>
<a href="#sec11">Block comment</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec12">Calculator</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec13">Integer example 1</a>
</dt>
<dt>
<a href="#sec14">Integer example 2</a>
</dt>
<dt>
<a href="#sec15">Integer example 3</a>
</dt>
<dt>
<a href="#sec16">Float example 1</a>
</dt>
<dt>
<a href="#sec17">Float example 2</a>
</dt>
<dt>
<a href="#sec18">Float example 3</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec19">Variables</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec20">Variable declaration</a>
</dt>
<dt>
<a href="#sec21">Variable scope</a>
</dt>
<dt>
<a href="#sec22">A variable can be unbound</a>
</dt>
<dt>
<a href="#sec23">Cells</a>
</dt>
<dt>
<a href="#sec24">BACKGROUND</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec25">If</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec26">if ... else ... end</a>
</dt>
<dt>
<a href="#sec27">if ... end</a>
</dt>
<dt>
<a href="#sec28">if as an expression</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec29">Procedure and Functions</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec30">Usage</a>
</dt>
<dt>
<a href="#sec31">Defining Max: procedure</a>
</dt>
<dt>
<a href="#sec32">Defining Max: function</a>
</dt>
<dt>
<a href="#sec33">Functions are procedures</a>
</dt>
<dt>
<a href="#sec34">Procedures as functions</a>
</dt>
<dt>
<a href="#sec35">Another example TODO</a>
</dt>
<dt>
<a href="#sec36">$ marks a return value</a>
</dt>
<dt>
<a href="#sec37">Recursion</a>
</dt>
<dt>
<a href="#sec38">BACKGROUND</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec39">Atoms and Names</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec40">Atoms</a>
</dt>
<dt>
<a href="#sec41">Equality</a>
</dt>
<dt>
<a href="#sec42">Names</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec43">Compound Types</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec44">Records (1)</a>
</dt>
<dt>
<a href="#sec45">Records (2)</a>
</dt>
<dt>
<a href="#sec46">Records (3)</a>
</dt>
<dt>
<a href="#sec47">Accessing record fields</a>
</dt>
<dt>
<a href="#sec48">Tuples (1)</a>
</dt>
<dt>
<a href="#sec49">Tuples (2)</a>
</dt>
<dt>
<a href="#sec50">Tuples (3)</a>
</dt>
<dt>
<a href="#sec51">Lists (1)</a>
</dt>
<dt>
<a href="#sec52">Lists (2)</a>
</dt>
<dt>
<a href="#sec53">Lists (3)</a>
</dt>
<dt>
<a href="#sec54">Lists (4)</a>
</dt>
<dt>
<a href="#sec55">Pairs (1)</a>
</dt>
<dt>
<a href="#sec56">Pairs (2)</a>
</dt>
<dt>
<a href="#sec57">Strings (1)</a>
</dt>
<dt>
<a href="#sec58">Strings (2)</a>
</dt>
<dt>
<a href="#sec59">Virtual Strings</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec60">Error messages</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec61">Parse error</a>
</dt>
<dt>
<a href="#sec62">Static analysis error</a>
</dt>
<dt>
<a href="#sec63">Binding analysis error</a>
</dt>
<dt>
<a href="#sec64">Type error</a>
</dt>
<dt>
<a href="#sec65">Failure</a>
</dt>
</dl>
</dd>
</dl>
</div>


<h2><a name="sec1" id="sec1"></a>
About this document</h2>

<p class="first">This file was automatically generated from the interactive Strasheela tutorial. Some aspects of the text only make sense in the original interactive tutorial application (e.g., buttons indicated to press, and positions specified on the screen), and not in this version of the text.</p>


<h2><a name="sec2" id="sec2"></a>
&mdash; First Steps in Oz</h2>

<p class="first">This chapter covers fundamental concepts in Oz.</p>





<h2><a name="sec3" id="sec3"></a>
This Tutorial</h2>

<p class="first">This interactive tutorial demonstrates the basics of the Oz programming language and Strasheela.  By presenting small code snippets which can be easily executed and edited, we hope to simply the process of learning about Oz/Strasheela.</p>

<p>Nevertheless, this tutorial is kept brief.  The explanation of Oz focuses on aspects which are particularly important for Strasheela, and even Strasheela concepts are only briefly outlined.  In other words, it is not the intention of this tutorial to replace the extensive documentation already available on Oz, nor my thesis on Strasheela ;-)</p>

<p>This tutorial is organised in small lessons.  After you started the interactive tutorial application, you can select the examples in the list at the top-left of this window.  Many lessons consist of several sub-examples, accesible via the list in the bottom-right corner.  These examples are best studied in their order.</p>

<p>(if you are reading the tutorial in your HTML browser, of course there are no lists of lessons and examples)</p>


<h3><a name="sec4" id="sec4"></a>
Conventions</h3>

<pre class="src">
<span style="color: #b22222;">/*</span><span style="color: #b22222;">
We use a few conventions to present information in this tutorial:

  - =command=: in the running text, code in the Oz language is formatted
    =like this=; remove them when writing your own code.
  - {...}: the {curly braces} denote a procedure in Oz; you should never
    remove them when writing your own code.
  - </span><span style="color: #ff0000; font-weight: bold;">WARNING:</span><span style="color: #b22222;"> explains a particularly confusing part of the Oz language.
  - BACKGROUND: these examples give brief explanations of generic
    concepts in Computer Science; please see them if the lesson contains
    unfamiliar terms.
*/</span>

</pre>


<h3><a name="sec5" id="sec5"></a>
BACKGROUND</h3>

<pre class="src">
<span style="color: #b22222;">/*</span><span style="color: #b22222;">
For explanations about general concepts, see:

  - van Roy and Haridi (2004). Concepts, Techniques, and Models of
      Computer Programming. MIT Press.
      http://www.info.ucl.ac.be/~pvr/book.html
  - The Oz documentation:
      http://www.mozart-oz.org/documentation/
  - Wikipedia (maybe?  -I'd rather find a better resource, though) TODO
*/</span>

</pre>



<h2><a name="sec6" id="sec6"></a>
Hello World and Comments</h2>

<p class="first">By convention, the first steps in any programming langauge is to output the text &quot;Hello World!&quot;.  This tutorial obeys this rule.  :)</p>

<p>Hit the [Run] button in the bottom-left corner to execute this example.  The other examples demonstrate alternative ways to output information:</p>

<ul>
<li>Browse: opens a Browse window</li>
<li>Show: outputs text to standard out</li>
<li>Inspect: opens an Inspect window</li>
</ul>

<p>(the Browse and Inspect windows might be hidden behind this window)</p>


<p>Oz supports line comments and block comments.  Please select each example to see how these comments differ.</p>

<p>(Executing these comment-examples does nothing, of course!)</p>

<h3><a name="sec7" id="sec7"></a>
Browse</h3>

<pre class="src">
{Browse <span style="color: #bc8f8f;">'Hello World!'</span>}
</pre>


<h3><a name="sec8" id="sec8"></a>
Show</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Show something at standard out (the commandline where you started
this tutorial). */</span>

{Show <span style="color: #bc8f8f;">'Hello World!'</span>}
</pre>


<h3><a name="sec9" id="sec9"></a>
Inspect</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The inspector shows sometimes more information than the Browser
(depending on the inspected value).  The inspector may be hidden behind
this tutorial.. */</span>

{Inspect <span style="color: #bc8f8f;">'Hello World!'</span>}
</pre>


<h3><a name="sec10" id="sec10"></a>
Line comment</h3>

<pre class="src">
<span style="color: #b22222;">% </span><span style="color: #b22222;">this is a line comment
</span></pre>


<h3><a name="sec11" id="sec11"></a>
Block comment</h3>

<pre class="src">
<span style="color: #b22222;">/*</span><span style="color: #b22222;">
this is a
block
comment
*/</span>
</pre>



<h2><a name="sec12" id="sec12"></a>
Calculator</h2>

<p class="first">This example executes simple numeric calculations and displays the result.</p>

<p>Try changing the calculation by using different numbers and freely combining the operators +, -, * , ~ (negation), div (integer division), mod (integer modulus) and / (float division).  You may also use parenthesis to indicate precedence.</p>

<p>You can use integers (e.g. 3, 7) and floats (e.g. 1.0, 3.14).  However, you can not directly mix integers and floats in a calculation (in that case, an error will be printed at the command line).</p>

<h3><a name="sec13" id="sec13"></a>
Integer example 1</h3>

<pre class="src">
{Browse 3<span style="color: #a020f0;">+</span>4}
</pre>


<h3><a name="sec14" id="sec14"></a>
Integer example 2</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">~ is the negation sign
</span>{Browse <span style="color: #a020f0;">~</span>7 <span style="color: #a020f0;">*</span> 5}
</pre>


<h3><a name="sec15" id="sec15"></a>
Integer example 3</h3>

<pre class="src">
{Browse (4 <span style="color: #a020f0;">+</span> 2) <span style="color: #a020f0;">div</span> 2}
</pre>


<h3><a name="sec16" id="sec16"></a>
Float example 1</h3>

<pre class="src">
{Browse 3<span style="color: #a020f0;">.</span>0 <span style="color: #a020f0;">/</span> <span style="color: #a020f0;">~</span>2<span style="color: #a020f0;">.</span>0}
</pre>


<h3><a name="sec17" id="sec17"></a>
Float example 2</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A float is converted into the closest integer
with the function FloatToInt (in case two integers are equally close it rounds
to the closest even integer).  There is also a function IntToFloat. */</span>

{Browse {FloatToInt 3<span style="color: #a020f0;">.</span>5}}
</pre>


<h3><a name="sec18" id="sec18"></a>
Float example 3</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">many other numeric functions are available for floats,
</span><span style="color: #b22222;">%% </span><span style="color: #b22222;">e.g., Exp, Log, Sin, Cos...
</span>{Browse {Sqrt 9<span style="color: #a020f0;">.</span>0}}
</pre>



<h2><a name="sec19" id="sec19"></a>
Variables</h2>

<p class="first">All variables in Oz must start with a capital letter.  They must be declared first, for example, with the keyword <code>local</code>.</p>

<p>Global variables can be introduced with the keyword 'declare'.  However, global variables are intended for testing and are not supported in this tutorial application.</p>

<p>WARNING: Oz variables are single assignment variables.  If you do not have experience with functional or logic programming languages, we highly recommend reading the background example!  Variables may be bound to a value, or may be left unbound or even partially bound (for compound data types such as lists).  However, their value can never be changed!</p>

<p>Rewritable data storage is also supported by Oz; the simplest form are called Cells.  Other types of stateful data include arrays, directories, and objects, but we shall not cover them in this tutorial.</p>

<h3><a name="sec20" id="sec20"></a>
Variable declaration</h3>

<pre class="src">
<span style="color: #a020f0;">local</span>
   X = 1 <span style="color: #a020f0;">+</span> 1
   Y
<span style="color: #a020f0;">in</span>
   Y = 3
   {Browse X<span style="color: #a020f0;">*</span>Y}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec21" id="sec21"></a>
Variable scope</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Local statements can be freely nested (like
virtually everything in Oz).  Oz supports static or lexical scope
(i.e. a variable always refers to its nearest enclosing binding). */</span>

<span style="color: #a020f0;">local</span>
   X = 3
<span style="color: #a020f0;">in</span>
  <span style="color: #a020f0;">local</span>
    <span style="color: #b22222;">%% </span><span style="color: #b22222;">shadows the outer X
</span>    X = 4
  <span style="color: #a020f0;">in</span>
    {Browse X}
  <span style="color: #a020f0;">end</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">later, browse original X
</span>  {Browse X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec22" id="sec22"></a>
A variable can be unbound</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Watch the Browser: X is first unbound (_ is displayed).
X is bound to 3 after 2000 msec. */</span>

<span style="color: #a020f0;">local</span>
   X
<span style="color: #a020f0;">in</span>
   {Browse X}
   {Delay 2000}
   X = 3
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec23" id="sec23"></a>
Cells</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Cells provide rewritable memory for values.
</span><span style="color: #ff0000; font-weight: bold;">WARNING:</span><span style="color: #b22222;"> The syntax for reading and writing to cells is different than
the syntax for variables.
*/</span>
<span style="color: #a020f0;">local</span>
  C = {NewCell 0}  <span style="color: #b22222;">% </span><span style="color: #b22222;">create new cell with initial value 0
</span>  V
<span style="color: #a020f0;">in</span>
  {Browse <span style="color: #a020f0;">@</span>C}      <span style="color: #b22222;">% </span><span style="color: #b22222;">browse cell value
</span>  {Delay 2000}
  C <span style="color: #a020f0;">:=</span> 5           <span style="color: #b22222;">% </span><span style="color: #b22222;">change cell value to 0 (stateful operation)
</span>  {Browse <span style="color: #a020f0;">@</span>C}
  V = <span style="color: #a020f0;">@</span>C
  {Browse V}
<span style="color: #a020f0;">end</span>

</pre>


<h3><a name="sec24" id="sec24"></a>
BACKGROUND</h3>

<pre class="src">
<span style="color: #b22222;">/*</span><span style="color: #b22222;">
TODO Torsten: revise terminology

Terms: single assignment, logic variable, bound/determined variables,
unbound/free variables, local variables, global variables.

In mainstream programming languages, variables may be read and written
at will. Actually, a better term for them may be "mutables".  This often
confuses new programmers, since variables in math do not operate this
way -- once the value of a variable is set, it stays set.

In Oz, variables operate more like math variables. Assigning a value
to a variable is called "binding"; once a variable is "bound", it
cannot be changed.  Variables are "free" (have no value) by default,
and compound variables (such as lists) may be "partially bound" (ie
some elements may be bound, while others are unbound).


Reading:

  - van Roy and Haridi, Chap. 1-2 (in particular Sec. 1.2, and 2.2).
  - Oz Tutorial, Chap. 3, introduction
*/</span>

</pre>



<h2><a name="sec25" id="sec25"></a>
If</h2>

<p class="first">Oz provides the usual <code>if</code> control structure.  Note that unlike many programming languages, parenthesis () are not required around the condition, althought they may make the code easier to read.</p>

<p>Please note that the <code>if</code> control structure can also be used as an expression which returns a value from the <code>then</code> or <code>else</code> clause.</p>


<h3><a name="sec26" id="sec26"></a>
if ... else ... end</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">try changing 2 to 6...
</span>
<span style="color: #a020f0;">if</span> (2 <span style="color: #a020f0;">&lt;</span> 5) <span style="color: #a020f0;">then</span>
    {Browse less}
<span style="color: #a020f0;">else</span>
    {Browse more}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec27" id="sec27"></a>
if ... end</h3>

<pre class="src">

<span style="color: #b22222;">%% </span><span style="color: #ff0000; font-weight: bold;">NOTE:</span><span style="color: #b22222;"> the =test= formatting has no effect inside the Oz-tag!
</span><span style="color: #b22222;">/* </span><span style="color: #b22222;">The `else' clause is optional. This example does nothing, but try
changing `==' to `\=.' The operations `==' and `\=' test equality and
inequality of values. */</span>

<span style="color: #a020f0;">if</span> (this <span style="color: #a020f0;">==</span> that) <span style="color: #a020f0;">then</span>
    {Browse hi}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec28" id="sec28"></a>
if as an expression</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">This `if' returns a value, which is browsed.
</span>
{Browse
 <span style="color: #a020f0;">if</span> (2 <span style="color: #a020f0;">&lt;</span> 5) <span style="color: #a020f0;">then</span> less <span style="color: #a020f0;">else</span> more <span style="color: #a020f0;">end</span>}
</pre>



<h2><a name="sec29" id="sec29"></a>
Procedure and Functions</h2>

<p class="first">Procedures and functions are the standard means for expressing a collection of computations in a single entity.  Examples range from numeric computations to commands involving the operating system.  For example, we have already seen a number of numeric operations expressed by the common infix notation.</p>

<p>WARNING: curly braces {...} must surround a function or a procedure call.  This syntax for procedure/function application is rather unusual when compared with other programming languages, but it is also unambiguous.</p>

<p>In Oz, procedures are the fundamental concept.  Functions are just a syntactic variant of procedures, added for convenience.  The main difference between functions and procedures is that functions are procedures which always returns exactly one value.  Procedures do not necessarily return anything.</p>

<p>More specifically, a function is a procedure whose last argument &mdash; the return value &mdash; is expressed implicitly.  Every function may be called like a procedure by adding this return value explicitly.  In addition, any procedure can also be called as a function which returns its omitted last argument.</p>


<h3><a name="sec30" id="sec30"></a>
Usage</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Procedure `Browse' is called with the result of function `IsEven'.
`IsEven' expects one integer as an argument, and returns true or false.
`Browse' expects one argument (any variable type), and returns nothing.
*/</span>

{Browse
 {IsEven 3}
}
</pre>


<h3><a name="sec31" id="sec31"></a>
Defining Max: procedure</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The procedure Max gets two numbers as its first two arguments and
binds its last argument to the greater number.

</span><span style="color: #ff0000; font-weight: bold;">WARNING:</span><span style="color: #b22222;"> the variable X in the Max definition and the variable X
outside are different variables (cf.  variable scope above).
*/</span>

<span style="color: #a020f0;">local</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">procedure definition
</span>  <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y Z}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> Z = X <span style="color: #a020f0;">else</span> Z = Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
  X
<span style="color: #a020f0;">in</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">procedure application
</span>  {Max 4 3 X}
  {Browse X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec32" id="sec32"></a>
Defining Max: function</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">As mentioned above, a function in Oz is a procedure which returns
its last value.  Functions are just "syntactic sugar", added for
programming convenience.

This Max function is equivalent to the Max procedure of the previous example.
*/</span>

<span style="color: #a020f0;">local</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">function definition
</span>  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> X <span style="color: #a020f0;">else</span> Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
  X
<span style="color: #a020f0;">in</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">function application
</span>  X = {Max 4 3}
  {Browse X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec33" id="sec33"></a>
Functions are procedures</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Since functions are procedures, we can treat them just like procedures.
</span><span style="color: #a020f0;">local</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">function definition
</span>  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> X <span style="color: #a020f0;">else</span> Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
  X
<span style="color: #a020f0;">in</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">function application like a procedure
</span>  {Max 4 3 X}
  {Browse X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec34" id="sec34"></a>
Procedures as functions</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Remember, every procedure can also be called like a function for convenience.
</span>
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y Z}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> Z = X <span style="color: #a020f0;">else</span> Z = Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Browse {Max 4 3}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec35" id="sec35"></a>
Another example TODO</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Here we treat `IsEven' as a procedure with two arguments.
`IsEven' binds the variable B.  Please note the order of computations in this
example:
  1.  B is browsed.
  2.  IsEven binds B to false.

However, `Browse' does indeed show the correct value of B.

This demonstrates a vital feature of Oz: variables are be used to
communicate information between different parts of a program -- even
if the information is not available yet.  Browse can handle unknown
information, but other parts of the program may wait (i.e. block)
until the information is available.
*/</span>

<span style="color: #a020f0;">local</span> B <span style="color: #a020f0;">in</span>
   {Browse B}
   {IsEven 4 B}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec36" id="sec36"></a>
$ marks a return value</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Every procedure argument can be a return value.  The $ (dollar sign)
always marks a return value.  This example is not yet very convincing,
but procedures will encapsulate constraints in later examples...
</span><span style="color: #ff0000; font-weight: bold;">TODO:</span><span style="color: #b22222;">  what's happening here?  -gp
</span><span style="color: #ff0000; font-weight: bold;">TODO:</span><span style="color: #b22222;"> I think this belongs somewhere in Basics-2, or even in the
CSP stuff.
*/</span>

<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y Z}
      <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> Z = X <span style="color: #a020f0;">else</span> Z = Y <span style="color: #a020f0;">end</span>
   <span style="color: #a020f0;">end</span>
   X = 4
   Result
<span style="color: #a020f0;">in</span>
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">Note the $
</span>   X = {Max $ 3 Result}
   {Browse Result}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec37" id="sec37"></a>
Recursion</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Procedures and functions can call themselves (recursion).  The
function Factorial implements the mathematical factorial concept. */</span>

<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Factorial</span> N}
      <span style="color: #a020f0;">if</span> (N<span style="color: #a020f0;">==</span>0) <span style="color: #a020f0;">then</span>
        1
      <span style="color: #a020f0;">else</span>
        N <span style="color: #a020f0;">*</span> {Factorial N<span style="color: #a020f0;">-</span>1}
      <span style="color: #a020f0;">end</span>
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">10! = 3628800
</span>   {Browse
    {Factorial 10}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec38" id="sec38"></a>
BACKGROUND</h3>

<pre class="src">
<span style="color: #b22222;">/*</span><span style="color: #b22222;">
Terms: procedure, function.

Procedures and functions are the standard means for expressing a
collection of computations in a single entity.  Examples range
from numeric computations to commands involving the operating
system.  For example, we have already seen a number of numeric
operations expressed by the common infix notation.

A procedure definition wraps up (abstracts) some computation: a
complex computation can then be executed simply by calling the
procedure.
*/</span>

</pre>



<h2><a name="sec39" id="sec39"></a>
Atoms and Names</h2>

<p class="first">Oz provides a number of basic data types which have a specific textual representation in source code.  We have already seen numbers (i.e. integers and floats).  Here we shall discuss two other data types: Atoms and Names.</p>

<p>Atom:
The safest way to create an atom is to surround it in single quotes: 'hi there'..  Atoms may also be written as text (without spaces) as long as they do not start with a capital letter (those are variables) and the text is not an Oz keyword.  For simplicity, we recommend using 'single quotes'.  ;)</p>

<p>Name:
There are a few things which look like atoms, but are a different variable type: Name.  The boolean values true and false are both Names (specifically, the Bool subtype).  Another often used value which looks like an atom is unit (also a name).</p>

<h3><a name="sec40" id="sec40"></a>
Atoms</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Several atoms are inspected below. (Remember that the inspector window
</span><span style="color: #b22222;">%% </span><span style="color: #b22222;">might open behind the tutorial!)
</span>
{Inspect <span style="color: #bc8f8f;">'I am an atom'</span>}
{Inspect iAmAnAtom}
{Inspect test}
{Inspect nil}
<span style="color: #b22222;">%% </span><span style="color: #b22222;">if is an Oz keyword, but 'if' is an atom
</span>{Inspect <span style="color: #bc8f8f;">'if'</span>}
{Inspect <span style="color: #bc8f8f;">'=='</span>}
</pre>


<h3><a name="sec41" id="sec41"></a>
Equality</h3>

<pre class="src">
{Inspect test <span style="color: #a020f0;">==</span> <span style="color: #bc8f8f;">'test'</span>}
</pre>


<h3><a name="sec42" id="sec42"></a>
Names</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The values `true', `false' and `unit' are values which are similar
to atoms, but which play a special role (note that the quotes don't
belong to the values here). Obviously, `true' and `false' are the
common boolean values. Oz provides the value `unit' for the computer
science concept of the unit type (a value which is intended to express
no further information). For example, `unit' is often used wherever a
token is needed whose value is not important. */</span>

{Inspect <span style="color: #a020f0;">true</span>}
{Inspect <span style="color: #a020f0;">false</span>}
{Inspect <span style="color: #a020f0;">unit</span>}

<span style="color: #b22222;">%% </span><span style="color: #b22222;">The Inspector shows atoms and names in different colors
</span>{Inspect <span style="color: #bc8f8f;">'I am an atom'</span>}
</pre>



<h2><a name="sec43" id="sec43"></a>
Compound Types</h2>

<p class="first">Besides the atomic types discussed before, Oz also provides compound data types: records, tuples, lists, and strings.</p>

<p>Internally, all of these data types are actually records (just like all functions are actually procedures).  Tuples, lists, and strings just provide a different syntax for interacting with records.</p>

<h3><a name="sec44" id="sec44"></a>
Records (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A record has a label and consists of feature-value pairs.
</span>
{Inspect label(feature1:value1 feature2:value2)}
</pre>


<h3><a name="sec45" id="sec45"></a>
Records (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Integer features need not be listed explicitly; these two
 examples are identical.  Note that the `foo' label does not count
towards these integer features, and that the integer features are
placed before non-integer features. */</span>

{Inspect test(1:one 2:two foo:bar 3:three)}
{Inspect test(one two foo:bar three)}
</pre>


<h3><a name="sec46" id="sec46"></a>
Records (3)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Records can be freely nested.
</span>
{Inspect test(1:hi 2:there x:<span style="color: #a020f0;">unit</span>(foo:bar))}
</pre>


<h3><a name="sec47" id="sec47"></a>
Accessing record fields</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Record fields are accessed with the dot operator.  R.X returns the
value stored at feature X in record R.  Records support constant-time
access (i.e. the time the access takes is independent of the feature
position). */</span>

{Inspect test(x:hi y:there)<span style="color: #a020f0;">.</span>x}
</pre>


<h3><a name="sec48" id="sec48"></a>
Tuples (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A tuple consists of a label and values.
</span>
{Inspect label(value1 value2 value3)}
</pre>


<h3><a name="sec49" id="sec49"></a>
Tuples (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Actually, a tuple is a record which has only integer features in
ascending order.  These features can be omitted.  The two records below
are equivalent. */</span>

{Inspect <span style="color: #a020f0;">unit</span>(1:a 2:b 3:c) <span style="color: #a020f0;">==</span> <span style="color: #a020f0;">unit</span>(a b c)}
</pre>


<h3><a name="sec50" id="sec50"></a>
Tuples (3)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">An atom is an "empty" tuple.
</span>
{Inspect test() <span style="color: #a020f0;">==</span> test}
</pre>


<h3><a name="sec51" id="sec51"></a>
Lists (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A list is a sequence of values.
</span>
{Browse [value1 value2 value3]}
</pre>


<h3><a name="sec52" id="sec52"></a>
Lists (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A list can also be written using | (cf. cons in Lisp). nil is the
empty list, which terminates every list. */</span>

{Inspect a<span style="color: #a020f0;">|</span>b<span style="color: #a020f0;">|</span>c<span style="color: #a020f0;">|</span>nil}
</pre>


<h3><a name="sec53" id="sec53"></a>
Lists (3)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Actually, a list is a nested tuple with the labels '|'.
</span>
{Inspect [a b c] <span style="color: #a020f0;">==</span> <span style="color: #bc8f8f;">'|'</span>(a <span style="color: #bc8f8f;">'|'</span>(b <span style="color: #bc8f8f;">'|'</span>(c nil)))}
</pre>


<h3><a name="sec54" id="sec54"></a>
Lists (4)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Consequently, the first element of a list can be accessed under the
feature 1, and the remaining list under the feature 2. */</span>

{Inspect [a b c]<span style="color: #a020f0;">.</span>1}
{Inspect [a b c]<span style="color: #a020f0;">.</span>2}
</pre>


<h3><a name="sec55" id="sec55"></a>
Pairs (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A pair is a convenient way of concatenating values.
</span>
{Inspect value1 <span style="color: #a020f0;">#</span> value2 <span style="color: #a020f0;">#</span> value3}
</pre>


<h3><a name="sec56" id="sec56"></a>
Pairs (2)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Actually, a pair is a tuple with the label '#'.
</span>
{Inspect a<span style="color: #a020f0;">#</span>b<span style="color: #a020f0;">#</span>c  <span style="color: #a020f0;">==</span> <span style="color: #bc8f8f;">'#'</span>(a b c)}
</pre>


<h3><a name="sec57" id="sec57"></a>
Strings (1)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A string is a list of integers denoting characters (i.e. all list
procedures can be used for strings). */</span>

{Inspect <span style="color: #bc8f8f;">"test"</span> <span style="color: #a020f0;">==</span> [116 101 115 116]}
</pre>


<h3><a name="sec58" id="sec58"></a>
Strings (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Although a string is just a list of integers, you can show strings
as text in the Browser and the Inspector.  However, you need to
configure them for showing strings first.  In the Inspector Preference
settings (Options menu), select the tab Appearance and tick "Show
Strings".  You need to do these settings before you inspect a
string. */</span>

{Inspect <span style="color: #bc8f8f;">"This is a string!"</span>}
</pre>


<h3><a name="sec59" id="sec59"></a>
Virtual Strings</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A virtual string (VS) is a (possibly nested) concatenation of
strings, atoms, and numbers.  Many procedures expecting strings as
arguments can also handle virtual strings for convenience. */</span>

<span style="color: #a020f0;">local</span>
  VS = <span style="color: #bc8f8f;">'my test '</span>
<span style="color: #a020f0;">in</span>
  {Inspect VS<span style="color: #a020f0;">#</span>3}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec60" id="sec60"></a>
Error messages</h2>

<p class="first">When we do program, we almost inevitably write bugs
sometimes.  Luckily, when confronted with specific problems in
programs, compilers try to tell us about the problem (naturally, the
real hard bugs are the ones no compiler complains about).  All errors
are actually raised exceptions (see the Tutorial of Oz, Sec. 5.10 for
more details).</p>

<p>The compiler is your friend, so this example introduces you to some
typical Oz error messages ;-) During your programming sessions,
carefully reading error messages can save you much time.  In this
tutorial, all these messages are shown at the shell (or in the DOS
box) where you started the tutorial.  The Oz Programming Interface
(OPI) even supports moving to the code where the bug is likely to be
located (see the Tutorial of Oz, Sec. 2.3.3).</p>

<p>BTW: the error messages of this tutorial are slightly obscured
unfortunately by some trick which keeps the tutorial application
running even in the case of an error: there are always a few lines of
other code before the actual error message.  Also, the reported line
number is not correct, because the tutorial application adds a few
lines to each example (the resulting full example is shown just before
the error message).</p>


<h3><a name="sec61" id="sec61"></a>
Parse error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">The left curly brace does not match the right parenthesis
</span>
{Browse hello)
</pre>


<h3><a name="sec62" id="sec62"></a>
Static analysis error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Browse expects only a single argument
</span>
{Browse hi there}
</pre>


<h3><a name="sec63" id="sec63"></a>
Binding analysis error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Variable X is not declared
</span>
X = 3
</pre>


<h3><a name="sec64" id="sec64"></a>
Type error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">We can not add an integer and a float
</span>
{Browse 3 <span style="color: #a020f0;">+</span> 2<span style="color: #a020f0;">.</span>0}
</pre>


<h3><a name="sec65" id="sec65"></a>
Failure</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Inconsistent constraint programs result in a failure.  Failures play
an important role internally in a constraint solver searching for
solutions to a constraint satisfaction problem. */</span>

<span style="color: #a020f0;">local</span>
   X = 3
<span style="color: #a020f0;">in</span>
   3 <span style="color: #a020f0;">+</span> 4 <span style="color: #a020f0;">=:</span> X
<span style="color: #a020f0;">end</span>
</pre>




<!-- Page published by Emacs Muse ends here -->
<!-- Footer -->
<div id="footer">
<div id="author">&copy; 
Torsten Anders</div>
<div id="date">Last time edited: 2008.01.18</div>
</div>
  </body>
</html>
