<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>More Oz Basics</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
<div id="header">
  <ul class="nav">
    <li class="nav1"><a href="index.html">home</a></li>
    <li class="navn"><a href="https://sourceforge.net/projects/strasheela/">download at sourceforge</a></li>
    <!-- <li class="navn"><a href="IndexOfPages.html">site map</a></li> -->
    <li class="navn"><a href="contact.html">contact</a></li>
  </ul>
  <div id="logo">
    <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=167225&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </div>
</div>
    <h1>More Oz Basics</h1>
    <!-- Page published by Emacs Muse begins here -->
<div class="contents">
<dl>
<dt>
<a href="#sec1">About this document</a>
</dt>
<dt>
<a href="#sec2">&mdash; More Oz Basics</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec3">Introduction</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec4">Pattern Matching</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec5">Introduction</a>
</dt>
<dt>
<a href="#sec6">Case (head and tail)</a>
</dt>
<dt>
<a href="#sec7">Case (every element)</a>
</dt>
<dt>
<a href="#sec8">Multiple case clauses</a>
</dt>
<dt>
<a href="#sec9">Implicit pattern matching</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec10">Procedures over Compounds</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec11">Introduction</a>
</dt>
<dt>
<a href="#sec12">Record HasFeature</a>
</dt>
<dt>
<a href="#sec13">Record -&gt; List</a>
</dt>
<dt>
<a href="#sec14">Combining records</a>
</dt>
<dt>
<a href="#sec15">Accessing a list element</a>
</dt>
<dt>
<a href="#sec16">Reverse list</a>
</dt>
<dt>
<a href="#sec17">Append lists</a>
</dt>
<dt>
<a href="#sec18">User-defined procedures</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec19">Higher-Order Programming</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec20">Introduction</a>
</dt>
<dt>
<a href="#sec21">Filter</a>
</dt>
<dt>
<a href="#sec22">ForAll</a>
</dt>
<dt>
<a href="#sec23">Map</a>
</dt>
<dt>
<a href="#sec24">Anonymous procedures</a>
</dt>
<dt>
<a href="#sec25">Sort (simple)</a>
</dt>
<dt>
<a href="#sec26">Sort (advanced)</a>
</dt>
<dt>
<a href="#sec27">Defining higher-order procedures</a>
</dt>
<dt>
<a href="#sec28">BACKGROUND</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec29">Unification</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec30">Introduction</a>
</dt>
<dt>
<a href="#sec31">Unifying two numbers</a>
</dt>
<dt>
<a href="#sec32">Unifying two lists</a>
</dt>
<dt>
<a href="#sec33">Recursive unification</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec34">Class Method Application</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec35">Introduction</a>
</dt>
<dt>
<a href="#sec36">Method call</a>
</dt>
<dt>
<a href="#sec37">Method arguments</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec38">Concurrency</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec39">Introduction</a>
</dt>
<dt>
<a href="#sec40">Another section TODO</a>
</dt>
<dt>
<a href="#sec41">Declarative concurrency</a>
</dt>
<dt>
<a href="#sec42">Blocking computation</a>
</dt>
<dt>
<a href="#sec43">'Signalling' a blocking computation</a>
</dt>
<dt>
<a href="#sec44">'Signalling' a blocking computation (2)</a>
</dt>
</dl>
</dd>
</dl>
</div>


<h2><a name="sec1" id="sec1"></a>
About this document</h2>

<p class="first">This file was automatically generated from the interactive Strasheela tutorial. Some aspects of the text only make sense in the original interactive tutorial application (e.g., buttons indicated to press, and positions specified on the screen), and not in this version of the text.</p>


<h2><a name="sec2" id="sec2"></a>
&mdash; More Oz Basics</h2>

<h3><a name="sec3" id="sec3"></a>
Introduction</h3>

<p class="first">This chapter covers more basic info about Oz.  However, despite still beging &quot;basic&quot; information, it requires a solid understanding of material in the previous chapter.</p>




<h2><a name="sec4" id="sec4"></a>
Pattern Matching</h2>

<h3><a name="sec5" id="sec5"></a>
Introduction</h3>

<p class="first">Pattern matching is a convenient way to access the elements contained in compund data types (i.e. records, lists, etc).  Pattern matching decomposes such compund data, declares new variables, and binds these variables to parts of the compound data.</p>

<p>The primary pattern matching construct is the case statement, but some programming constructs (such as functions) allow pattern matching via an implicit case statement.</p>




<h3><a name="sec6" id="sec6"></a>
Case (head and tail)</h3>

<p class="first">In the section below, `case' declares the two variables H and T and binds them to the head and tail of the list Xs.  Finally, the H and T are inspected.  Please note that the pattern-matching expression H|T is written with the usual list syntax using the cons-operation (|).</p>

<p>This approach can be used to pattern match lists of arbitrary length, except empty lists (i.e. nil).  Try changing the definition of Xs to a list of a different length and watch how the value of T changes.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span>
      H <span style="color: #a020f0;">|</span> T
   <span style="color: #a020f0;">then</span>
      {Inspect H}
      {Inspect T}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec7" id="sec7"></a>
Case (every element)</h3>

<p class="first">The previous section matched the head and the tail of a list.  Instead, we can also match individual list elements (or the elements of other data structures, such as records or tuples).</p>

<p>WARNING: if the length of the lists is not equal, an error occurs.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span>
      [A B C D]
   <span style="color: #a020f0;">then</span>
      {Inspect A}
      {Inspect B}
      {Inspect C}
      {Inspect D}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec8" id="sec8"></a>
Multiple case clauses</h3>

<p class="first">Having only a single clause to match against (as in the previous sections), can be too restrictive.  This section presents a typical `case' expression.  It matches a list, which checks whether Xs is either a non-empty list, an empty list, or some other value.  You may want to play around with the value of Xs to try out these different clauses.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span>
      H<span style="color: #a020f0;">|</span>T
   <span style="color: #a020f0;">then</span>
      {Inspect nonEmptyList}
   <span style="color: #a020f0;">[]</span> nil <span style="color: #a020f0;">then</span>
      {Inspect emptyList}
   <span style="color: #a020f0;">else</span>
      {Inspect notList}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec9" id="sec9"></a>
Implicit pattern matching</h3>

<p class="first">The following function GetFeature2 expects a record as argument; this record must match recordType(feature2:_ ...).  The variable MyVar is implicitly declared and bound to the value at the feature 'feature2' of the record given as argument to the function.</p>

<p>Please note that the record in the header of the function GetFeature2 is not even complete but contains three dots (...) to indicate that further record features are possible.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   MyRec = recordType(feature1:value1 feature2:value2)
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">GetFeature2</span> recordType(feature2:MyVar <span style="color: #a020f0;">...</span>)}
      MyVar
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">show the normal record
</span>   {Inspect MyRec}
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">show the feature we want
</span>   {Inspect {GetFeature2 MyRec}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec10" id="sec10"></a>
Procedures over Compounds</h2>

<h3><a name="sec11" id="sec11"></a>
Introduction</h3>

<p class="first">Oz provides a rich set of procedures for processing these compound data such as lists and records.  A few sections are shown here.  More procedures are listed in the reference documentation at</p>

<blockquote>
<p class="quoted"><a href="http://www.mozart-oz.org/documentation/base/index.html">http://www.mozart-oz.org/documentation/base/index.html</a></p>
</blockquote>




<h3><a name="sec12" id="sec12"></a>
Record HasFeature</h3>

<p class="first">Tests whether a record has a certain feature.</p>

<pre class="src">
{Inspect {HasFeature <span style="color: #a020f0;">unit</span>(x:1 y:2 z:3) y}}
</pre>


<h3><a name="sec13" id="sec13"></a>
Record -&amp;gt; List</h3>

<p class="first">Return the features of a record as a list.</p>

<pre class="src">
{Inspect {Arity <span style="color: #a020f0;">unit</span>(a b x:1 y:2 z:3)}}
</pre>


<h3><a name="sec14" id="sec14"></a>
Combining records</h3>

<p class="first">&quot;Merge&quot; two records.  Note that features and labels of the second record take precedence over the first.</p>

<pre class="src">
{Inspect {Adjoin <span style="color: #a020f0;">unit</span>(x:1 y:2 z:3) test(foo:hi bar:there z:<span style="color: #bc8f8f;">'overwrite!'</span>)}}
</pre>


<h3><a name="sec15" id="sec15"></a>
Accessing a list element</h3>

<p class="first">Return the nth element of a list.  Note that the list is 1-indexed.</p>

<pre class="src">
{Inspect {Nth [a b c d] 2}}
</pre>


<h3><a name="sec16" id="sec16"></a>
Reverse list</h3>

<p class="first">Reverse a list.</p>

<pre class="src">
{Inspect {Reverse [a b c d]}}
</pre>


<h3><a name="sec17" id="sec17"></a>
Append lists</h3>

<p class="first">Append two lists.</p>

<pre class="src">
{Inspect {Append [a b] [x y]}}
</pre>


<h3><a name="sec18" id="sec18"></a>
User-defined procedures</h3>

<p class="first">You can define procedures over lists and records as easily as numeric procedures.  Following is the definition of the function Append.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Append</span> Xs Ys}
    <span style="color: #a020f0;">if</span> Xs <span style="color: #a020f0;">==</span> nil <span style="color: #a020f0;">then</span> Ys
    <span style="color: #a020f0;">else</span> Xs<span style="color: #a020f0;">.</span>1 <span style="color: #a020f0;">|</span> {Append Xs<span style="color: #a020f0;">.</span>2 Ys}
    <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Inspect {Append [a b] [x y]}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec19" id="sec19"></a>
Higher-Order Programming</h2>

<h3><a name="sec20" id="sec20"></a>
Introduction</h3>

<p class="first">Oz procedures (and functions) are first-class values.  This means that a procedure can be processed like any other value.  For example, procedures can be given to other procedures as arguments.</p>

<p>This leads to highly flexible programming technique called higher-order programming.  Procedures expecting procedures as arguments are called higher-order procedures.  This concept is demonstrated be several sections.</p>




<h3><a name="sec21" id="sec21"></a>
Filter</h3>

<p class="first">The function Filter expects a list and a test function, and returns only those elements for which the test function returns true.</p>

<p>The function IsEven returns true for even integers and thus a list with only the even integers in [~3 ~2 ~1 0 1 2 3] is returned.  Try replaying IsEven by IsOdd, IsNumber or IsNat (testing for natural numbers) to better understand this filtering.</p>

<p>(BTW: there is a bug in IsOdd concerning negative numbers)</p>


<pre class="src">
{Browse {Filter [<span style="color: #a020f0;">~</span> 4 <span style="color: #a020f0;">~</span>3 <span style="color: #a020f0;">~</span>2 <span style="color: #a020f0;">~</span>1 0 1 2 3] IsEven}}
</pre>


<h3><a name="sec22" id="sec22"></a>
ForAll</h3>

<p class="first">The procedure ForAll applies a given procedure to any element of a list.  In this section, the procedure Browse is applied to every list element.</p>

<pre class="src">
{ForAll [a b c d e f] Browse}
</pre>


<h3><a name="sec23" id="sec23"></a>
Map</h3>

<p class="first">The function Map expects a list and a unary function (i.e. a function expecting a single value) as arguments.  It applies the function to every list element, and returns the collected results in a list.</p>

<p>The section defines and uses the function square in order to square all numbers in the list.  You may want to change this function to understand that any function can be given to a higher-order function as an argument.  For example, replace Square by a function Double, which doubles its argument.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Square</span> X} X <span style="color: #a020f0;">*</span> X <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Browse {Map [1 2 3 4 5 6] Square}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec24" id="sec24"></a>
Anonymous procedures</h3>

<p class="first">Sometimes we need a function only once &mdash; as the function Square in the previous section.  In such cases we don't necessarily need to care about giving the function any name.  Instead, we can define an anonymous function.</p>

<p>This section restates the previous section by defining the Square function 'inline' without giving it any name.  Please recall that $ always denotes a return value.  In this case, $ returns the function value itself.</p>


<pre class="src">
{Browse
 {Map [1 2 3 4 5 6] <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X} X <span style="color: #a020f0;">*</span> X <span style="color: #a020f0;">end</span>}}
</pre>


<h3><a name="sec25" id="sec25"></a>
Sort (simple)</h3>

<p class="first">The function Sort expects a list and a binary function (i.e. a function expecting two values) as arguments.  This binary function compares two values, and Sort sorts the list values according to this comparison.  For example, the function in the section compares two numbers and returns true if the first number is smaller.  Consequently, this section sorts the list elements in ascending order.  You may want to replace the &lt; by &gt; in the function definition to sort the numbers in decreasing order.</p>


<pre class="src">
{Browse
 {Sort
  [1 5 3 2 0 7]
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X Y}
    X <span style="color: #a020f0;">&lt;</span> Y
  <span style="color: #a020f0;">end</span>
 }}
</pre>


<h3><a name="sec26" id="sec26"></a>
Sort (advanced)</h3>

<p class="first">You can actually sort the list elements in any way you want using the Sort function.  For example, you may place all even numbers at the beginning and all odd numbers at the end of the list and sort all even and odd numbers in ascending order.  This is done in the second (commented) Sort call.  How does this sorting work?</p>


<pre class="src">
{Browse
 {Sort
  [1 5 3 2 0 7]
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X Y}
    <span style="color: #a020f0;">if</span> {IsEven X} <span style="color: #a020f0;">then</span>
      <span style="color: #a020f0;">if</span> {IsEven Y} <span style="color: #a020f0;">then</span>
        X <span style="color: #a020f0;">&lt;</span> Y
      <span style="color: #a020f0;">else</span>
        <span style="color: #a020f0;">true</span>
      <span style="color: #a020f0;">end</span>
    <span style="color: #a020f0;">else</span>
      <span style="color: #a020f0;">if</span> {IsOdd Y} <span style="color: #a020f0;">then</span>
        X <span style="color: #a020f0;">&lt;</span> Y
      <span style="color: #a020f0;">else</span>
        <span style="color: #a020f0;">false</span>
      <span style="color: #a020f0;">end</span>
    <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
 }}
</pre>


<h3><a name="sec27" id="sec27"></a>
Defining higher-order procedures</h3>

<p class="first">Higher order procedures are defined like any other procedure: some arguments are simply procedures &mdash; which are then usually applied in the definition.  This section defines a higher-order function Find which expects a list Xs and a test function Fn: Find returns the first element in Xs for which Fn returns true.</p>

<p>This section also demonstrates the pattern-matching case statement with multiple clauses operating on the list Xs.  In case Xs is the empty list nil, then Find returns nil.  Otherwise (multiple clauses are separated with the keyword []), Xs is matched with X|Xr, where X is bound to the first element of Xs and Xr to the list's tail or rest.  The function Find then checks whether {Fn X} returns true.  In that case, the searched for list element has been found and is returned.  Otherwise, Find is called recursively with the rest of the list.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Find</span> Xs Fn}
      <span style="color: #a020f0;">case</span> Xs
      <span style="color: #a020f0;">of</span> nil <span style="color: #a020f0;">then</span> nil
      <span style="color: #a020f0;">[]</span> X<span style="color: #a020f0;">|</span>Xr
      <span style="color: #a020f0;">then</span> <span style="color: #a020f0;">if</span> {Fn X} <span style="color: #a020f0;">then</span> X
           <span style="color: #a020f0;">else</span> {Find Xr Fn}
           <span style="color: #a020f0;">end</span>
      <span style="color: #a020f0;">end</span>
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   {Browse {Find [1 2 3 4 5 6] IsEven}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec28" id="sec28"></a>
BACKGROUND</h3>

<p class="first">TODO: Torsten, please add info about &quot;first-class values&quot; here.  :)</p>




<h2><a name="sec29" id="sec29"></a>
Unification</h2>

<h3><a name="sec30" id="sec30"></a>
Introduction</h3>

<p class="first">The operator = performs unification of two variables.  The variables share all the information they have about their values.  A variable without a name (an anonymous variable) is written as an underscore ( _ ).  Unification is a basic form of constraint programming (constraint programming is discussed further below).</p>




<h3><a name="sec31" id="sec31"></a>
Unifying two numbers</h3>

<p class="first">TODO: add something</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X = {FD<span style="color: #a020f0;">.</span>int 1<span style="color: #a020f0;">#</span>5}
  Y = {FD<span style="color: #a020f0;">.</span>int 0<span style="color: #a020f0;">#</span>3}
<span style="color: #a020f0;">in</span>
  X = Y          <span style="color: #b22222;">% </span><span style="color: #b22222;">unify X and Y
</span>  {Inspect X}
<span style="color: #a020f0;">end</span>

</pre>


<h3><a name="sec32" id="sec32"></a>
Unifying two lists</h3>

<p class="first">TODO: add something</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X = [a _ _]
  Y = [_ b _]
<span style="color: #a020f0;">in</span>
  X = Y          <span style="color: #b22222;">% </span><span style="color: #b22222;">unify X and Y
</span>  {Inspect X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec33" id="sec33"></a>
Recursive unification</h3>

<p class="first">Unification also works recursively.  The Inspector and the Browser show two different ways for representing that (the Inspector can be configured to show either way: options menu, structure tab, under representation, select between tree and relation mode).</p>

<pre class="src">
<span style="color: #a020f0;">local</span> X = <span style="color: #a020f0;">unit</span>(x:X) <span style="color: #a020f0;">in</span>
  {Browse X}
  {Inspect X}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec34" id="sec34"></a>
Class Method Application</h2>

<h3><a name="sec35" id="sec35"></a>
Introduction</h3>

<p class="first">Oz supports object-oriented programming.  This programming paradigm introduces the notion of objects which instantiate classes.  An object (or class instance) is a datum which encapsulates its internal structure.  A class specifies what data are contained in its instances and what methods these instances understands.  A method (or message) is effectively a procedure which is defined for instances of specific classes only.</p>

<p>For more details on object-oriented programming in general, please refer to other Oz documentation:
<blockquote>
<p class="quoted"><a href="http://www.mozart-oz.org/documentation/tutorial/node10.html">http://www.mozart-oz.org/documentation/tutorial/node10.html</a></p>
</blockquote>

<p>Internally, objects are actually procedures which expect a single argument &mdash; hence this syntax.  When the object is sent a message (i.e. the procedure is called with a specific argument) it processes the message according to its definition.  This method definition may change its internal state, as we expect from typical objects.</p>




<h3><a name="sec36" id="sec36"></a>
Method call</h3>

<p class="first">The following section creates a graphical user interface button.  You do not need to understand the code which creates the window itself (i.e., the call to QTk.build).  For our purposes here, only this single line is important:</p>

<blockquote>
<p class="quoted">{Window show}</p>
</blockquote>

<p>`Window' is an object, and `show' is the name of the method understood by this object.  This method results in showing the window with the button.</p>

<p>Please note that the syntax of a method differs clearly from the procedure syntax shown before.  If `show' was a procedure, then we would write:</p>

<blockquote>
<p class="quoted">{Show Window}</p>
</blockquote>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Window = {QTk<span style="color: #a020f0;">.</span>build lr(button(text:<span style="color: #bc8f8f;">"Hello world!"</span>
                                 action:toplevel<span style="color: #a020f0;">#</span>close))}
<span style="color: #a020f0;">in</span>
   {Window show}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec37" id="sec37"></a>
Method arguments</h3>

<p class="first">Class methods are actually records which can contain method arguments.  For example, the following statement sends the following message to the object Window.  This changes the width of the border around the button and sets the background of this border to the color blue.</p>

<blockquote>
<p class="quoted">{Window set(borderwidth:1.0#c background:blue)}</p>
</blockquote>

<p>In general, the record denoting a message can wrap multiple arguments, as in the following section where the method myMethod with two arguments is send to the class MyObject.</p>

<blockquote>
<p class="quoted">{MyObject myMethod(Arg1 Arg2 ..)}</p>
</blockquote>

<p>We will later see many more method application sections in the context of Strasheela's music representation.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Window = {QTk<span style="color: #a020f0;">.</span>build lr(button(text:<span style="color: #bc8f8f;">"Hello world!"</span>
                                 action:toplevel<span style="color: #a020f0;">#</span>close))}
<span style="color: #a020f0;">in</span>
   {Window show}
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">change to button background color after 1000 msecs
</span>   {Delay 1000}
   {Window set(borderwidth:1<span style="color: #a020f0;">.</span>0<span style="color: #a020f0;">#</span>c
               background:blue)}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec38" id="sec38"></a>
Concurrency</h2>

<h3><a name="sec39" id="sec39"></a>
Introduction</h3>

<p class="first">Oz provides excellent support for concurrent programming, where computations run in parallel in multiple threads.  We will only touch on this subject and discuss aspects relevant for Strasheela.  In general, however, concurrent programming plays a major role in Oz programming.</p>

<p>The computations in different threads can communicate with each other via variables.  Multiple threads can use the same variable in a computation.  If the value of a variable does not present enough information for performing a specific operation, then the thread simply blocks and waits for more information.  In the section below, the addition X+3 can not be performed as long as the value of X is unknown.  As soon as more information about the variable value is available, the thread resumes its execution.</p>

<p>This behaviour leads to a concurrent programming model which is highly declarative &mdash; and thus easy to program in.  We will later see how this model simplifies the definition of complex musical constraint satisfaction problems (Oz' constraint programming model is based on concurrent programming).</p>

<p>The downside of this concurrency model is that it can result in an unintended blocking of a program which is not explicitly signalled (e.g. no error message is shown when a program blocks, because this is a normal program behaviour).  The second and third section below demonstrate a pragmatic way to deal with this downside.</p>

<p>The sections demonstrates concurrent programming, but do not show a typical application (a typical application would be a program split in a server and one or more clients).  In the context of Strasheela, we will seldomly write concurrent programs explicitly.  Nevertheless, it is very important to know how concurrent programming works in Oz.  Even if we are not explicitly writing a concurrent program, constraint programming in Oz always results in a concurrent program.  Concurrent programming forms one of the foundations of Oz' constraint programming model, where each constraint (i.e. each propagator) is a concurrent agent running in its own thread.</p>




<h3><a name="sec40" id="sec40"></a>
Another section TODO</h3>

<p class="first">Here we treat `IsEven' as a procedure with two arguments.  `IsEven' binds the variable B.  Please note the order of computations in this section:</p>

<ol>
<li>B is browsed.</li>
<li>IsEven binds B to false.</li>
</ol>

<p>However, `Browse' does indeed show the correct value of B.</p>

<p>This demonstrates a vital feature of Oz: variables are be used to communicate information between different parts of a program &mdash; even if the information is not available yet.  Browse can handle unknown information, but other parts of the program may wait (i.e. block) until the information is available.</p>


<pre class="src">
<span style="color: #a020f0;">local</span> B <span style="color: #a020f0;">in</span>
   {Browse B}
   {IsEven 4 B}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec41" id="sec41"></a>
Declarative concurrency</h3>

<p class="first">This section declares X and then browses 'hello' (just to show that the browser works in principle).  However, the addition X+3 can not be executed immediately and blocks.  Because this computation is executed in its own thread, the top-level thread continues regardless, and calls the procedure Delay, which waits for 3000 msecs.  After that time, the top-level thread determines X to 4.  This awakes the other thread: it can now compute X+3 and browse the sum.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #a020f0;">thread</span> {Browse X <span style="color: #a020f0;">+</span> 3} <span style="color: #a020f0;">end</span>
  {Delay 3000}
  X = 4
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec42" id="sec42"></a>
Blocking computation</h3>

<p class="first">This section demonstrates a buggy program which does not signal any error but simply does nothing.  The section is very similar to the previous section, but does not place the blocking X+3 in its own thread.  As a result, the whole program blocks at that point and never executes X = 4.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec43" id="sec43"></a>
'Signalling' a blocking computation</h3>

<p class="first">This section demonstrates a pragmatic approach which checks for blocking programs.  The section ends with the statement {Browse endOfProgram}.  A non-blocking program will always execute this last line of code and show 'endOfProgram' in the Browser.  However, a blocking program (as the present one) does not do that and thus indicates that it is blocking.  Although this little trick does not tell us <em>where</em> the program blocks, the information <em>that</em> we wrote a blocking program can prove very helpful already.  You may get a feel for this trick by changing the section so that the message 'endOfProgram' is shown (e.g. comment the blocking statement out, or surrounding it with a 'thread .. end' statement).</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>
{Browse endOfProgram}
</pre>


<h3><a name="sec44" id="sec44"></a>
'Signalling' a blocking computation (2)</h3>

<p class="first">This section demonstrates a technique which causes an error (raises an exception) when the current thread blocks. The function `Thread.this' returns the current thread, and `Debug.setRaiseOnBlock' activates this debugging feature. The error message can even tell you which variable caused the blocking (although in this section the deduced variable name is simply _).</p>

<p>Note that you must load Debug first, before using `Debug.setRaiseOnBlock' (which this tutorial does implicitly).</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Debug<span style="color: #a020f0;">.</span>setRaiseOnBlock {Thread<span style="color: #a020f0;">.</span>this} <span style="color: #a020f0;">true</span>}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>

</pre>




<!-- Page published by Emacs Muse ends here -->
<!-- Footer -->
<div id="footer">
<div id="author">&copy; 
Torsten Anders</div>
<div id="date">Last time edited: 2008.02.23</div>
</div>
  </body>
</html>
