<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>More Oz Basics</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
<div id="header">
  <ul class="nav">
    <li class="nav1"><a href="index.html">home</a></li>
    <li class="navn"><a href="https://sourceforge.net/projects/strasheela/">download at sourceforge</a></li>
    <!-- <li class="navn"><a href="IndexOfPages.html">site map</a></li> -->
    <li class="navn"><a href="contact.html">contact</a></li>
  </ul>
  <div id="logo">
    <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=167225&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </div>
</div>
    <h1>More Oz Basics</h1>
    <!-- Page published by Emacs Muse begins here -->
<div class="contents">
<dl>
<dt>
<a href="#sec1">About this document</a>
</dt>
<dt>
<a href="#sec2">&mdash; More Oz Basics</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec3">Introduction</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec4">Pattern Matching</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec5">Introduction</a>
</dt>
<dt>
<a href="#sec6">Case (head and tail)</a>
</dt>
<dt>
<a href="#sec7">Case (every element)</a>
</dt>
<dt>
<a href="#sec8">Multiple case clauses</a>
</dt>
<dt>
<a href="#sec9">Implicit pattern matching</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec10">Procedures over Compounds</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec11">Introduction</a>
</dt>
<dt>
<a href="#sec12">Record HasFeature</a>
</dt>
<dt>
<a href="#sec13">Record arity</a>
</dt>
<dt>
<a href="#sec14">Combining records</a>
</dt>
<dt>
<a href="#sec15">Accessing a list element</a>
</dt>
<dt>
<a href="#sec16">Reverse list</a>
</dt>
<dt>
<a href="#sec17">Append lists</a>
</dt>
<dt>
<a href="#sec18">User-defined procedures</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec19">Higher-Order Programming</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec20">Introduction</a>
</dt>
<dt>
<a href="#sec21">Filter</a>
</dt>
<dt>
<a href="#sec22">ForAll</a>
</dt>
<dt>
<a href="#sec23">Map</a>
</dt>
<dt>
<a href="#sec24">Zip</a>
</dt>
<dt>
<a href="#sec25">Anonymous procedures</a>
</dt>
<dt>
<a href="#sec26">Sort (simple)</a>
</dt>
<dt>
<a href="#sec27">Sort (advanced)</a>
</dt>
<dt>
<a href="#sec28">Defining higher-order procedures</a>
</dt>
<dt>
<a href="#sec29">BACKGROUND</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec30">Unification</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec31">Introduction</a>
</dt>
<dt>
<a href="#sec32">Unifying two numbers</a>
</dt>
<dt>
<a href="#sec33">Unifying two lists</a>
</dt>
<dt>
<a href="#sec34">Recursive unification</a>
</dt>
<dt>
<a href="#sec35">BACKGROUND</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec36">Object-Oriented Programming</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec37">Introduction</a>
</dt>
<dt>
<a href="#sec38">Method call</a>
</dt>
<dt>
<a href="#sec39">Method arguments</a>
</dt>
<dt>
<a href="#sec40">Nesting marker $</a>
</dt>
<dt>
<a href="#sec41">Class definition</a>
</dt>
<dt>
<a href="#sec42">BACKGROUND</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec43">Concurrency</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec44">Introduction</a>
</dt>
<dt>
<a href="#sec45">Variables (single thread)</a>
</dt>
<dt>
<a href="#sec46">Variables (multiple threads)</a>
</dt>
<dt>
<a href="#sec47">Blocked programs</a>
</dt>
<dt>
<a href="#sec48">Detecting blocked progs (1)</a>
</dt>
<dt>
<a href="#sec49">Detecting blocked progs (2)</a>
</dt>
</dl>
</dd>
</dl>
</div>


<h2><a name="sec1" id="sec1"></a>
About this document</h2>

<p class="first">This file was automatically generated from the interactive Strasheela tutorial. Some aspects of the text only make sense in the original interactive tutorial application (e.g., buttons indicated to press, and positions specified on the screen), and not in this version of the text.</p>


<h2><a name="sec2" id="sec2"></a>
&mdash; More Oz Basics</h2>

<h3><a name="sec3" id="sec3"></a>
Introduction</h3>

<p class="first">This chapter covers more basic info about Oz.  However, despite still being &quot;basic&quot; information, it requires a solid understanding of material in the previous chapter.</p>




<h2><a name="sec4" id="sec4"></a>
Pattern Matching</h2>

<h3><a name="sec5" id="sec5"></a>
Introduction</h3>

<p class="first">Pattern matching is a convenient way to access the elements contained in compund data types (i.e. records, lists, etc).  Pattern matching decomposes such compund data, declares new variables, and binds these variables to parts of the compound data.</p>

<p>The primary pattern matching construct is the `case' statement, but some programming constructs (such as functions) allow pattern matching via an implicit case statement.</p>




<h3><a name="sec6" id="sec6"></a>
Case (head and tail)</h3>

<p class="first">In the section below, `case' declares the two variables H and T and binds them to the head and tail of the list Xs.  Finally, the H and T are inspected.  Please note that the pattern-matching expression H|T is written with the usual list syntax using the cons-operation (|).</p>

<p>This approach can be used to pattern match lists of arbitrary length, except empty lists (i.e. nil).  Try changing the definition of Xs to a list of a different length and watch how the value of T changes.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span> H <span style="color: #a020f0;">|</span> T
   <span style="color: #a020f0;">then</span>
      {Inspect H}
      {Inspect T}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec7" id="sec7"></a>
Case (every element)</h3>

<p class="first">The previous section matched the head and the tail of a list.  Instead, we can also match individual list elements (or the elements of other data structures, such as records or tuples).</p>

<p>WARNING: if the length of the lists is not equal, an error occurs.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span> [A B C D]
   <span style="color: #a020f0;">then</span>
      {Inspect A}
      {Inspect B}
      {Inspect C}
      {Inspect D}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec8" id="sec8"></a>
Multiple case clauses</h3>

<p class="first">Having only a single clause to match against (as in the previous sections), can be too restrictive.  This section presents a typical `case' expression.  It matches a list, which checks whether Xs is either a non-empty list, an empty list, or some other value.  Additional case-clauses are introduced with the keyword `[]'.  You may want to play around with the value of Xs to try out these different clauses.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span> H<span style="color: #a020f0;">|</span>T <span style="color: #a020f0;">then</span> {Inspect nonEmptyList}
   <span style="color: #a020f0;">[]</span> nil <span style="color: #a020f0;">then</span> {Inspect emptyList}
   <span style="color: #a020f0;">else</span> {Inspect notList}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec9" id="sec9"></a>
Implicit pattern matching</h3>

<p class="first">The following function GetX expects a record as argument; this record must match test(x:X ...).  The variable X is implicitly declared and bound to the value at the feature 'x' of the record given as argument to the function.</p>

<p>Please note that the record in the header of the function GetX is not even complete but contains three dots (...) to indicate that further record features are possible.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   R = test(x:value1 y:value2)
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">GetX</span> test(x:X <span style="color: #a020f0;">...</span>)} X <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">show the normal record
</span>   {Inspect R}
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">show the feature we want
</span>   {Inspect {GetX R}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec10" id="sec10"></a>
Procedures over Compounds</h2>

<h3><a name="sec11" id="sec11"></a>
Introduction</h3>

<p class="first">Oz provides a rich set of procedures for processing compound data such as lists and records.  A few examples are shown here.  More procedures are listed in the reference documentation at</p>

<blockquote>
<p class="quoted"><a href="http://www.mozart-oz.org/documentation/base/index.html">http://www.mozart-oz.org/documentation/base/index.html</a></p>
</blockquote>




<h3><a name="sec12" id="sec12"></a>
Record HasFeature</h3>

<p class="first">Test whether a record has a certain feature.</p>

<pre class="src">
{Inspect {HasFeature <span style="color: #a020f0;">unit</span>(x:1 y:2 z:3) y}}
</pre>


<h3><a name="sec13" id="sec13"></a>
Record arity</h3>

<p class="first">Return the features of a record as a list.</p>

<pre class="src">
{Inspect {Arity <span style="color: #a020f0;">unit</span>(a b x:1 y:2 z:3)}}
</pre>


<h3><a name="sec14" id="sec14"></a>
Combining records</h3>

<p class="first">&quot;Merge&quot; two records.  Note that features and labels of the second record take precedence over the first.</p>

<pre class="src">
{Inspect {Adjoin <span style="color: #a020f0;">unit</span>(x:1 y:2 z:3) test(foo:hi bar:there z:<span style="color: #bc8f8f;">'overwrite!'</span>)}}
</pre>


<h3><a name="sec15" id="sec15"></a>
Accessing a list element</h3>

<p class="first">Return the nth element of a list.  Note that the list is 1-indexed.</p>

<pre class="src">
{Inspect {Nth [a b c d] 2}}
</pre>


<h3><a name="sec16" id="sec16"></a>
Reverse list</h3>

<p class="first">Reverse a list.</p>

<pre class="src">
{Inspect {Reverse [a b c d]}}
</pre>


<h3><a name="sec17" id="sec17"></a>
Append lists</h3>

<p class="first">Append two lists.</p>

<pre class="src">
{Inspect {Append [a b] [x y]}}
</pre>


<h3><a name="sec18" id="sec18"></a>
User-defined procedures</h3>

<p class="first">You can define procedures over lists and records as easily as numeric procedures.  Following is the definition of the function Append.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Append</span> Xs Ys}
    <span style="color: #a020f0;">if</span> Xs <span style="color: #a020f0;">==</span> nil <span style="color: #a020f0;">then</span> Ys
    <span style="color: #a020f0;">else</span> Xs<span style="color: #a020f0;">.</span>1 <span style="color: #a020f0;">|</span> {Append Xs<span style="color: #a020f0;">.</span>2 Ys}
    <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Inspect {Append [a b] [x y]}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec19" id="sec19"></a>
Higher-Order Programming</h2>

<h3><a name="sec20" id="sec20"></a>
Introduction</h3>

<p class="first">Oz procedures (and functions) are first-class values.  This means that a procedure can be processed like any other value.  For example, procedures can be given to other procedures as arguments.</p>

<p>This leads to highly flexible programming technique called higher-order programming.  Procedures expecting procedures as arguments are called higher-order procedures.  This concept is demonstrated be several sections.</p>




<h3><a name="sec21" id="sec21"></a>
Filter</h3>

<p class="first">The function Filter expects a list and a test function, and returns only those elements for which the test function returns true.</p>

<p>The function IsEven returns true for even integers and thus a list with only the even integers in [~4 ~3 ~2 ~1 0 1 2 3] is returned.  Try replaying IsEven by IsOdd, IsNumber or IsNat (testing for natural numbers) to better understand this filtering.</p>

<p>(BTW: there is a bug in IsOdd concerning negative numbers)</p>


<pre class="src">
{Browse {Filter [<span style="color: #a020f0;">~</span>4 <span style="color: #a020f0;">~</span>3 <span style="color: #a020f0;">~</span>2 <span style="color: #a020f0;">~</span>1 0 1 2 3] IsEven}}
</pre>


<h3><a name="sec22" id="sec22"></a>
ForAll</h3>

<p class="first">The procedure ForAll applies a given procedure to any element of a list.  In this section, the procedure Browse is applied to every list element.</p>

<pre class="src">
{ForAll [a b c d e f] Browse}
</pre>


<h3><a name="sec23" id="sec23"></a>
Map</h3>

<p class="first">The function Map expects a list and a unary function (i.e. a function expecting a single value) as arguments.  It applies the function to every list element, and returns the collected results in a list.</p>

<p>The section defines and uses the function square in order to square all numbers in the list.  You may want to change this function to understand that any function can be given to a higher-order function as an argument.  For example, replace Square by a function Double, which doubles its argument.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Square</span> X} X <span style="color: #a020f0;">*</span> X <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Browse {Map [1 2 3 4 5 6] Square}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec24" id="sec24"></a>
Zip</h3>

<p class="first">Zip applies a procedure to elements from two lists.  The
lists must have the same size.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y Z}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> Z = X <span style="color: #a020f0;">else</span> Z = Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
  A = [1 2 3 4 5]
  B = [5 4 3 2 1]
<span style="color: #a020f0;">in</span>
  {Browse {List<span style="color: #a020f0;">.</span>zip A B Max}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec25" id="sec25"></a>
Anonymous procedures</h3>

<p class="first">Sometimes we need a function only once &mdash; as the function Square in the previous section.  In such cases we don't necessarily need to care about giving the function any name.  Instead, we can define an anonymous function.</p>

<p>This section restates the previous section by defining the Square function 'inline' without giving it any name.  In an anonymous function definition, the variable which names the function is replaced by $ (dollar sign).</p>

<pre class="src">
{Browse
 {Map [1 2 3 4 5 6] <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X} X <span style="color: #a020f0;">*</span> X <span style="color: #a020f0;">end</span>}}
</pre>


<h3><a name="sec26" id="sec26"></a>
Sort (simple)</h3>

<p class="first">The function Sort expects a list and a binary function (i.e. a function expecting two values) as arguments.  This binary function compares two values, and Sort sorts the list values according to this comparison.  For example, the function in the section compares two numbers and returns true if the first number is smaller.  Consequently, this section sorts the list elements in ascending order.  You may want to replace the &lt; by &gt; in the function definition to sort the numbers in decreasing order.</p>


<pre class="src">
{Browse
 {Sort [1 5 3 2 0 7]
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X Y} X <span style="color: #a020f0;">&lt;</span> Y <span style="color: #a020f0;">end</span>}}
</pre>


<h3><a name="sec27" id="sec27"></a>
Sort (advanced)</h3>

<p class="first">You can actually sort the list elements in any way you want using the Sort function.  For example, you may place all even numbers at the beginning and all odd numbers at the end of the list and sort all even and odd numbers in ascending order.  This is done in the second (commented) Sort call.  How does this sorting work?</p>


<pre class="src">
{Browse
 {Sort
  [1 5 3 2 0 7]
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X Y}
    <span style="color: #a020f0;">if</span> {IsEven X} <span style="color: #a020f0;">then</span>
      <span style="color: #a020f0;">if</span> {IsEven Y} <span style="color: #a020f0;">then</span> X <span style="color: #a020f0;">&lt;</span> Y
      <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">true</span>
      <span style="color: #a020f0;">end</span>
    <span style="color: #a020f0;">else</span>
      <span style="color: #a020f0;">if</span> {IsOdd Y} <span style="color: #a020f0;">then</span> X <span style="color: #a020f0;">&lt;</span> Y
      <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">false</span>
      <span style="color: #a020f0;">end</span>
    <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>}}
</pre>


<h3><a name="sec28" id="sec28"></a>
Defining higher-order procedures</h3>

<p class="first">Higher order procedures are defined like any other procedure: some arguments are simply procedures &mdash; which are then usually applied in the definition.  This section defines a higher-order function Find which expects a list Xs and a test function Fn: Find returns the first element in Xs for which Fn returns true.</p>

<p>This section also demonstrates the pattern-matching case statement with multiple clauses operating on the list Xs.  In case Xs is the empty list nil, then Find returns nil.  Otherwise (multiple clauses are separated with the keyword []), Xs is matched with X|Xr, where X is bound to the first element of Xs and Xr to the list's tail or rest.  The function Find then checks whether {Fn X} returns true.  In that case, the searched for list element has been found and is returned.  Otherwise, Find is called recursively with the rest of the list.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Find</span> Xs Fn}
      <span style="color: #a020f0;">case</span> Xs
      <span style="color: #a020f0;">of</span> nil <span style="color: #a020f0;">then</span> nil
      <span style="color: #a020f0;">[]</span> X<span style="color: #a020f0;">|</span>Xr
      <span style="color: #a020f0;">then</span> <span style="color: #a020f0;">if</span> {Fn X} <span style="color: #a020f0;">then</span> X
           <span style="color: #a020f0;">else</span> {Find Xr Fn}
           <span style="color: #a020f0;">end</span>
      <span style="color: #a020f0;">end</span>
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   {Browse {Find [1 2 3 4 5 6] IsEven}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec29" id="sec29"></a>
BACKGROUND</h3>

<p class="first">Terms: first-class value, first-class function/procedure, higher-order function/procedure.</p>

<p>A first-class value is a value (also object, or citizen) which can be stored in data structures, given to procedures as arguments and returned as results. Functions which are first-class values are also called first-class functions.</p>

<p>First-class functions are a central concept of functional programming. They allow for higher-order programming, which make procedures more general and in effect can greatly reduce the length of a program. For example, instead of defining a sort function for every kind of data you need to sort (e.g., numbers, strings, score objects) you only define a single sort function and specify how it compares values.</p>

<p>Reading:</p>

<ul>
<li>van Roy and Haridi, Sec. 3.6</li>
<li>Wikipedia: <a href="http://en.wikipedia.org/wiki/First-class_function">http://en.wikipedia.org/wiki/First-class_function</a></li>
</ul>





<h2><a name="sec30" id="sec30"></a>
Unification</h2>

<h3><a name="sec31" id="sec31"></a>
Introduction</h3>

<p class="first">The operator = performs unification of two variables.  The variables share all the information they have about their values.  A variable without a name (an anonymous variable) is written as an underscore ( _ ).</p>




<h3><a name="sec32" id="sec32"></a>
Unifying two numbers</h3>

<p class="first">Unification shares information between two variables, including the domain of possible values. This example introduces finite domain integers (FD), discussed below in more detail.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
  X = {FD<span style="color: #a020f0;">.</span>int 1<span style="color: #a020f0;">#</span>5} <span style="color: #b22222;">% </span><span style="color: #b22222;">declare an integer with domain {1, ..., 5}
</span>  Y = {FD<span style="color: #a020f0;">.</span>int 0<span style="color: #a020f0;">#</span>3}
<span style="color: #a020f0;">in</span>
  X = Y          <span style="color: #b22222;">% </span><span style="color: #b22222;">unify X and Y
</span>  {Inspect X}    <span style="color: #b22222;">% </span><span style="color: #b22222;">X now has the domain {1, ..., 3}
</span><span style="color: #a020f0;">end</span>

</pre>


<h3><a name="sec33" id="sec33"></a>
Unifying two lists</h3>

<p class="first">Compound data structures such as lists may contain free variables. Such lists are then partially bound and they can be unified.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X = [a _ _]
  Y = [_ b _]
<span style="color: #a020f0;">in</span>
  X = Y          <span style="color: #b22222;">% </span><span style="color: #b22222;">unify X and Y
</span>  {Inspect X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec34" id="sec34"></a>
Recursive unification</h3>

<p class="first">Unification also works recursively.  The Inspector and Browser windows show two different ways for representing this.</p>

<p>The Inspector can be configured to show either way: under the options menu, structure tab, below representation, select between tree and relation mode.</p>

<pre class="src">
<span style="color: #a020f0;">local</span> X = <span style="color: #a020f0;">unit</span>(x:X) <span style="color: #a020f0;">in</span>
  {Browse X}
  {Inspect X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec35" id="sec35"></a>
BACKGROUND</h3>

<p class="first">Terms: logic variables, unification.</p>

<p>Unification is the core operation of logic programming (besides search). Variables which allow for unification are therefore also called &quot;logic variables&quot;. Unification is also the first constraint we meet. Constraint programming is discussed further below.</p>

<p>Reading:</p>

<ul>
<li>van Roy and Haridi, Chap. 2 (in particular Sec. 2.2, and 2.7.2)</li>
<li>Oz Tutorial, Chap. 4</li>
<li>Wikipedia: <a href="http://en.wikipedia.org/wiki/Unification">http://en.wikipedia.org/wiki/Unification</a></li>
</ul>





<h2><a name="sec36" id="sec36"></a>
Object-Oriented Programming</h2>

<h3><a name="sec37" id="sec37"></a>
Introduction</h3>

<p class="first">Oz supports object-oriented programming (OOP).  This programming paradigm introduces the notion of objects.  Objects encapsulate internal data and understand methods (or messages) which somehow process this internal data.  Different 'kinds' of objects are defined by defining classes: objects are class instances.  A class specifies what data are contained in its instances and what methods these instances understand. A method is effectively a procedure which is defined for instances of specific classes only.</p>




<h3><a name="sec38" id="sec38"></a>
Method call</h3>

<p class="first">The following section creates a graphical user interface button.  You do not need to understand the code which creates the window itself (i.e., the call to QTk.build).  For our purposes here, only this single line is important:</p>

<blockquote>
<p class="quoted">{Window show}</p>
</blockquote>

<p>`Window' is an object, and `show' is the name of the method understood by this object.  This method results in showing the window with the button.</p>

<p>Please note that the syntax of a method differs clearly from the procedure syntax shown before.  If `show' was a procedure, then we would write:</p>

<blockquote>
<p class="quoted">{Show Window}</p>
</blockquote>

<p>Internally, objects are actually procedures which expect a single argument &mdash; hence this syntax.  When the object is sent a message (i.e. the procedure is called with a specific argument) it processes the message according to its definition.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Window = {QTk<span style="color: #a020f0;">.</span>build lr(button(text:<span style="color: #bc8f8f;">"Hello world!"</span>
                                 action:toplevel<span style="color: #a020f0;">#</span>close))}
<span style="color: #a020f0;">in</span>
   {Window show}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec39" id="sec39"></a>
Method arguments</h3>

<p class="first">Class methods are actually records which can contain method arguments.  For example, the following statement sends the following message to the object Window.  This changes the width of the border around the button and sets the background of this border to the color blue.</p>

<blockquote>
<p class="quoted">{Window set(borderwidth:1.0#c background:blue)}</p>
</blockquote>

<p>In general, the record denoting a message can wrap multiple arguments, as in the following example where the method myMethod with multiple arguments is send to the class MyObject.</p>

<blockquote>
<p class="quoted">{MyObject myMethod(Arg1 Arg2 ...)}</p>
</blockquote>

<p>We will later see many more method application sections in the context of Strasheela's music representation.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Window = {QTk<span style="color: #a020f0;">.</span>build lr(button(text:<span style="color: #bc8f8f;">"Hello world!"</span>
                                 action:toplevel<span style="color: #a020f0;">#</span>close))}
<span style="color: #a020f0;">in</span>
   {Window show}
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">change to button background color after 1000 msec
</span>   {Delay 1000}
   {Window set(borderwidth:1<span style="color: #a020f0;">.</span>0<span style="color: #a020f0;">#</span>c
               background:blue)}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec40" id="sec40"></a>
Nesting marker $</h3>

<p class="first">Oz provides a special construct for marking return values.  This construct is the nesting marker which is notated $ (dollar sign).  In a previous example (repeated below), the nesting marker was used for defining an anonymous function.  In this case, $ returns the function value itself.</p>

<blockquote>
<p class="quoted">{Map [1 2 3 4 5 6] fun {$ X} X * X end}</p>
</blockquote>


<p>More generally, the nesting marker transforms any statement into an expression.  For example, method calls are statements by default &mdash; they return nothing.  The nesting marker can turn methods into expressions.  Using the nesting marker can make code more concise.  Instead of writing</p>

<blockquote>
<p class="quoted">local X in {Obj get(X)} {Browse X} end</p>
</blockquote>

<p>we can write</p>

<blockquote>
<p class="quoted">{Browse {Obj get($)}}</p>
</blockquote>

<p>The following example creates a text entry widget.  Whenever you edit the widget text, it is (re-)browsed.  Again it is not important to understand the full example; just note the code segment which does the browsing (see below).  Entry is the entry widget object, and the method get(X) binds its argument X to the present widget text (as string).</p>

<blockquote>
<p class="quoted">{Browse {String.toAtom {Entry get($)}}}</p>
</blockquote>


<pre class="src">
<span style="color: #a020f0;">local</span>
   Entry
   Window = {QTk<span style="color: #a020f0;">.</span>build
             lr(entry(init:<span style="color: #bc8f8f;">"Change this text..."</span>
                      handle:Entry
                      action:<span style="color: #a020f0;">proc</span>{<span style="color: #0000ff;">$</span>} {Browse {String<span style="color: #a020f0;">.</span>toAtom {Entry get($)}}} <span style="color: #a020f0;">end</span>))}
<span style="color: #a020f0;">in</span>
   {Window show}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec41" id="sec41"></a>
Class definition</h3>

<p class="first">This example defines a simple counter class.  It stores internally a counter value in its attribute i.  This value is accessed with the method get, and the method incr raises the counter value by one.  Every class defines an initialisation method: the method init expects the initial counter value as argument.  Note that the syntax for accessing and overwriting attribute values is very similar the the syntax of cells (see above).  In fact, object attributes are also stateful data, like cells.</p>

<p>The example then creates a counter object (MyCounter) with the function New, which expects a class and an initialisation method.  The rest of the example uses this object.  Its initial counter value 3 is first browsed. The object is then incremented (so the counter becomes 4), and then its value is browsed again.  Note the use of the nesting marking for returning the counter value.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">class</span> <span style="color: #228b22;">Counter</span>
      <span style="color: #a020f0;">attr</span> i                    <span style="color: #b22222;">% </span><span style="color: #b22222;">define attribute i
</span>      <span style="color: #a020f0;">meth</span> <span style="color: #0000ff;">init</span>(I) i <span style="color: #a020f0;">:=</span> I <span style="color: #a020f0;">end</span>   <span style="color: #b22222;">% </span><span style="color: #b22222;">bind i to arg I
</span>      <span style="color: #a020f0;">meth</span> <span style="color: #0000ff;">get</span>(I) I=<span style="color: #a020f0;">@</span>i <span style="color: #a020f0;">end</span>      <span style="color: #b22222;">% </span><span style="color: #b22222;">return i
</span>      <span style="color: #a020f0;">meth</span> <span style="color: #0000ff;">incr</span> i <span style="color: #a020f0;">:=</span> <span style="color: #a020f0;">@</span>i<span style="color: #a020f0;">+</span>1 <span style="color: #a020f0;">end</span>   <span style="color: #b22222;">% </span><span style="color: #b22222;">increment i by one
</span>   <span style="color: #a020f0;">end</span>
   MyCounter = {New Counter init(3)}
<span style="color: #a020f0;">in</span>
   {Browse {MyCounter get($)}}
   {MyCounter incr}
   {Browse {MyCounter get($)}}
<span style="color: #a020f0;">end</span>

</pre>


<h3><a name="sec42" id="sec42"></a>
BACKGROUND</h3>

<p class="first">Terms: class, object (class instance), method</p>

<p>Strasheela's music representation makes extensive use of object-oriented programming.  Even basic Strasheela programs commonly require writing method calls.  Extending Strasheela often means writing new Strasheela classes.</p>

<p>Nevertheless, object-oriented programming is a complex programming paradigm.  This section therefore presented only the very basics of this paradigm.  For more details, please refer to other Oz documentation:</p>

<p>Reading:</p>

<ul>
<li>van Roy and Haridi, Chap. 7</li>
<li>Oz Tutorial, Chap. 10</li>
</ul>

<p>Please note that object-oriented programming is often used as a stateful programming paradigm: methods often change the internal state of objects (cf. the counter example above).  By constrast, most methods in Strasheela are stateless which is important in the context of constraint programming.  The Strasheela music representation is introduced later in this tutorial.</p>





<h2><a name="sec43" id="sec43"></a>
Concurrency</h2>

<h3><a name="sec44" id="sec44"></a>
Introduction</h3>

<p class="first">Oz provides excellent support for concurrent programming, where computations run in parallel in multiple threads.  We will only touch on this subject and discuss aspects relevant for Strasheela.  In general, however, concurrent programming plays a major role in Oz programming.</p>

<p>The computations in different threads can communicate with each other via variables.  Multiple threads can use the same variable in a computation.  If the value of a variable does not present enough information for performing a specific operation, then the thread simply blocks and waits for more information.  As soon as more information about the variable value is available, the thread resumes its execution.  This approach makes concurrent programs highly declarative and thus easy to write and understand.</p>

<p>The downside of this concurrency model is that it can result in an unintended blocking of a program which is not explicitly signalled (e.g. no error message is shown when a program blocks, because this is a normal program behaviour).  There are a few pragmatic tricks we can use to avoid this downside; these are covered later in this chapter.</p>

<p>This section demonstrates concurrent programming, but does not show a typical application (a typical application would be a program split in a server and one or more clients).  In the context of Strasheela, we will seldomly write concurrent programs explicitly.  Nevertheless, it is very important to know how concurrent programming works in Oz.  Even if we are not explicitly writing a concurrent program, constraint programming in Oz always results in a concurrent program.  Concurrent programming forms one of the foundations of Oz' constraint programming model, where each constraint (i.e. each propagator) is a concurrent agent running in its own thread.</p>




<h3><a name="sec45" id="sec45"></a>
Variables (single thread)</h3>

<p class="first">Variables may be used to communicate information between different parts of a program &mdash; even if the information is not available yet.  Browse can handle unknown information, but other parts of the program may wait (i.e. block) until the information is available.</p>

<p>Here, `IsEven' binds the variable B.  Please note the order of computations in this section:</p>

<ol>
<li>B is browsed.</li>
<li>IsEven binds B to false.</li>
</ol>

<p>However, `Browse' does indeed show the correct value of B.  WARNING: not all procedures can handle unknown information.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
  B
<span style="color: #a020f0;">in</span>
  {Browse B}
  {Delay 3000}
  {IsEven 4 B}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec46" id="sec46"></a>
Variables (multiple threads)</h3>

<p class="first">Variables may also be used to communicate between different threads.  This example declares X and then browses 'hello' (just to show that the browser works in principle).  However, the addition X+3 cannot be executed immediately and blocks.  Because this computation is executed in its own thread, the top-level thread continues regardless, and calls the procedure Delay, which waits for 3000 msec.  After that time, the top-level thread determines X to 4.  This awakes the other thread: it can now compute X+3 and browse the sum.</p>

<p>In the section below, the addition X+3 cannot be performed as long as the value of X is unknown.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #a020f0;">thread</span> {Browse X <span style="color: #a020f0;">+</span> 3} <span style="color: #a020f0;">end</span>  <span style="color: #b22222;">% </span><span style="color: #b22222;">compute and browse X+3 concurrently
</span>  {Delay 3000}
  X = 4
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec47" id="sec47"></a>
Blocked programs</h3>

<p class="first">This section demonstrates a buggy program which does not signal any error but simply does nothing.  The section is very similar to the previous section, but does not place the blocking X+3 in its own thread.  As a result, the whole program blocks at that point and never executes X = 4.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec48" id="sec48"></a>
Detecting blocked progs (1)</h3>

<p class="first">This section demonstrates a pragmatic approach which checks for blocking programs.  The section ends with the statement {Browse endOfProgram}.  A non-blocking program will always execute this last line of code and show 'endOfProgram' in the Browser.  However, a blocking program (as the present one) does not do that and thus indicates that it is blocking.  Although this little trick does not tell us <em>where</em> the program blocks, the information <em>that</em> we wrote a blocking program can prove very helpful already.  You may get a feel for this trick by changing the section so that the message 'endOfProgram' is shown (e.g. comment the blocking statement out, or surrounding it with a 'thread .. end' statement).</p>

<p>Of course, this technique is most effective for programs which should complete immediately. By contrast, if we call procedures like Delay in a program (see above), the browsing of 'endOfProgram' will also be delayed accordingly.</p>


<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>
{Browse endOfProgram}
</pre>


<h3><a name="sec49" id="sec49"></a>
Detecting blocked progs (2)</h3>

<p class="first">This section demonstrates a technique which causes an error (raises an exception) when the current thread blocks. The function `Thread.this' returns the current thread, and `Debug.setRaiseOnBlock' activates this debugging feature. The error message can even tell you which variable caused the blocking (although in this section the deduced variable name is simply _).</p>

<p>Note that you must load Debug first, before using `Debug.setRaiseOnBlock' (which this tutorial does implicitly). For example, include the following line at the beginning of your program.</p>

<p>declare [Debug] = {Module.link ['x-oz://boot/Debug']}</p>



<pre class="src">
<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Debug<span style="color: #a020f0;">.</span>setRaiseOnBlock {Thread<span style="color: #a020f0;">.</span>this} <span style="color: #a020f0;">true</span>}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>

</pre>




<!-- Page published by Emacs Muse ends here -->
<!-- Footer -->
<div id="footer">
<div id="author">&copy; 
Torsten Anders and Graham Percival</div>
<div id="date">Last time edited: ; INVALID LISP CODE</div>
</div>
  </body>
</html>
