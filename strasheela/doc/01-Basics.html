<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Oz Basics</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=utf-8">
    
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
<div id="header">
  <ul class="nav">
    <li class="nav1"><a href="index.html">home</a></li>
    <li class="navn"><a href="https://sourceforge.net/projects/strasheela/">download at sourceforge</a></li>
    <!-- <li class="navn"><a href="IndexOfPages.html">site map</a></li> -->
    <li class="navn"><a href="contact.html">contact</a></li>
  </ul>
  <div id="logo">
    <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=167225&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </div>
</div>
    <h1>Oz Basics</h1>
    <!-- Page published by Emacs Muse begins here -->
<div class="contents">
<dl>
<dt>
<a href="#sec1">About this document</a>
</dt>
<dt>
<a href="#sec2">Start here</a>
</dt>
<dt>
<a href="#sec3">How to read this tutorial</a>
</dt>
<dt>
<a href="#sec4">Comments</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec5">Line comment</a>
</dt>
<dt>
<a href="#sec6">Block comment</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec7">Hello World!</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec8">Browse</a>
</dt>
<dt>
<a href="#sec9">Show</a>
</dt>
<dt>
<a href="#sec10">Inspect</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec11">Calculator</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec12">Integer example 1</a>
</dt>
<dt>
<a href="#sec13">Integer example 2</a>
</dt>
<dt>
<a href="#sec14">Integer example 3</a>
</dt>
<dt>
<a href="#sec15">Float example 1</a>
</dt>
<dt>
<a href="#sec16">Float example 2</a>
</dt>
<dt>
<a href="#sec17">Float example 3</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec18">Variables</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec19">Variable declaration</a>
</dt>
<dt>
<a href="#sec20">Variable scope</a>
</dt>
<dt>
<a href="#sec21">A variable can be unbound</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec22">If</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec23">if ... end</a>
</dt>
<dt>
<a href="#sec24">if ... else ... end</a>
</dt>
<dt>
<a href="#sec25">if as an expression</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec26">Procedure and Functions</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec27">Usage</a>
</dt>
<dt>
<a href="#sec28">Functions are procedures</a>
</dt>
<dt>
<a href="#sec29">Procedures used like functions</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec30">Procedure Definition</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec31">Max procedure</a>
</dt>
<dt>
<a href="#sec32">$ marks a return value</a>
</dt>
<dt>
<a href="#sec33">Function call of procedure</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec34">Function Definition</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec35">Max function</a>
</dt>
<dt>
<a href="#sec36">Recursion</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec37">Atoms and Names</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec38">Atoms</a>
</dt>
<dt>
<a href="#sec39">Equality</a>
</dt>
<dt>
<a href="#sec40">Names</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec41">Compound Types</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec42">Records (1)</a>
</dt>
<dt>
<a href="#sec43">Records (2)</a>
</dt>
<dt>
<a href="#sec44">Records (3)</a>
</dt>
<dt>
<a href="#sec45">Accessing record fields</a>
</dt>
<dt>
<a href="#sec46">Tuples (1)</a>
</dt>
<dt>
<a href="#sec47">Tuples (2)</a>
</dt>
<dt>
<a href="#sec48">Tuples (3)</a>
</dt>
<dt>
<a href="#sec49">Lists (1)</a>
</dt>
<dt>
<a href="#sec50">Lists (2)</a>
</dt>
<dt>
<a href="#sec51">Lists (3)</a>
</dt>
<dt>
<a href="#sec52">Lists (4)</a>
</dt>
<dt>
<a href="#sec53">Pairs (1)</a>
</dt>
<dt>
<a href="#sec54">Pairs (2)</a>
</dt>
<dt>
<a href="#sec55">Strings (1)</a>
</dt>
<dt>
<a href="#sec56">Strings (2)</a>
</dt>
<dt>
<a href="#sec57">Virtual Strings</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec58">Pattern Matching</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec59">Case statements (1)</a>
</dt>
<dt>
<a href="#sec60">Case statements (2)</a>
</dt>
<dt>
<a href="#sec61">Multiple case clauses</a>
</dt>
<dt>
<a href="#sec62">Implicit pattern matching</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec63">Procedures over Compound Data</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec64">HasFeature</a>
</dt>
<dt>
<a href="#sec65">Arity</a>
</dt>
<dt>
<a href="#sec66">Adjoin</a>
</dt>
<dt>
<a href="#sec67">Nth</a>
</dt>
<dt>
<a href="#sec68">Reverse</a>
</dt>
<dt>
<a href="#sec69">Append</a>
</dt>
<dt>
<a href="#sec70">User-defined procedures</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec71">Unification</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec72">Unifying two lists</a>
</dt>
<dt>
<a href="#sec73">Recursive unification</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec74">Class Method Application</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec75">Method call</a>
</dt>
<dt>
<a href="#sec76">Method arguments</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec77">Higher-Order Programming</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec78">Filter</a>
</dt>
<dt>
<a href="#sec79">ForAll</a>
</dt>
<dt>
<a href="#sec80">Map</a>
</dt>
<dt>
<a href="#sec81">Anonymous procedure definition</a>
</dt>
<dt>
<a href="#sec82">Sort (1)</a>
</dt>
<dt>
<a href="#sec83">Sort (2)</a>
</dt>
<dt>
<a href="#sec84">Defining higher-order procedures</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec85">Concurrency</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec86">Declarative concurrency</a>
</dt>
<dt>
<a href="#sec87">Blocking computation</a>
</dt>
<dt>
<a href="#sec88">'Signalling' a blocking computation</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec89">Understanding error messages</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec90">Parse error</a>
</dt>
<dt>
<a href="#sec91">Static analysis error</a>
</dt>
<dt>
<a href="#sec92">Binding analysis error</a>
</dt>
<dt>
<a href="#sec93">Type error</a>
</dt>
<dt>
<a href="#sec94">Failure</a>
</dt>
</dl>
</dd>
</dl>
</div>


<h2><a name="sec1" id="sec1"></a>
About this document</h2>

<p class="first">This file was automatically generated from the interactive Strasheela tutorial. Some aspects of the text only make sense in the original interactive tutorial application (e.g., buttons indicated to press, and positions specified on the screen), and not in this version of the text.</p>


<h2><a name="sec2" id="sec2"></a>
Start here</h2>

<p class="first">This interactive tutorial demonstrates the basics of the Oz programming language and Strasheela.  By presenting small code snippets which can be easily executed and edited, we hope to simply the process of learning about Oz/Strasheela.  After this tutorial, you should be ready to read and edit existing Strasheela examples, as well as creating your own Strasheela programs.</p>

<p>Nevertheless, this tutorial is kept brief.  The explanation of Oz focuses on aspects which are particularly important for Strasheela, and also Strasheela concepts are only outlined.  Everything is explained very briefly to get you started quickly.  In other words, it is not the intention of this tutorial to replace the extensive documentation already available on Oz, nor my thesis on Strasheela ;-)</p>

<p>This tutorial is organised in small lessons.  After you started the interactive tutorial application, you can select the examples in the list at the top-left of this window.  Many lessons consist of several sub-examples, accesible via the list in the bottom-right corner.  These examples are best studied in their order.</p>

<p>(if you are reading the tutorial in your HTML browser, of course there are no lists of lessons and examples)</p>





<h2><a name="sec3" id="sec3"></a>
How to read this tutorial</h2>

<p class="first">We use a few conventions to present information in this tutorial:</p>

<ul>
<li>`command': in the running text, code in the Oz language is enclosed in `single quotes'; remove them when writing your own code.</li>

<table class="muse-table" border="2" cellpadding="5">
  <tbody>
    <tr>
      <td><li>For explaining syntax, we use the Extended Backusâ€“Naur form (EBNF, <a href="http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form</a>). Non-terminal symbols are surrounded by angle brackets as  &lt;x&gt;, literal terminals are surrounded by single quotes as `&lt;x&gt;', alternatives are separated by a bar as $&lt;x&gt;</td>
      <td>&lt;y&gt;$, and optional items are surrounded by brackets as $[ &lt;x&gt; ]$. The ellipsis (...) specifies an incomplete EBNF rule, e.g., that at the end of the rule further alternatives are omitted. The suffix * (Kleene star) means that the preceding item is repeated zero or more times whereas the suffix + means that the preceding item is repeated at least once. Multiple symbols can be grouped by round parenthesis to specify a suffix for the whole group.</td>
    </tr>
  </tbody>
</table>

<p>For example, the `if' statement has the following syntax in Oz</p>

<blockquote>
<p class="quoted">`if' &lt;expression&gt; `then'
&lt;statement1&gt;
[ `else'
&lt;statement2&gt; ]
`end'</p>
</blockquote>

<p>When writing your own code, you remove the syntax markers, as in the following example:</p>

<blockquote>
<p class="quoted">if X=Y then ok end</p>
</blockquote></li>

<li>Naturally, the actual code examples use Oz syntax, which we will explain as we move along.</li>
<li>WARNING: explains a particularly confusing part of the Oz language.</li>
<li>BACKGROUND: these are generic concepts in Computer Science; if the list contains unfamiliar terms, please consult the reading list below.</li>
</ul>


<p>For explanations about general concepts, see:
- van Roy and Haridi (2004). Concepts, Techniques, and Models of Computer Programming. MIT Press. <a href="http://www.info.ucl.ac.be/~pvr/book.html">http://www.info.ucl.ac.be/~pvr/book.html</a>
- The Oz documentation: <a href="http://www.mozart-oz.org/documentation/">http://www.mozart-oz.org/documentation/</a>
- Wikipedia (maybe?  -I'd rather find a better resource, though)</p>




<p>TODO this is just to see what the docs look like; will be removed.</p>

<p>We use a few conventions to present information in this tutorial:</p>

<blockquote>
<p class="quoted">&lt;expression&gt;: this refers to an arbitrary expression (remove the &lt;&gt;)</p>
</blockquote>

<blockquote>
<p class="quoted">`command': this refers to a command or statment in the Oz language.</p>
</blockquote>

<blockquote>
<p class="quoted">{something}: this is not a documentation convention at all; the {curly braces} are an essential part of the Oz syntax.  Do not remove these!</p>
</blockquote>

<blockquote>
<p class="quoted">WARNING: explains a particularly confusing part of the Oz language.</p>
</blockquote>

<blockquote>
<p class="quoted">BACKGROUND: these are generic concepts in Computer Science; if the list contains unfamiliar terms, please consult the reading list below.</p>
</blockquote>

<p>end list.</p>







<h2><a name="sec4" id="sec4"></a>
Comments</h2>

<p class="first">Oz supports line comments and block comments.  There are two examples in the bottom-right list:
<blockquote>
<p class="quoted">Line comment
Block comment</p>
</blockquote>

<p>Please select each example to see how these comments differ.</p>

<p>(Executing these examples does nothing, of course!)</p>

<h3><a name="sec5" id="sec5"></a>
Line comment</h3>

<pre class="src">
<span style="color: #b22222;">% </span><span style="color: #b22222;">this is a line comment
</span></pre>


<h3><a name="sec6" id="sec6"></a>
Block comment</h3>

<pre class="src">
<span style="color: #b22222;">/*</span><span style="color: #b22222;">
this is a
block
comment
*/</span>
</pre>



<h2><a name="sec7" id="sec7"></a>
Hello World!</h2>

<p class="first">The statement</p>

<blockquote>
<p class="quoted">{Browse something}</p>
</blockquote>

<p>shows 'something' in the Oz Browser.  Hit the [Run] button below to execute this example.  Congratulations, you just executed your first Oz program! Try changing the 'Hello World!' text and see what happens.</p>

<p>The other examples demonstrate alternative ways to output information.
<blockquote>
<p class="quoted">Browse: opens a Browse window
Show: outputs text to standard out
Inspect: opens an Inspect window</p>
</blockquote>

<p>WARNING: the pair of curly braces {...} is necessary; they always expresses a function or procedure call.</p>

<h3><a name="sec8" id="sec8"></a>
Browse</h3>

<pre class="src">
{Browse <span style="color: #bc8f8f;">'Hello World!'</span>}
</pre>


<h3><a name="sec9" id="sec9"></a>
Show</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Show something at standard out (the commandline where you started
this tutorial). */</span>

{Show <span style="color: #bc8f8f;">'Hello World!'</span>}
</pre>


<h3><a name="sec10" id="sec10"></a>
Inspect</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The inspector shows sometimes more information than the Browser
(depending on the inspected value).  The inspector may be hidden behind
this tutorial.. */</span>

{Inspect <span style="color: #bc8f8f;">'Hello World!'</span>}
</pre>



<h2><a name="sec11" id="sec11"></a>
Calculator</h2>

<p class="first">This example executes simple numeric calculations and displays the result.</p>

<p>Try changing the calculation by using different numbers and freely combining the operators +, -, * , ~ (negation), div (integer division), mod (integer modulus) and / (float division).  You may also use parenthesis to indicate precedence.</p>

<p>You can use integers (e.g. 3, 7) and floats (e.g. 1.0, 3.14).  However, you can not directly mix integers and floats in a calculation (in that case, an error will be printed at the command line).</p>

<h3><a name="sec12" id="sec12"></a>
Integer example 1</h3>

<pre class="src">
{Browse 3<span style="color: #a020f0;">+</span>4}
</pre>


<h3><a name="sec13" id="sec13"></a>
Integer example 2</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">~ is the negation sign
</span>{Browse <span style="color: #a020f0;">~</span>7 <span style="color: #a020f0;">*</span> 5}
</pre>


<h3><a name="sec14" id="sec14"></a>
Integer example 3</h3>

<pre class="src">
{Browse (4 <span style="color: #a020f0;">+</span> 2) <span style="color: #a020f0;">div</span> 2}
</pre>


<h3><a name="sec15" id="sec15"></a>
Float example 1</h3>

<pre class="src">
{Browse 3<span style="color: #a020f0;">.</span>0 <span style="color: #a020f0;">/</span> <span style="color: #a020f0;">~</span>2<span style="color: #a020f0;">.</span>0}
</pre>


<h3><a name="sec16" id="sec16"></a>
Float example 2</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A float is converted into the closest integer
with the function FloatToInt (in case two integers are equally close it rounds
to the closest even integer).  There is also a function IntToFloat. */</span>

{Browse {FloatToInt 3<span style="color: #a020f0;">.</span>5}}
</pre>


<h3><a name="sec17" id="sec17"></a>
Float example 3</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">many other numeric functions are available for floats,
</span><span style="color: #b22222;">%% </span><span style="color: #b22222;">e.g., Exp, Log, Sin, Cos...
</span>{Browse {Sqrt 9<span style="color: #a020f0;">.</span>0}}
</pre>



<h2><a name="sec18" id="sec18"></a>
Variables</h2>

<p class="first">The keyword local introduces a variable.  WARNING: variables must start with a capital letter in Oz.</p>

<p>Please note that Oz variables are single assignment variables.  After a variable is bound, it cannot be changed anymore (mutable data is also supported by Oz, but not discussed in this tutorial; read about cells in the Oz documentation).</p>

<p>However, in contrast to most other constraint programming languages, a variable can be unbound or even partially bound.  In other words, variables in Oz are 'logic variables'.  This is discussed further in the lesson &quot;Unification&quot; below.</p>

<p>Global variables can be introduced with the keyword 'declare'.  However, global variables are intended for testing and are only supported in the Emacs-based Oz Programming Interface (OPI), not in this tutorial application.</p>


<h3><a name="sec19" id="sec19"></a>
Variable declaration</h3>

<pre class="src">
<span style="color: #a020f0;">local</span>
   X = 1 <span style="color: #a020f0;">+</span> 1
   Y
<span style="color: #a020f0;">in</span>
   Y = 3
   {Browse X<span style="color: #a020f0;">*</span>Y}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec20" id="sec20"></a>
Variable scope</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Local statements can be freely nested (like
virtually everything in Oz).  Oz supports static or lexical scope (i.e. a
variable always refers to its nearest enclosing binding). */</span>

<span style="color: #a020f0;">local</span>
   X = 3
<span style="color: #a020f0;">in</span>
  <span style="color: #a020f0;">local</span>
    <span style="color: #b22222;">%% </span><span style="color: #b22222;">shadows the outer X
</span>    X = 4
  <span style="color: #a020f0;">in</span>
    {Browse X}
  <span style="color: #a020f0;">end</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">later, browse original X
</span>  {Browse X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec21" id="sec21"></a>
A variable can be unbound</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Watch the Browser: X is first unbound (_ is displayed).
X is bound to 3 after 3000 msec. */</span>

<span style="color: #a020f0;">local</span>
   X
<span style="color: #a020f0;">in</span>
   {Browse X}
   {Delay 3000}
   X = 3
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec22" id="sec22"></a>
If</h2>

<p class="first">Oz provides the usual if control structure.  Note that unlike many programming languages, parenthesis () are not required around the condition.</p>

<p>The general format is:</p>

<blockquote>
<p class="quoted">if &lt;expression&gt; then
&lt;statement1&gt;
else
&lt;statement2&gt;
end</p>
</blockquote>

<p>The [else] clause is optional.  Oz is white-space insensitive, so [if] statements can be placed on a single line.</p>

<p>Please note that the [if] control structure can also be used as an expression which returns a value from the [then] or [else] clause.</p>


<h3><a name="sec23" id="sec23"></a>
if ... end</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">This example does nothing, but try changing == to \=.
</span><span style="color: #b22222;">%% </span><span style="color: #b22222;">The operations == and \= test equality and inequality of values.
</span>
<span style="color: #a020f0;">if</span> this <span style="color: #a020f0;">==</span> that <span style="color: #a020f0;">then</span>
    {Browse hi}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec24" id="sec24"></a>
if ... else ... end</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">try changing 2 to 6...
</span>
<span style="color: #a020f0;">if</span> 2 <span style="color: #a020f0;">&lt;</span> 5 <span style="color: #a020f0;">then</span>
    {Browse less}
<span style="color: #a020f0;">else</span>
    {Browse more}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec25" id="sec25"></a>
if as an expression</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">This `if' returns a value.
</span>
{Browse
 <span style="color: #a020f0;">if</span> 2 <span style="color: #a020f0;">&lt;</span> 5 <span style="color: #a020f0;">then</span> less <span style="color: #a020f0;">else</span> more <span style="color: #a020f0;">end</span>}
</pre>



<h2><a name="sec26" id="sec26"></a>
Procedure and Functions</h2>

<p class="first">Procedures and functions are the standard means for expressing a collection of computations in a single entity.  Examples range from numeric computations to commands involving the operating system.  For example, we have already seen a number of numeric operations expressed by the common infix notation.</p>

<p>WARNING: curly braces {...} must surround a function or a procedure call.  This syntax for procedure/function application is rather unusual when compared with other programming languages, but it is also unambiguous.</p>

<p>In Oz, procedures are the fundamental concept.  Functions are just a syntactic variant of procedures, added for convenience.  The main difference between functions and procedures is that functions are procedures which always returns exactly one value.  Procedures do not necessarily return anything.</p>

<p>More specifically, a function is a procedure whose last argument &mdash; the return value &mdash; is expressed implicitly.  Every function may be called like a procedure by adding this return value explicitly.  In addition, any procedure can also be called as a function which returns its omitted last argument.</p>


<h3><a name="sec27" id="sec27"></a>
Usage</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">call procedure Browse with the result of function IsEven
</span><span style="color: #b22222;">%% </span><span style="color: #b22222;">IsEven expects one integer as an argument, and returns true or false.
</span><span style="color: #b22222;">%% </span><span style="color: #b22222;">Browse expects one argument (any variable type), and returns nothing.
</span>
{Browse
 <span style="color: #b22222;">%% </span><span style="color: #b22222;">call function IsEven
</span> {IsEven 3}}
</pre>


<h3><a name="sec28" id="sec28"></a>
Functions are procedures</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Here we treat IsEven as a procedure with two arguments.
IsEven binds the variable B.  Please note the order of computations in this
example.  Firstly, B is browsed.  Then IsEven binds B to false.  However, Browse
does indeed show the correct value of B.

This demonstrates a vital feature of Oz: variables are be used to
communicate information between different parts of a program -- even
if the information is not available yet.  Browse can handle unknown
information, but other parts of the program may wait (i.e. block)
until the information is available.  */</span>

<span style="color: #a020f0;">local</span> B <span style="color: #a020f0;">in</span>
   {Browse B}
   {IsEven 4 B}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec29" id="sec29"></a>
Procedures used like functions</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Because functions are just a syntactic variant of procedures, every
procedure (e.g.  Browse) can also be used like a function which
returns its last argument. */</span>

<span style="color: #a020f0;">local</span> X = {Browse}
<span style="color: #a020f0;">in</span>
  X = 3
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec30" id="sec30"></a>
Procedure Definition</h2>

<p class="first">A procedure definition wraps up (abstracts) some computation: a complex computation can then be executed simply by calling the procedure.  In the example, the procedure Max gets two numbers as its first two arguments and binds its last argument to the greater number (&gt;= means 'greater or equal').  Note that the curly braces in the definition surround the procedure name and its arguments like a procedure call.</p>

<h3><a name="sec31" id="sec31"></a>
Max procedure</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">NB: the variable X in the Max definition and the variable X outside
are different variables (cf. variable scope above). */</span>

<span style="color: #a020f0;">local</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">procedure definition
</span>  <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y Z}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> Z = X <span style="color: #a020f0;">else</span> Z = Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
  X
<span style="color: #a020f0;">in</span>
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">procedure application
</span>  {Max 4 3 X}
  {Browse X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec32" id="sec32"></a>
$ marks a return value</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Every procedure argument can be a return value.  The $ (dollar sign)
always marks a return value.  This example is not yet very convincing,
but procedures will encapsulate constraints in later examples... */</span>

<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y Z}
      <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> Z = X <span style="color: #a020f0;">else</span> Z = Y <span style="color: #a020f0;">end</span>
   <span style="color: #a020f0;">end</span>
   X = 4
   Result
<span style="color: #a020f0;">in</span>
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">Note the $
</span>   X = {Max $ 3 Result}
   {Browse Result}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec33" id="sec33"></a>
Function call of procedure</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Remember, every procedure can also be called like a function for convenience.
</span>
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y Z}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> Z = X <span style="color: #a020f0;">else</span> Z = Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Browse {Max 4 3}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec34" id="sec34"></a>
Function Definition</h2>

<p class="first">Oz offers a simplified notation (syntactic sugar) for a procedure definition which returns its last value: it can be defined as a function.</p>

<h3><a name="sec35" id="sec35"></a>
Max function</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">This Max function is equivalent to the Max procedure of the previous lesson.
</span>
<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Max</span> X Y}
     <span style="color: #a020f0;">if</span> X <span style="color: #a020f0;">&gt;=</span> Y <span style="color: #a020f0;">then</span> X <span style="color: #a020f0;">else</span> Y <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Browse {Max 4 3}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec36" id="sec36"></a>
Recursion</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Procedures and functions can call themselves (recursion).  The
function Factorial implements the mathematical factorial concept. */</span>

<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Factorial</span> N}
      <span style="color: #a020f0;">if</span> N<span style="color: #a020f0;">==</span>0
      <span style="color: #a020f0;">then</span> 1
      <span style="color: #a020f0;">else</span> N <span style="color: #a020f0;">*</span> {Factorial N<span style="color: #a020f0;">-</span>1}
      <span style="color: #a020f0;">end</span>
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">10! = 3628800
</span>   {Browse
    {Factorial 10}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec37" id="sec37"></a>
Atoms and Names</h2>

<p class="first">Oz provides a number of basic data types which have a specific textual representation in source code.  We have already seen numbers (i.e. integers and floats).  Here we shall discuss two other data types: Atoms and Names.</p>

<p>Atom:
The safest way to create an atom is to surround it in single quotes: 'hi there'..  Atoms may also be written as text (without spaces) as long as they do not start with a capital letter (those are variables) and the text is not an Oz keyword.  For simplicity, we recommend using 'single quotes'.  ;)</p>

<p>Name:
There are a few things which look like atoms, but are a different variable type: Name.  The boolean values true and false are both Names (specifically, the Bool subtype).  Another often used value which looks like an atom is unit (also a name).</p>

<h3><a name="sec38" id="sec38"></a>
Atoms</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Several atoms are inspected below. (Remember that the inspector window
</span><span style="color: #b22222;">%% </span><span style="color: #b22222;">might open behind the tutorial!)
</span>
{Inspect <span style="color: #bc8f8f;">'I am an atom'</span>}
{Inspect iAmAnAtom}
{Inspect test}
{Inspect nil}
<span style="color: #b22222;">%% </span><span style="color: #b22222;">if is an Oz keyword, but 'if' is an atom
</span>{Inspect <span style="color: #bc8f8f;">'if'</span>}
{Inspect <span style="color: #bc8f8f;">'=='</span>}
</pre>


<h3><a name="sec39" id="sec39"></a>
Equality</h3>

<pre class="src">
{Inspect test <span style="color: #a020f0;">==</span> <span style="color: #bc8f8f;">'test'</span>}
</pre>


<h3><a name="sec40" id="sec40"></a>
Names</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The values `true', `false' and `unit' are values which are similar
to atoms, but which play a special role (note that the quotes don't
belong to the values here). Obviously, `true' and `false' are the
common boolean values. Oz provides the value `unit' for the computer
science concept of the unit type (a value which is intended to express
no further information). For example, `unit' is often used wherever a
token is needed whose value is not important. */</span>

{Inspect <span style="color: #a020f0;">true</span>}
{Inspect <span style="color: #a020f0;">false</span>}
{Inspect <span style="color: #a020f0;">unit</span>}

<span style="color: #b22222;">%% </span><span style="color: #b22222;">The Inspector shows atoms and names in different colors
</span>{Inspect <span style="color: #bc8f8f;">'I am an atom'</span>}
</pre>



<h2><a name="sec41" id="sec41"></a>
Compound Types</h2>

<p class="first">Besides the atomic types discussed before, Oz also provides compound data types: records, tuples, lists, and strings.</p>

<p>Internally, all of these data types are actually records (just like all functions are actually procedures).  Tuples, lists, and strings just provide a different syntax for interacting with records.</p>

<h3><a name="sec42" id="sec42"></a>
Records (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A record has a label and consists of feature-value pairs.
</span>
{Inspect label(feature1:value1 feature2:value2)}
</pre>


<h3><a name="sec43" id="sec43"></a>
Records (2)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Records can be freely nested.
</span>
{Inspect test(1:hi 2:there x:<span style="color: #a020f0;">unit</span>(foo:bar))}
</pre>


<h3><a name="sec44" id="sec44"></a>
Records (3)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Integer features can be omitted.  The following example is identical to the previous. */</span>

{Inspect test(hi there x:<span style="color: #a020f0;">unit</span>(foo:bar))}
</pre>


<h3><a name="sec45" id="sec45"></a>
Accessing record fields</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Record fields are accessed with the dot operator.  R.X returns the
value stored at feature X in record R.  Records support constant-time
access (i.e. the time the access takes is independent of the feature
position). */</span>

{Inspect test(x:hi y:there)<span style="color: #a020f0;">.</span>x}
</pre>


<h3><a name="sec46" id="sec46"></a>
Tuples (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A tuple consists of a label and values.
</span>
{Inspect label(value1 value2 value3)}
</pre>


<h3><a name="sec47" id="sec47"></a>
Tuples (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Actually, a tuple is a record which has only integer features in
ascending order.  These features can be omitted.  The two records below
are equivalent. */</span>

{Inspect <span style="color: #a020f0;">unit</span>(1:a 2:b 3:c) <span style="color: #a020f0;">==</span> <span style="color: #a020f0;">unit</span>(a b c)}
</pre>


<h3><a name="sec48" id="sec48"></a>
Tuples (3)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">An atom is an "empty" tuple.
</span>
{Inspect test() <span style="color: #a020f0;">==</span> test}
</pre>


<h3><a name="sec49" id="sec49"></a>
Lists (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A list is a sequence of values.
</span>
{Browse [value1 value2 value3]}
</pre>


<h3><a name="sec50" id="sec50"></a>
Lists (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A list can also be written using | (cf. cons in Lisp). nil is the
empty list, which terminates every list. */</span>

{Inspect a<span style="color: #a020f0;">|</span>b<span style="color: #a020f0;">|</span>c<span style="color: #a020f0;">|</span>nil}
</pre>


<h3><a name="sec51" id="sec51"></a>
Lists (3)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Actually, a list is a nested tuple with the labels '|'.
</span>
{Inspect [a b c] <span style="color: #a020f0;">==</span> <span style="color: #bc8f8f;">'|'</span>(a <span style="color: #bc8f8f;">'|'</span>(b <span style="color: #bc8f8f;">'|'</span>(c nil)))}
</pre>


<h3><a name="sec52" id="sec52"></a>
Lists (4)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Consequently, the first element of a list can be accessed under the
feature 1, and the remaining list under the feature 2. */</span>

{Inspect [a b c]<span style="color: #a020f0;">.</span>2}
</pre>


<h3><a name="sec53" id="sec53"></a>
Pairs (1)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">A pair is a convenient way of concatenating values.
</span>
{Inspect value1 <span style="color: #a020f0;">#</span> value2 <span style="color: #a020f0;">#</span> value3}
</pre>


<h3><a name="sec54" id="sec54"></a>
Pairs (2)</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Actually, a pair is a tuple with the label '#'.
</span>
{Inspect a<span style="color: #a020f0;">#</span>b<span style="color: #a020f0;">#</span>c  <span style="color: #a020f0;">==</span> <span style="color: #bc8f8f;">'#'</span>(a b c)}
</pre>


<h3><a name="sec55" id="sec55"></a>
Strings (1)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A string is a list of integers denoting characters (i.e. all list
procedures can be used for strings). */</span>

{Inspect <span style="color: #bc8f8f;">"test"</span> <span style="color: #a020f0;">==</span> [116 101 115 116]}
</pre>


<h3><a name="sec56" id="sec56"></a>
Strings (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Although a string is just a list of integers, you can show strings
as text in the Browser and the Inspector.  However, you need to
configure them for showing strings first.  In the Inspector Preference
settings (Options menu), select the tab Appearance and tick "Show
Strings".  You need to do these settings before you inspect a
string. */</span>

{Inspect <span style="color: #bc8f8f;">"This is a string!"</span>}
</pre>


<h3><a name="sec57" id="sec57"></a>
Virtual Strings</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">A virtual string (VS) is a (possibly nested) concatenation of
strings, atoms, and numbers.  Many procedures expecting strings as
arguments can also handle virtual strings for convenience. */</span>

<span style="color: #a020f0;">local</span>
  VS = <span style="color: #bc8f8f;">'my test '</span>
<span style="color: #a020f0;">in</span>
  {Inspect VS<span style="color: #a020f0;">#</span>3}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec58" id="sec58"></a>
Pattern Matching</h2>

<p class="first">Pattern matching is a convenient way to access the elements contained in records, lists etc.  Pattern matching decomposes such compound data, declares new variables, and binds these variables to parts of the compound data.</p>

<p>The primary pattern matching construct is the case statement, but some programming constructs (for example, functions) allow pattern matching via an implicit case statement.</p>


<h3><a name="sec59" id="sec59"></a>
Case statements (1)</h3>

<pre class="src">
 <span style="color: #b22222;">/* </span><span style="color: #b22222;">In the example below, case declares the two variables H and T and
binds them to the head and tail of the list Xs.  Finally, the H and T are
inspected.  Please note that the pattern-matching expression H|T is written
with the usual list syntax using | (the cons-operation).

This approach can be used to pattern match lists of arbitrary length,
except empty lists (i.e. nil). Try to change the definition of Xs to a
list of a different length and watch how the value of T changes. */</span>

<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span> H <span style="color: #a020f0;">|</span> T
   <span style="color: #a020f0;">then</span> {Inspect H} {Inspect T}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec60" id="sec60"></a>
Case statements (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The previous example matched the head and the tail of a
list. Instead, we can also match individual list elements (or the
elements of other data structures, such as records or tuples). Note
that in this example changing the length of the lists results in an
error. */</span>

<span style="color: #a020f0;">local</span>
   Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span> [A B C D]
   <span style="color: #a020f0;">then</span> {Inspect A} {Inspect B} {Inspect C} {Inspect D}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec61" id="sec61"></a>
Multiple case clauses</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Having only a single clause to match against (as in the previous
examples), can be too restrictive. This example presents a typical
case expression matching a list, which checks whether Xs is either a
non-empty list, or an empty list, or some other value. You may want to
play around with the value of Xs to try out these different
clauses. */</span>

<span style="color: #a020f0;">local</span> Xs = [1 2 3 4]
<span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">case</span> Xs <span style="color: #a020f0;">of</span>  H<span style="color: #a020f0;">|</span>T <span style="color: #a020f0;">then</span> {Inspect nonEmptyList}
      <span style="color: #a020f0;">[]</span> nil <span style="color: #a020f0;">then</span> {Inspect emptyList}
      <span style="color: #a020f0;">else</span> {Inspect differentValue}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec62" id="sec62"></a>
Implicit pattern matching</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The following function GetPitch expects a record as
argument which must match the record note(pitch:Pitch ...).  The
variable Pitch is implicitly declared and bound to the value at the
feature 'pitch' of the record given as argument to the function.

Please note that the record in the header of the function
GetPitch is not even complete but contains three dots (...) to
indicate that further record features are possible. */</span>

<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">GetPitch</span> note(pitch:Pitch <span style="color: #a020f0;">...</span>)}
      Pitch
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   {Inspect {GetPitch note(duration:4 pitch:60)}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec63" id="sec63"></a>
Procedures over Compound Data</h2>

<p class="first">Oz provides a rich set of procedures for processing these compound data such as lists and records.  A few examples are shown here.  More procedures are listed in the reference documentation at</p>

<blockquote>
<p class="quoted"><a href="http://www.mozart-oz.org/documentation/base/index.html">http://www.mozart-oz.org/documentation/base/index.html</a></p>
</blockquote>


<h3><a name="sec64" id="sec64"></a>
HasFeature</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Tests whether a record has a certain feature
</span>
{Inspect {HasFeature <span style="color: #a020f0;">unit</span>(x:1 y:2 z:3) y}}
</pre>


<h3><a name="sec65" id="sec65"></a>
Arity</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Return the features of a record as a list.
</span>
{Inspect {Arity <span style="color: #a020f0;">unit</span>(a b x:1 y:2 z:3)}}
</pre>


<h3><a name="sec66" id="sec66"></a>
Adjoin</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">"Merge" two records.  Note that features and label of the second
record take precedence over the first. */</span>

{Inspect {Adjoin <span style="color: #a020f0;">unit</span>(x:1 y:2 z:3) test(foo:hi bar:there z:<span style="color: #bc8f8f;">'overwrite!'</span>)}}
</pre>


<h3><a name="sec67" id="sec67"></a>
Nth</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Return the nth element of a list.
</span>
{Inspect {Nth [a b c d] 2}}
</pre>


<h3><a name="sec68" id="sec68"></a>
Reverse</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Reverse a list.
</span>
{Inspect {Reverse [a b c d]}}
</pre>


<h3><a name="sec69" id="sec69"></a>
Append</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Append two lists.
</span>
{Inspect {Append [a b] [x y]}}
</pre>


<h3><a name="sec70" id="sec70"></a>
User-defined procedures</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">You can define procedures over lists and records as easily as
numeric procedures.  Following is the definition of the function
Append. */</span>

<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Append</span> Xs Ys}
    <span style="color: #a020f0;">if</span> Xs <span style="color: #a020f0;">==</span> nil <span style="color: #a020f0;">then</span> Ys
    <span style="color: #a020f0;">else</span> Xs<span style="color: #a020f0;">.</span>1 <span style="color: #a020f0;">|</span> {Append Xs<span style="color: #a020f0;">.</span>2 Ys}
    <span style="color: #a020f0;">end</span>
  <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Inspect {Append [a b] [x y]}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec71" id="sec71"></a>
Unification</h2>

<p class="first">The operator = performs unification of two variables.  The variables quasi share all the information they have about their values.  A variable without a name (an anonymous variable) is written as an underscore ( _ ).  Unification is a basic form of constraint programming (constraint programming is discussed further below).</p>


<h3><a name="sec72" id="sec72"></a>
Unifying two lists</h3>

<pre class="src">
<span style="color: #a020f0;">local</span>
  X = [a _ _]
  Y = [_ b _]
<span style="color: #a020f0;">in</span>
  X = Y          <span style="color: #b22222;">% </span><span style="color: #b22222;">unify X and Y
</span>  {Inspect X}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec73" id="sec73"></a>
Recursive unification</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Unification also works recursively.  The Inspector and the Browser
show two different ways for representing that (the Inspector can be
configured to show either way: options menu, structure tab, under
representation, select between tree and relation mode). */</span>

<span style="color: #a020f0;">local</span> X = <span style="color: #a020f0;">unit</span>(x:X) <span style="color: #a020f0;">in</span>
  {Browse X}
  {Inspect X}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec74" id="sec74"></a>
Class Method Application</h2>

<p class="first">Oz supports object-oriented programming.  This programming paradigm introduces the notion of objects which instantiate classes.  An object (or class instance) is a datum which encapsulates its internal structure.  A class specifies what data are contained in its instances and what methods these instances understands.  A method (or message) is effectively a procedure which is defined for instances of specific classes only.</p>

<p>For more details on object-oriented programming in general, please refer to other Oz documentation:
<blockquote>
<p class="quoted"><a href="http://www.mozart-oz.org/documentation/tutorial/node10.html">http://www.mozart-oz.org/documentation/tutorial/node10.html</a></p>
</blockquote>

<p>Internally, objects are actually procedures which expect a single argument &mdash; hence this syntax.  When the object is sent a message (i.e. the procedure is called with a specific argument) it processes the message according to its definition.  This method definition may change its internal state, as we expect from typical objects.</p>

<h3><a name="sec75" id="sec75"></a>
Method call</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The following example creates a graphical user interface
button.  You do not need to understand the code which creates the
window itself (i.e., the call to QTk.build).  For our purposes here,
only this single line is important:

  {Window show}

`Window' is an object, and `show' is the name of the method understood by
this object.  This method results in showing the window with the button.

Please note that the syntax of a method differs clearly from the procedure
syntax shown before.  If `show' was a procedure, then we would write:

  {Show Window}
*/</span>

<span style="color: #a020f0;">local</span>
   Window = {QTk<span style="color: #a020f0;">.</span>build lr(button(text:<span style="color: #bc8f8f;">"Hello world!"</span>
                                 action:toplevel<span style="color: #a020f0;">#</span>close))}
<span style="color: #a020f0;">in</span>
   {Window show}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec76" id="sec76"></a>
Method arguments</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Class methods are actually records which can contain method
arguments.  For example, the following statement sends the following
message to the object Window.  This changes the width of the border around
the button and sets the background of this border to the color blue.

  {Window set(borderwidth:1.0#c background:blue)}

In general, the record denoting a message can wrap multiple arguments,
as in the following example where the method myMethod with two
arguments is send to the class MyObject.

   {MyObject myMethod(Arg1 Arg2 ..)}

We will later see many more method application examples in the context
of Strasheela's music representation. */</span>

<span style="color: #a020f0;">local</span>
   Window = {QTk<span style="color: #a020f0;">.</span>build lr(button(text:<span style="color: #bc8f8f;">"Hello world!"</span>
                                 action:toplevel<span style="color: #a020f0;">#</span>close))}
<span style="color: #a020f0;">in</span>
   {Window show}
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">change to button background color after 1000 msecs
</span>   {Delay 1000}
   {Window set(borderwidth:1<span style="color: #a020f0;">.</span>0<span style="color: #a020f0;">#</span>c
               background:blue)}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec77" id="sec77"></a>
Higher-Order Programming</h2>

<p class="first">Oz procedures (and functions) are first-class values.  This means that a procedure can be processed like any other value.  For example, procedures can be given to other procedures as arguments.</p>

<p>This leads to highly flexible programming technique called higher-order programming.  Procedures expecting procedures as arguments are called higher-order procedures.  This concept is demonstrated be several examples.</p>

<h3><a name="sec78" id="sec78"></a>
Filter</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The function Filter expects a list and a test function, and returns
only those elements for which the test function returns true.

The function IsEven returns true for even integers and thus a list
with only the even integers in [~3 ~2 ~1 0 1 2 3] is returned.  Try
replaying IsEven by IsOdd, IsNumber or IsNat (testing for natural
numbers) to better understand this filtering.

(BTW: there is a bug in IsOdd concerning negative numbers)
*/</span>

{Browse {Filter [<span style="color: #a020f0;">~</span> 4 <span style="color: #a020f0;">~</span>3 <span style="color: #a020f0;">~</span>2 <span style="color: #a020f0;">~</span>1 0 1 2 3] IsEven}}
</pre>


<h3><a name="sec79" id="sec79"></a>
ForAll</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The procedure ForAll applies a given procedure to any element of a
list.  In this example, the procedure Browse is applied to every list
element. */</span>

{ForAll [a b c d e f] Browse}
</pre>


<h3><a name="sec80" id="sec80"></a>
Map</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The function Map expects a list and a unary function (i.e. a
function expecting a single value) as arguments.  It applies the
function to every list element, and returns the collected results in a
list.

The example defines and uses the function square in order to square
all numbers in the list.  You may want to change this function to
understand that any function can be given to a higher-order function
as an argument.  For example, replace Square by a function Double,
which doubles its argument. */</span>

<span style="color: #a020f0;">local</span>
  <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Square</span> X} X <span style="color: #a020f0;">*</span> X <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
  {Browse {Map [1 2 3 4 5 6] Square}}
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec81" id="sec81"></a>
Anonymous procedure definition</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Sometimes we need a function only once -- as the function Square in
the previous example.  In such cases we don't necessarily need to care
about giving the function any name.  Instead, we can define an
anonymous function.

This example restates the previous example by defining the Square
function 'inline' without giving it any name.  Please recall that $
always denotes a return value.  In this case, $ returns the function
value itself. */</span>

{Browse
 {Map [1 2 3 4 5 6] <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X} X <span style="color: #a020f0;">*</span> X <span style="color: #a020f0;">end</span>}}
</pre>


<h3><a name="sec82" id="sec82"></a>
Sort (1)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">The function Sort expects a list and a binary function (i.e. a
function expecting two values) as arguments.  This binary function
compares two values, and Sort sorts the list values according to this
comparison.  For example, the function in the example compares two
numbers and returns true if the first number is smaller.  Consequently,
this example sorts the list elements in ascending order.  You may want
to replace the &lt; by &gt; in the function definition to sort the
numbers in decreasing order. */</span>

{Browse {Sort [1 5 3 2 0 7] <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X Y}  X <span style="color: #a020f0;">&lt;</span> Y <span style="color: #a020f0;">end</span>}}
</pre>


<h3><a name="sec83" id="sec83"></a>
Sort (2)</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">You can actually sort the list elements in any way you want using
the Sort function.  For example, you may place all even numbers at the
beginning and all odd numbers at the end of the list and sort all even
and odd numbers in ascending order.  This is done in the second
(commented) Sort call.  How does this sorting work? */</span>

{Browse {Sort [1 5 3 2 0 7] <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> X Y}
                              <span style="color: #a020f0;">if</span> {IsEven X}
                              <span style="color: #a020f0;">then</span>
                                <span style="color: #a020f0;">if</span> {IsEven Y}
                                <span style="color: #a020f0;">then</span> X <span style="color: #a020f0;">&lt;</span> Y
                                <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">true</span>
                                <span style="color: #a020f0;">end</span>
                              <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">false</span>
                              <span style="color: #a020f0;">end</span>
                            <span style="color: #a020f0;">end</span>}}
</pre>


<h3><a name="sec84" id="sec84"></a>
Defining higher-order procedures</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Higher order procedures are defined like any other procedure: some
arguments are simply procedures -- which are then usually applied in
the definition.  This example defines a higher-order function Find
which expects a list Xs and a test function Fn: Find returns the first
element in Xs for which Fn returns true.

This example also demonstrates the pattern-matching case statement
with multiple clauses operating on the list Xs.  In case Xs is the
empty list nil, then Find returns nil.  Otherwise (multiple clauses are
separated with the keyword []), Xs is matched with X|Xr, where X is
bound to the first element of Xs and Xr to the list's tail or
rest.  The function Find then checks whether {Fn X} returns true.  In
that case, the searched for list element has been found and is
returned.  Otherwise, Find is called recursively with the rest of the
list. */</span>

<span style="color: #a020f0;">local</span>
   <span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">Find</span> Xs Fn}
      <span style="color: #a020f0;">case</span> Xs
      <span style="color: #a020f0;">of</span> nil <span style="color: #a020f0;">then</span> nil
      <span style="color: #a020f0;">[]</span> X<span style="color: #a020f0;">|</span>Xr
      <span style="color: #a020f0;">then</span> <span style="color: #a020f0;">if</span> {Fn X} <span style="color: #a020f0;">then</span> X
           <span style="color: #a020f0;">else</span> {Find Xr Fn}
           <span style="color: #a020f0;">end</span>
      <span style="color: #a020f0;">end</span>
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">in</span>
   {Browse {Find  [1 2 3 4 5 6] IsEven}}
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec85" id="sec85"></a>
Concurrency</h2>

<p class="first">Oz provides excellent support for concurrent programming, where computations run in parallel in multiple threads.  We will only touch on this subject and discuss aspects relevant for Strasheela.  In general, however, concurrent programming plays a major role in Oz programming.</p>

<p>The computations in different threads can communicate with each other via variables.  Multiple threads can use the same variable in a computation.  If the value of a variable does not present enough information for performing a specific operation, then the thread simply blocks and waits for more information.  In the example below, the addition X+3 can not be performed as long as the value of X is unknown.  As soon as more information about the variable value is available, the thread resumes its execution.</p>

<p>This behaviour leads to a concurrent programming model which is highly declarative &mdash; and thus easy to program in.  We will later see how this model simplifies the definition of complex musical constraint satisfaction problems (Oz' constraint programming model is based on concurrent programming).</p>

<p>The downside of this concurrency model is that it can result in an unintended blocking of a program which is not explicitly signalled (e.g. no error message is shown when a program blocks, because this is a normal program behaviour).  The second and third example below demonstrate a pragmatic way to deal with this downside.</p>

<p>The examples demonstrates concurrent programming, but do not show a typical application (a typical application would be a program split in a server and one or more clients).  In the context of Strasheela, we will seldomly write concurrent programs explicitly.  Nevertheless, it is very important to know how concurrent programming works in Oz.  Even if we are not explicitly writing a concurrent program, constraint programming in Oz always results in a concurrent program.  Concurrent programming forms one of the foundations of Oz' constraint programming model, where each constraint (i.e. each propagator) is a concurrent agent running in its own thread.</p>


<h3><a name="sec86" id="sec86"></a>
Declarative concurrency</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">This example declares X and then browses 'hello' (just to show that
the browser works in principle).  However, the addition X+3 can not be
executed immediately and blocks.  Because this computation is executed
in its own thread, the top-level thread continues regardless, and
calls the procedure Delay, which waits for 3000 msecs.  After that
time, the top-level thread determines X to 4.  This awakes the other
thread: it can now compute X+3 and browse the sum. */</span>

<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #a020f0;">thread</span> {Browse X <span style="color: #a020f0;">+</span> 3} <span style="color: #a020f0;">end</span>
  {Delay 3000}
  X = 4
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec87" id="sec87"></a>
Blocking computation</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">This example demonstrates a buggy program which does not signal any
error but simply does nothing.  The example is very similar to the
previous example, but does not place the blocking X+3 in its own
thread.  As a result, the whole program blocks at that point and never
executes X = 4. */</span>

<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>
</pre>


<h3><a name="sec88" id="sec88"></a>
'Signalling' a blocking computation</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">This example demonstrates a pragmatic approach which checks for
blocking programs.  The example ends with the statement {Browse
endOfProgram}.  A non-blocking program will always execute this last
line of code and show 'endOfProgram' in the Browser.  However, a
blocking program (as the present one) does not do that and thus
indicates that it is blocking.  Although this little trick does not
tell us *where* the program blocks, the information *that* we wrote a
blocking program can prove very helpful already.  You may get a feel
for this trick by changing the example so that the message
'endOfProgram' is shown (e.g. comment the blocking statement out, or
surrounding it with a 'thread .. end' statement). */</span>

<span style="color: #a020f0;">local</span>
  X
<span style="color: #a020f0;">in</span>
  {Browse hello}
  <span style="color: #b22222;">%% </span><span style="color: #b22222;">!! blocks
</span>  {Browse X<span style="color: #a020f0;">+</span>3}
  X = 4
<span style="color: #a020f0;">end</span>
{Browse endOfProgram}
</pre>



<h2><a name="sec89" id="sec89"></a>
Understanding error messages</h2>

<p class="first">When we do program, we almost inevitably write bugs
sometimes.  Luckily, when confronted with specific problems in
programs, compilers try to tell us about the problem (naturally, the
real hard bugs are the ones no compiler complains about).  All errors
are actually raised exceptions (see the Tutorial of Oz, Sec. 5.10 for
more details).</p>

<p>The compiler is your friend, so this example introduces you to some
typical Oz error messages ;-) During your programming sessions,
carefully reading error messages can save you much time.  In this
tutorial, all these messages are shown at the shell (or in the DOS
box) where you started the tutorial.  The Oz Programming Interface
(OPI) even supports moving to the code where the bug is likely to be
located (see the Tutorial of Oz, Sec. 2.3.3).</p>

<p>BTW: the error messages of this tutorial are slightly obscured
unfortunately by some trick which keeps the tutorial application
running even in the case of an error: there are always a few lines of
other code before the actual error message.  Also, the reported line
number is not correct, because the tutorial application adds a few
lines to each example (the resulting full example is shown just before
the error message).</p>


<h3><a name="sec90" id="sec90"></a>
Parse error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">The left curly brace does not match the right parenthesis
</span>
{Browse hello)
</pre>


<h3><a name="sec91" id="sec91"></a>
Static analysis error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Browse expects only a single argument
</span>
{Browse hi there}
</pre>


<h3><a name="sec92" id="sec92"></a>
Binding analysis error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">Variable X is not declared
</span>
X = 3
</pre>


<h3><a name="sec93" id="sec93"></a>
Type error</h3>

<pre class="src">
<span style="color: #b22222;">%% </span><span style="color: #b22222;">We can not add an integer and a float
</span>
{Browse 3 <span style="color: #a020f0;">+</span> 2<span style="color: #a020f0;">.</span>0}
</pre>


<h3><a name="sec94" id="sec94"></a>
Failure</h3>

<pre class="src">
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Inconsistent constraint programs result in a failure.  Failures play
an important role internally in a constraint solver searching for
solutions to a constraint satisfaction problem. */</span>

<span style="color: #a020f0;">local</span>
   X = 3
<span style="color: #a020f0;">in</span>
   3 <span style="color: #a020f0;">+</span> 4 <span style="color: #a020f0;">=:</span> X
<span style="color: #a020f0;">end</span>
</pre>




<!-- Page published by Emacs Muse ends here -->
<!-- Footer -->
<div id="footer">
<div id="author">&copy; 
Torsten Anders</div>
<div id="date">Last time edited: 2007.12.07</div>
</div>
  </body>
</html>
