<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Realtime Constraint Programming: A Simple Counterpoint Example</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
<div id="header">
  <ul class="nav">
    <li class="nav1"><a href="index.html">home</a></li>
    <li class="navn"><a href="https://sourceforge.net/projects/strasheela/">download at sourceforge</a></li>
    <!-- <li class="navn"><a href="IndexOfPages.html">site map</a></li> -->
    <li class="navn"><a href="contact.html">contact</a></li>
  </ul>
  <div id="logo">
    <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=167225&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </div>
</div>
    <h1>Realtime Constraint Programming: A Simple Counterpoint Example</h1>
    <!-- Page published by Emacs Muse begins here -->








<p><a href="StrasheelaExamples.html">back</a></p>

<div class="contents">
<dl>
<dt>
<a href="#sec1">Communication Between Strasheela and Supercollider via OSC</a>
</dt>
<dd>
<dl>
<dt>
<a href="#sec2">Strasheela OSC Interface</a>
</dt>
<dt>
<a href="#sec3">Supercollider OSC Interface</a>
</dt>
</dl>
</dd>
<dt>
<a href="#sec4">Defining Sound Playback in Supercollider</a>
</dt>
<dt>
<a href="#sec5">Defining the CSP in Strasheela</a>
</dt>
<dt>
<a href="#sec6">Transforming OSC Packets to a Strasheela Score and Back</a>
</dt>
<dt>
<a href="#sec7">Calling a Realtime Capable Constraint Solver</a>
</dt>
<dt>
<a href="#sec8">Defining a Voice Generation Routine in Supercollider</a>
</dt>
<dt>
<a href="#sec9">Getting is Running</a>
</dt>
<dt>
<a href="#sec10">Discussion</a>
</dt>
</dl>
</div>


<p>This example demonstrates how Strasheela can be used in realtime &mdash; interoperating with <a href="http://supercollider.sourceforge.net/">SuperCollider</a>. Supercollider algorithmically generates a single voice using Supercollider patterns. The notes of this voice are send to Strasheela via <a href="http://www.cnmat.berkeley.edu/OpenSoundControl/">Open Sound Control</a> (OSC). Strasheela considers this voice the cantus firmus and creates a fitting counterpoint for it in realtime. Strasheela sends the counterpoint back to Supercollider (again via OSC), and Supercollider plays both voices synchronously (with a small latency).</p>

<p>The example implements a very simple variant of first species counterpoint. The counterpoint is homophonic to the cantus firmus. However, in this example the cantus firmus is rhythmically free. The CSP implements the following rules for the second voice.</p>

<ul>
<li>Harmonic rule: simultaneous notes must be consonant (perfect or imperfect consonance).</li>

<li>Melodic rule on generated voice: only specific intervals are allowed.</li>

<li>Melodic rule: the generated melody stays in C major (like the cantus).</li>
</ul>






<center>
<p><a href="sound/realtime-counterpoint-excerpt.mp3">Sound example (excerpt)</a></p>
</center>

<p>The core idea of the realtime constraint solver demonstrated by this example is very simple. It conducts a search like a normal Oz solver. However, it is given a maximum search time. If no solution is found after this maximum search time (or if the search failed), then a user-defined default solution is returned. That way, the solver is never busy for too long and always responses to new input. In this example, the default solution is <code>nil</code>, and in case of a timeout or fail, a note is simply omitted.
The maximum search time is compensated for by a latency which delays all notes of the example (i.e. the cantus firmus generated by Supercollider and the counterpoint from Strasheela). If the maximum search time and the latency is high enough, the search should never time out nor fail in this example. No dropped note (no timeout) nor any late note were produced by this example with 10 msec maximum search time and 35 msec latency (for OSC network traffic) on a Macbook Pro 2.2GHz.</p>

<p>Please note that the code examples below are partly Strasheela code and partly Supercollider code. However, the language is always indicated. The full implementation of the example presented here is also available as source, split into two source files: one <a href="../contributions/anders/Realtime/examples/Simple-Counterpoint.sc">Supercollider source</a> file and one <a href="../contributions/anders/Realtime/examples/Simple-Counterpoint.oz">Strasheela source</a> file.
The explanation below is quite detailed: you can see it as a mini tutorial how realtime constraint programming can be done with Strasheela.</p>


<h2><a name="sec1" id="sec1"></a>
Communication Between Strasheela and Supercollider via OSC</h2>

<p class="first">This section explains how the communication between Strasheela and Supercollider is set up. We will first look at Strasheela, and then at Supercollider. In later sections, we will customise the definitions of the present section to specify what Strasheela and Supercollider actually do when receiving OSC in this example.</p>

<h3><a name="sec2" id="sec2"></a>
Strasheela OSC Interface</h3>

<p class="first">Strasheela currently uses the UNIX applications <code>sendOSC</code> and <code>dumpOSC</code> (available <a href="http://www.cnmat.berkeley.edu/OpenSoundControl/">here</a>) for its OSC interface. Hence, the OSC interface (and also this example) is only supported on UNIX systems (e.g., Linux or MacOS X). Firstly, we must load the Strasheela functors required for realtime constraint programming. <code>ModuleLink</code> should be defined in your Oz initialisation file (cf. <a href="../_ozrc">../_ozrc</a>), and you may add the following code to this file as well. Please remember that variables (e.g., <code>OSC</code> and <code>RT</code>) must be declared first (e.g., by preceding the keyword <code>declare</code> at the beginning of your Oz initialisation file).</p>

<pre class="src">
[OSC RT] = {ModuleLink [<span style="color: #bc8f8f;">'x-ozlib://anders/strasheela/OSC/OSC.ozf'</span>
                        <span style="color: #bc8f8f;">'x-ozlib://anders/strasheela/Realtime/Realtime.ozf'</span>]}
</pre>

<p>The following four lines set up OSC input at port 7777 and output to port 57120 (the port of sclang, the Supercollider language application).<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup></p>

<pre class="src">
OutPort = 57120                 <span style="color: #b22222;">% </span><span style="color: #b22222;">sclang port
</span>InPort = 7777
MySendOSC = {New OSC<span style="color: #a020f0;">.</span>sendOSC init(port:OutPort)}
MyDumpOSC = {New OSC<span style="color: #a020f0;">.</span>dumpOSC init(port:InPort)}
</pre>

<h4>Testing</h4>

<p class="first">We can test the Strasheela OSC interface by setting OutPort and InPort to the same number, so that Strasheela sends OSC packets to itself.</p>

<pre class="src">
OutPort = InPort = 1234
MySendOSC = {New OSC<span style="color: #a020f0;">.</span>sendOSC init(port:OutPort)}
MyDumpOSC = {New OSC<span style="color: #a020f0;">.</span>dumpOSC init(port:InPort)}
</pre>

<p>The following code line will cause Strasheela to browse all OSC package received at port <code>InPort</code>. The method <code>getOSCs</code> returns a stream of packages (i.e. a list whose tail is unbound and which can therefore be extended).</p>

<pre class="src">
{Browse {MyDumpOSC getOSCs($)}}
</pre>

<p>Instead, the next line installs an OSC responder which reacts only to messages with the address pattern '/note'. Whenever a message with this address is received, the corresponding procedure is called. Here, the procedure also just browses the message. The responder also receives a timetag, which is 1 in case a single message was sent. In case the message was sent within a bundle, then the timetag of the enclosing bundle is received. See below for details.</p>

<pre class="src">
{MyDumpOSC setResponder(<span style="color: #bc8f8f;">'/note'</span> <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> Timetag Msg} {Browse responder<span style="color: #a020f0;">#</span>Msg} <span style="color: #a020f0;">end</span>)}
</pre>

<p>OSC messages may contain strings, which are not properly displayed by the Browser by default (remember that strings are just lists of character, which in turn are just integers). You can customise the Browser either via its GUI (in menu &quot;Options&quot;, entry &quot;Representation...&quot; tick Strings), or feed the following line.</p>

<pre class="src">
{Browser<span style="color: #a020f0;">.</span>object option(representation strings:<span style="color: #a020f0;">true</span>)}
</pre>

<p>Now, we are ready to send test messages from <code>MySendOSC</code> to <code>MyDumpOSC</code>. The <code>'\note'</code> parameters of this example are only intended for testing, and have no further meaning.</p>

<pre class="src">
{MySendOSC send(test(some <span style="color: #bc8f8f;">"test message"</span>))}
{MySendOSC send(<span style="color: #bc8f8f;">'/note'</span>(0 1 2<span style="color: #a020f0;">.</span>0))}
</pre>

<p>Please note that OSC messages are expressed simply by Oz tuples for the <code>send</code> method, and the the received messages have the same format. The Strasheela interface also supports OSC bundles, including timetags. A bundle is a list, and the first bundle element is optionally a timetag. Bundles can be nested. Different timetag formats are supported, but the default is an integer denoting the milliseconds since midnight UTC of January 1, 1970. The following example sends a bundle with a timetag 1000 msec later than now and a single message. Please see the <a href="../contributions/anders/OSC/doc/node1.html">documentation</a> for further details on the format of OSC packets in Strasheela.</p>

<pre class="src">
{MySendOSC send([{OSC<span style="color: #a020f0;">.</span>timeNow} <span style="color: #a020f0;">+</span> 1000
                 <span style="color: #bc8f8f;">'/note'</span>(0 1 2<span style="color: #a020f0;">.</span>0)])}
</pre>




<h3><a name="sec3" id="sec3"></a>
Supercollider OSC Interface</h3>

<p class="first">We now come to the Supercollider side of our communication process. Supercollider already receives OSC per default at the port 57120. We only need to define what Supercollider should do when it receives OSC packets (see below). The following two lines define an interface for sending OSC.</p>

<pre class="src">
<span style="color: #b8860b;">~outPort</span> = 7777;
<span style="color: #b8860b;">~mySendOSC</span> = <span style="color: #228b22;">NetAddr</span>(<span style="color: #bc8f8f;">"localhost"</span>, <span style="color: #b8860b;">~outPort</span>);
</pre>


<h4>Testing</h4>

<p class="first">Assuming that OSC messages are still browsed on the Strasheela side, we can test the communication from Supercollider to Strasheela with the following code.</p>

<pre class="src">
<span style="color: #b8860b;">~mySendOSC</span>.sendMsg(<span style="color: #5f9ea0;">'test'</span>, <span style="color: #5f9ea0;">'some'</span>, <span style="color: #bc8f8f;">"test message"</span>);
<span style="color: #b8860b;">~mySendOSC</span>.sendMsg(<span style="color: #5f9ea0;">'/note'</span>, 0, 1, 2.0);
</pre>

<p>Finally, we test sending OSC from Strasheela to Supercollider. The following Supercollider code defines a function which is called whenever Supercollider receives any OSC message. This function simply prints any received message. However, once Supercollider's localhost synthesis server <code>scsynth</code> is started, it also sends OSC messages to the Supercollider language application. As we are not interested in the messages from the <code>scsynth</code>, the <code>if</code> conditional ensures that those messages do not cause any additional action.</p>

<pre class="src">
<span style="color: #a020f0;">thisProcess</span>.recvOSCfunc = { <span style="color: #a020f0;">arg</span> time, addr, msg;
    <span style="color: #0000ff;">if</span> ( addr.port != 57110, <span style="color: #b22222;">// </span><span style="color: #b22222;">ignore scsynth messages
</span>    { msg.postln; })
};
</pre>

<p>We send OSC messages from Strasheela as before.</p>

<pre class="src">
{MySendOSC send(test(some <span style="color: #bc8f8f;">"test message"</span>))}
{MySendOSC send(<span style="color: #bc8f8f;">'/note'</span>(0 1 2<span style="color: #a020f0;">.</span>0))}
</pre>





<h2><a name="sec4" id="sec4"></a>
Defining Sound Playback in Supercollider</h2>

<p class="first">This section defines the sound playback in Supercollider. We define a very simple synthesis instrument: a saw oscillator which is filtered by a resonating low-pass filter. However, before we do that, we need to start Supercollider's localhost server.</p>

<pre class="src">
s.boot;
</pre>

<p>The following code defines our 'synth' and sends it to the server. The synth expects the following optional parameters: the duration <code>dur</code> (measured in secs), the pitch <code>freq</code> (measured in Hz), the loudness <code>amp</code> (a float in the interval [0,1]), and the filter cutoff-frequency <code>ffreq</code> (also measured in Hz). If you don't know the Supercollider language, please refer to the Supercollider documentation for understanding this definition.</p>

<pre class="src">
<span style="color: #228b22;">SynthDef</span>(<span style="color: #bc8f8f;">"Strasheela-playback"</span>, { <span style="color: #a020f0;">arg</span> dur=1, freq=440, amp=0.3, ffreq=1000;
  <span style="color: #a020f0;">var</span> env = <span style="color: #228b22;">EnvGen</span>.<span style="color: #0000ff;">kr</span>(<span style="color: #228b22;">Env</span>.perc(0.05, dur-0.05, 1, -2), 1.0, <span style="color: #b8860b;">doneAction:</span> 2);
  <span style="color: #228b22;">Out</span>.<span style="color: #0000ff;">ar</span>(0, <span style="color: #228b22;">RLPF</span>.<span style="color: #0000ff;">ar</span>(<span style="color: #228b22;">Saw</span>.<span style="color: #0000ff;">ar</span>(freq, amp*env), ffreq, 0.1))
}).send(s);
</pre>

<p>We test our synth &quot;Strasheela-playback&quot; with the following call.</p>

<pre class="src">
<span style="color: #228b22;">Synth</span>(<span style="color: #bc8f8f;">"Strasheela-playback"</span>, [<span style="color: #5f9ea0;">\dur</span>, 3, <span style="color: #5f9ea0;">\freq</span>, 72.midicps, <span style="color: #5f9ea0;">\amp</span>, 1, <span style="color: #5f9ea0;">\ffreq</span>, 2000]);
</pre>

<p>In the example, the two different voices will use different filter settings in order to make them better distinguishable.</p>



<h2><a name="sec5" id="sec5"></a>
Defining the CSP in Strasheela</h2>

<p class="first">We now define the actual constraint satisfaction problem. The following rules are defined in exactly the same way as rules for non-realtime CSPs. To keep the example simple, only very few rules are defined. Nevertheless, these rules make multiple score contexts interdependent (namely pairs of neighbouring melodic notes, and simultaneous notes), and that way result in a true search problem (although the problem is rather simple).</p>

<p>A harmonic rule &mdash; stating that simultaneous notes must be consonant &mdash; is implemented by two procedures. The procedure <code>IsConsonance</code> defines the actual rule, and the procedure <code>GetInterval</code> makes the definition of this and the rule more simple. <code>GetInterval</code> expects two notes and returns a fresh finite domain integer (FD int), constrained to the absolute distance between the pitches of these notes.</p>

<pre class="src">
<span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">GetInterval</span> Note1 Note2 Interval}
   Interval = {FD<span style="color: #a020f0;">.</span>decl}
   {FD<span style="color: #a020f0;">.</span>distance {Note1 getPitch($)} {Note2 getPitch($)} <span style="color: #bc8f8f;">'=:'</span> Interval}
<span style="color: #a020f0;">end</span>
</pre>

<p><code>IsConsonance</code> constrains the interval between two simultaneous notes (a FD int) to a perfect or imperfect consonance up to an octave plus a major third at maximum. Note that the unison (<code>Interval</code> equals 0) is not permitted.</p>

<pre class="src">
<span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">IsConsonance</span> Interval}
   Interval <span style="color: #a020f0;">::</span> [3 4 7 8 9 12 15 16]
<span style="color: #a020f0;">end</span>
</pre>

<p>The melodic rule <code>RestrictMelodicInterval</code> is very similar to <code>IsConsonance</code>: it expects the interval between two successive melodic notes (a FD int) and constrains it to either anything between a minor second and a fourth, or to a fifth, or to an octave. Again, the interval 0 (i.e. pitch repetition) is not permitted.</p>

<pre class="src">
<span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">RestrictMelodicInterval</span> Interval}
   Interval <span style="color: #a020f0;">::</span> [1<span style="color: #a020f0;">#</span>5 7 12]
<span style="color: #a020f0;">end</span>
</pre>

<p>Finally, the rule <code>IsDiatonic</code> restricts the domain of a single note to pitch classes of the  C major scale.</p>

<pre class="src">
<span style="color: #a020f0;">local</span>
   ScalePCs = [0 2 4 5 7 9 11] <span style="color: #b22222;">% </span><span style="color: #b22222;">list of pitch classes in c-major scale
</span><span style="color: #a020f0;">in</span>
   <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">IsDiatonic</span> MyNote}
      {FD<span style="color: #a020f0;">.</span>modI {MyNote getPitch($)} 12} <span style="color: #a020f0;">::</span> ScalePCs
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec6" id="sec6"></a>
Transforming OSC Packets to a Strasheela Score and Back</h2>

<p class="first">In this example, Strasheela receives OSC packets from Supercollider and sends OSC packets back. However, internally Strasheela uses its own music representation. This section shows how single notes in both representations can be transformed into each other. For a CSP as simple as the present one this is not really required, we could instead use OSC messages directly. However, Strasheela's music representation provides a rich interface which can simplify the definition of more complex realtime CSPs with a more complex input or output score, and therefore such a transformation is worth showing. Moreover, using Strasheela's music representation we can also use Strasheela's score distribution strategies &mdash; which allow for a randomised variable value selection.</p>

<p>The transformations shown below depend on the variable <code>Now</code>. <code>Now</code> is bound to some value which serves as reference for the start time 0. The function <code>OSC.timeNow</code> returns the number of milliseconds since midnight UTC of January 1, 1970 (an int).</p>

<pre class="src">
Now = {OSC<span style="color: #a020f0;">.</span>timeNow}
</pre>

<p>The function <code>MakeScoreNote</code> expects a <code>Timetag</code> and an OSC message representing a note. It returns a corresponding Strasheela note object. Supercollider sends the note parameters in the correct unit of measurement (temporal parameters are measured in msecs, <code>Pitch</code> is a MIDI key-number, and <code>Amplitude</code> is a MIDI velocity &mdash; all values are integers). Note that the note's start time is the <code>Timetag</code> minus <code>Now</code> (the <code>Timetag</code> itself is beyond the domain of a FD int). When a note is transformed back to OSC, <code>Now</code> is added to the note's start time (see below).</p>

<pre class="src">
<span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">MakeScoreNote</span> Timetag <span style="color: #bc8f8f;">'/note'</span>(Duration Pitch Amplitude)}
   {Score<span style="color: #a020f0;">.</span>makeScore note(startTime: Timetag <span style="color: #a020f0;">-</span> Now
                         duration: Duration
                         pitch: Pitch
                         amplitude: Amplitude
                         timeUnit:msecs)
    <span style="color: #a020f0;">unit</span>}
<span style="color: #a020f0;">end</span>
</pre>

<p>The corresponding function <code>MakeOSCNote</code> expects a Strasheela note object and returns an OSC bundle representing the note. The note's start time plus <code>Now</code> is the bundle's timetag. The note duration is transformed into seconds (a float) for more easy processing at the Supercollider side.</p>

<pre class="src">
<span style="color: #a020f0;">fun</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">MakeOSCNote</span> MyNote}
   [{MyNote getStartTime($)} <span style="color: #a020f0;">+</span> Now
    <span style="color: #bc8f8f;">'/note'</span>({MyNote getDurationInSeconds($)}
            {MyNote getPitch($)}
            {MyNote getAmplitude($)})]
<span style="color: #a020f0;">end</span>
</pre>



<h2><a name="sec7" id="sec7"></a>
Calling a Realtime Capable Constraint Solver</h2>

<p class="first">This section finally shows the most interesting part of the example: how a constraint solver is called in realtime. We first define the constraint script, then create a constraint solver object for the script, and finally define an OSC responder which generates the next counterpoint note whenever it receives a cantus firmus note by calling the solver with its script again.</p>

<p>The structure of the following script definition is very similar to the scripts of non-realtime CSPs shown by other examples before. New is only the script argument <code>Args</code>, which is a record providing the script with multiple CSP parameters. The arguments of the procedure <code>MyScript</code> are its solution (here a single note <code>NewNote</code>) and a record of script parameters. We may call a script with two arguments an 'extended script'.</p>

<p><code>MyScript</code> accesses two arguments from <code>Args</code>: the note which is simultaneous to <code>NewNote</code> and the melodic predecessor of <code>NewNote</code>. The simultaneous note is the note coming from Supercollider: the OSC responder hands this note to the scripts argument <code>Args.inputScore</code> (see below). The melodic predecessor note is the solution of the previous call of the CSP. Previous solutions (and previous input) are collected automatically by the solver and are made available in reverse order at the scripts argument <code>Args.outputScores</code> (respectively <code>Args.inputScores</code>).<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup></p>

<pre class="src">
<span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">MyScript</span> Args NewNote}
   SimNote = Args<span style="color: #a020f0;">.</span>inputScore
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">PrevNote can be nil (for first note and in case of no solution)
</span>   PrevNote = Args<span style="color: #a020f0;">.</span>outputScores<span style="color: #a020f0;">.</span>1 <span style="color: #b22222;">% </span><span style="color: #b22222;">immediate predecessor of NewNote
</span><span style="color: #a020f0;">in</span>
   NewNote = {Score<span style="color: #a020f0;">.</span>makeScore note(startTime:{SimNote getStartTime($)}
                                   duration:{SimNote getDuration($)}
                                   pitch:{FD<span style="color: #a020f0;">.</span>int 48<span style="color: #a020f0;">#</span>72}  <span style="color: #b22222;">% </span><span style="color: #b22222;">MIDI key-number
</span>                                   amplitude:64  <span style="color: #b22222;">% </span><span style="color: #b22222;">MIDI velocity
</span>                                   timeUnit:msecs)
              <span style="color: #a020f0;">unit</span>}
   <span style="color: #b22222;">%% </span><span style="color: #b22222;">three simple rules
</span>   {IsDiatonic NewNote}
   {IsConsonance {GetInterval SimNote NewNote}}
   <span style="color: #a020f0;">if</span> PrevNote <span style="color: #a020f0;">\=</span> nil
   <span style="color: #a020f0;">then</span> {RestrictMelodicInterval {GetInterval NewNote PrevNote}}
   <span style="color: #a020f0;">end</span>
<span style="color: #a020f0;">end</span>
</pre>

<p>The rest of <code>MyScript</code> is strait forward. A note object is created and bound to <code>NewNote</code> and the rules shown before are applied to this note and its simultaneous note (or its melodic predecessor). Please observe that the constraint <code>RestrictIntervalDomain</code> is only applied in case the previous note is not <code>nil</code> (which is the case for the very first note and happens if the previous CSP call found no solution, see below).</p>

<p>As mentioned above, a maximum search time is given to the constraint solver. If no solution is found within that time, or if the search failed, then a default solution is returned. The following code defines the constraint solver object <code>MySearcher</code>, an instance of the class <code>RT.scoreSearcherWithTimeout</code>. The solver is an object, because it maintains an internal state between solver calls (e.g., the previous solutions). The solver is given the constraint script <code>MyScript</code>, a maximum search time of 30 msecs, and the default solution <code>nil</code>. Additionally, the list of initial output scores is specified as <code>[nil]</code> (i.e. the previous note of the very first note is <code>nil</code>), and the value selection of the score distribution is randomised.<sup><a class="footref" name="fnr.3" href="#fn.3">3</a></sup> See the <a href="../contributions/anders/Realtime/doc/node1.html">RT documentation</a> for additional information on <code>RT.scoreSearcherWithTimeout</code>.</p>

<pre class="src">
MySearcher = {New RT<span style="color: #a020f0;">.</span>scoreSearcherWithTimeout
              init(MyScript
                   maxSearchTime:30     <span style="color: #b22222;">% </span><span style="color: #b22222;">in msec
</span>                   defaultSolution:nil
                   outputScores:[nil]
                   distroArgs:<span style="color: #a020f0;">unit</span>(value:random))}
</pre>


<p>The following OSC responder reacts to OSC messages with the address pattern '/note'. Any received note message is first transformed into a Strasheela note using the function <code>MakeScoreNote</code> (see above, the OSC responder takes for granted that note messages have the format suitable for the function <code>MakeScoreNote</code>). Then, the constraint solver <code>MySearcher</code> is called: the method <code>next</code> invokes the solver and returns the next solution &mdash; in this example the next counterpoint note. Arbitrary arguments can be handed to the scripts <code>Args</code> argument (see above) by handing them as arguments to the solver's <code>next</code> method. We use this mechanism to forward the freshly received note <code>SimNote</code> to the script. Finally, the solver's output is tested whether it is the default solution <code>nil</code> (i.e., whether a timeout or failure happened). If this is not the case, then the note output by the solver is transformed into an OSC bundle (using <code>MakeOSCNote</code>, see above) and send to Supercollider.</p>

<pre class="src">
{MyDumpOSC setResponder(<span style="color: #bc8f8f;">'/note'</span> <span style="color: #a020f0;">proc</span><span style="color: #b8860b;"> </span>{<span style="color: #0000ff;">$</span> Timetag Msg}
                                   <span style="color: #b22222;">%% </span><span style="color: #b22222;">optional, for debugging
</span>                                   <span style="color: #b22222;">%% </span><span style="color: #b22222;">{Browse input#Start#Msg}
</span>                                   <span style="color: #b22222;">%% </span><span style="color: #b22222;">OSC to Strasheela note
</span>                                   SimNote = {MakeScoreNote Timetag Msg}
                                   <span style="color: #b22222;">%% </span><span style="color: #b22222;">call solver
</span>                                   NewNote = {MySearcher next($ inputScore:SimNote)}
                                <span style="color: #a020f0;">in</span>
                                   <span style="color: #a020f0;">if</span> NewNote <span style="color: #a020f0;">\=</span> nil
                                   <span style="color: #a020f0;">then</span> <span style="color: #b22222;">%% </span><span style="color: #b22222;">transform note to OSC and send it back
</span>                                      {MySendOSC send({MakeOSCNote NewNote})}
                                   <span style="color: #a020f0;">else</span> {Browse <span style="color: #bc8f8f;">'no solution found'</span>}
                                   <span style="color: #a020f0;">end</span>
                                <span style="color: #a020f0;">end</span>)}
</pre>



<h2><a name="sec8" id="sec8"></a>
Defining a Voice Generation Routine in Supercollider</h2>

<p class="first">The rest of this example is defined in Supercollider. The cantus firmus of this example is generated algorithmically in Supercollider by a number of patterns. A Supercollider pattern serves the creation of a sequence of values, possibly of infinite length. Patterns are often used to describe various parameters of a note sequence. In this section, we will define a pattern for each of the following note parameters: note durations, pitches and amplitudes. The explanation of these patterns will be brief, please see the Supercollider documentation for more information on its patterns.</p>

<p>For the sake of simplicity, the first pattern is extremely simple: all note amplitudes have the MIDI velocity 64.</p>

<pre class="src">
<span style="color: #b8860b;">~amps</span> = 64.asStream;
</pre>

<p>The pattern for the durations is slightly more complex. The pattern randomly selects from three different sequence patterns. These sequence patterns are chosen such that the resulting durations always express a triple meter. For example, in each of these sequence patterns all its values sum up to three. The note durations are measured in seconds, but the pattern values will later be multipled by some tempo factor (see below).</p>

<pre class="src">
<span style="color: #b8860b;">~durs</span> = <span style="color: #228b22;">Prand</span>([<span style="color: #228b22;">Pseq</span>([2.0, 1.0]), <span style="color: #228b22;">Pseq</span>([1.0, 1.0, 1.0]), 3.0], <span style="color: #da70d6;">inf</span>).asStream;
</pre>

<p>The pitch pattern performs a random walk through the pitches in the C major scale, expressed by MIDI key-numbers. The walk starts at the tonic 60 (the third element, using zero-based indexing), the maximum pitch interval is a fourth up or downwards, but small intervals are preferred.</p>

<pre class="src">
<span style="color: #b8860b;">~pitches</span> = <span style="color: #228b22;">Pwalk</span>(<span style="color: #b22222;">// </span><span style="color: #b22222;">pitches in C major from g to c over 1 1/2 octaves
</span>                 [55, 57, 59, 60, 62, 64, 65, 67, 69, 71, 72],
                 <span style="color: #b22222;">// </span><span style="color: #b22222;">steps up to 3 in either direction, but no repetition,
</span>                 <span style="color: #b22222;">// </span><span style="color: #b22222;">and weighted toward positive
</span>                 <span style="color: #228b22;">Pwrand</span>([-3, -2, -1, 1, 2, 3],
                        [0.02, 0.05, 0.4, 0.4, 0.1, 0.03].normalizeSum, <span style="color: #da70d6;">inf</span>),
                 1,     <span style="color: #b22222;">// </span><span style="color: #b22222;">reverse direction at boundaries
</span>                 3      <span style="color: #b22222;">// </span><span style="color: #b22222;">start at tonic
</span>         ).asStream;
</pre>



<h2><a name="sec9" id="sec9"></a>
Getting is Running</h2>

<p class="first">Finally, this section starts the note generation process in Supercollider, sends and receives notes from Strasheela, and sends all notes to Supercollider's sound generation program <code>scsynth</code> for playback.</p>

<p>The following code segment generates the cantus firmus by using the patterns defined before. It defines a routine <code>~myRoutine</code>, whose body is an infinite loop. Each loop iteration fetches a value from each of the above patterns (using the method <code>next</code>), uses these values to construct a new note which is send as message to Strasheela and played back on the scsynth. The loop then waits for the duration of the note, before constructing and sending the next note.</p>

<p>Please note the two variables <code>~latency</code> and <code>~tempoFactor</code>. The tempo factor is simply a factor for the note durations, allowing to speed up or slow down the music. To allow for a synchronised playback of both voices, the latency compensates for the processing time needed by Strasheela. The latency is used as timetag when OSC bundles are send to Strasheela and the scsynth. The scsynth delays the playback of the received notes by this amount (50 msecs in this example). Strasheela preserves this timetag in its newly generated note (see above) so that exactly the same timetag is used when this note is send to the scsynth (see below).</p>

<pre class="src">
<span style="color: #b8860b;">~latency</span> = 0.05;   <span style="color: #b22222;">// </span><span style="color: #b22222;">in secs
</span><span style="color: #b8860b;">~tempoFactor</span> = 0.6;
<span style="color: #b8860b;">~myRoutine</span> = <span style="color: #228b22;">Routine</span>.new({
    <span style="color: #da70d6;">inf</span>.do({ <span style="color: #a020f0;">arg</span> i;
             <span style="color: #a020f0;">var</span> dur, pitch, amp;
             <span style="color: #b22222;">// </span><span style="color: #b22222;">fetch pattern values
</span>             dur = <span style="color: #b8860b;">~durs</span>.next * <span style="color: #b8860b;">~tempoFactor</span>;
             amp = <span style="color: #b8860b;">~amps</span>.next;
             pitch = <span style="color: #b8860b;">~pitches</span>.next;
             <span style="color: #b22222;">// </span><span style="color: #b22222;">send note to Strasheela
</span>             <span style="color: #b8860b;">~mySendOSC</span>.sendBundle(<span style="color: #b8860b;">~latency</span>, [<span style="color: #5f9ea0;">'/note'</span>, (dur*1000).asInt, pitch, amp]);
             <span style="color: #b22222;">// </span><span style="color: #b22222;">play note on scserver
</span>             s.makeBundle(<span style="color: #b8860b;">~latency</span>,
               {<span style="color: #228b22;">Synth</span>(<span style="color: #bc8f8f;">"Strasheela-playback"</span>, [<span style="color: #5f9ea0;">\dur</span>, dur, <span style="color: #5f9ea0;">\freq</span>, pitch.midicps, <span style="color: #5f9ea0;">\amp</span>, amp/127, <span style="color: #5f9ea0;">\ffreq</span>, 500, <span style="color: #5f9ea0;">\pan</span>, 0.9]);});
             dur.wait;
    });
    <span style="color: #bc8f8f;">"done"</span>.postln;
});
</pre>

<p>The following function is called whenever a note is received from Strasheela (cf. the definition of a <code>recvOSCfunc</code> function above). This note is then played back on the scsynth.</p>

<pre class="src">
<span style="color: #a020f0;">thisProcess</span>.recvOSCfunc = { <span style="color: #a020f0;">arg</span> time, addr, msg;
    <span style="color: #0000ff;">if</span> ( addr.port != 57110, <span style="color: #b22222;">// </span><span style="color: #b22222;">ignore scsynth messages
</span>    { <span style="color: #a020f0;">var</span> address, dur, pitch, amp;
      # address, dur, pitch, amp = msg;
      s.makeBundle(time-<span style="color: #a020f0;">thisThread</span>.seconds,
           {<span style="color: #228b22;">Synth</span>(<span style="color: #bc8f8f;">"Strasheela-playback"</span>, [<span style="color: #5f9ea0;">\dur</span>, dur, <span style="color: #5f9ea0;">\freq</span>, pitch.midicps, <span style="color: #5f9ea0;">\amp</span>, amp/127, <span style="color: #5f9ea0;">\ffreq</span>, 2000, <span style="color: #5f9ea0;">\pan</span>, -0.9]);});
     };)
};
</pre>

<p>We are finally in the position to run the example. The method <code>play</code> starts the routine. The routine creates note events with the patterns, sends these notes to Strasheela and the scsynth. Strasheela creates a new notes, which it sends back. The recvOSCfunc receives these notes from Strasheela and sends them to the scsynth. Simultaneous notes are played exactly in sync (if the latency is high enough).</p>

<pre class="src">
<span style="color: #228b22;">SystemClock</span>.play(<span style="color: #b8860b;">~myRoutine</span>);
</pre>



<h2><a name="sec10" id="sec10"></a>
Discussion</h2>

<p class="first">This example demonstrated how a realtime music CSP can be defined in Strasheela. Please note that the implementation is not optimised in any way. For example, the implementation is purely declarative (no stateful operation), generating continuously lots of data which has to be garbage collected. Nevertheless, given a high enough latency, the output of the example is perfectly timed.</p>

<p>Garbage collection is indeed performed repeatedly while the example is running, and unlike Supercollider, Oz has <em>not</em> a realtime garbage collector. In Oz, the program execution must be shortly interrupted for garbage collection. Nevertheless, its garbage collection algorithm (copying dual-space algorithm) is fast for programs which require little active memory size. Moreover, larger applications can be split into multiple processes (using Oz' support for <a href="http://www.mozart-oz.org/documentation/dstutorial/index.html">distributed programming</a>), where each process has its own local garbage collection. If the time-critical parts of an Oz application run in small processes, their local garbage collection will be fast.</p>



<p>In this example, the input voice is created automatically by Supercollider. Alternatively, you may hook a MIDI keyboard into Supercollider, transform the incoming MIDI notes into OSC messages, and send them to Strasheela. You can then play some cantus firmus in realtime, and Strasheela generates a second voice for it. Please note that for a synchronised output, you still need to delay the playback of all notes by some latency.</p>

<p>Supercollider and Strasheela communicate via OSC in this example. Similarly, you can use Straheela's realtime constraint programming facilities for any other music programming environment which supports OSC, for example <a href="http://puredata.info/">Pure Data</a>.</p>


<hr>

<p class="footnote"><a class="footnum" name="fn.1" href="#fnr.1">1.</a> Note that this interface calls <code>dumpOSC</code> in a terminal (xterm), and sends its output to Oz via a socket with <code>netcat</code>. Starting <code>dumpOSC</code> in a terminal is necessary, because for unknown reasons <code>dumpOSC</code> refuses to output anything when called by Oz directly in a pipe (for details, see postings in the mailing lists <a href="mailto:osc_dev@create.ucsb.edu">osc_dev@create.ucsb.edu</a>, and <a href="mailto:users@mozart-oz.org">users@mozart-oz.org</a>, on the 7 September 2007 and following days). This interface relies thus on the following applications, which must be installed: <code>sendOSC</code>, <code>dumpOSC</code>, <code>xterm</code>, and netcat (<code>nc</code>). On most Unixes, <code>xterm</code> is already there. On MacOS, however, the X11 application must be installed in order to make <code>xterm</code> available (please find this application on your MacOS install CDs).</p>

<p>Additionally, all these applications must be specified in the Strasheela environment (if they are not in the PATH). For example, add lines like the following to your Oz init file <code>~/.ozrc</code>.</p>

<blockquote>
<p class="quoted"><code>{Init.putStrasheelaEnv sendOSC &quot;/path/to/sendOSC&quot;}</code></p>
</blockquote>

<p>The respective Strasheela environment variables are <code>sendOSC</code> (its default value is 'sendOSC'), <code>dumpOSC</code> (default 'dumpOSC'), <code>xterm</code> (default 'xterm'), <code>netcat</code> (default 'nc'), and <code>'X11.app'</code> (default <code>'/Applications/Utilities/X11.app'</code>). The environment variable <code>'X11.app'</code> is only required on MacOS.</p>

<p>The original dumpOSC delays the printout of bundles (when called in a pipe as this interface does) and it is recommended to apply the dumpOSC patch available <a href="../contributions/anders/OSC/others/dumpOSC/dumpOSC-patch.diff">here</a> (or simply replace the original file dumpOSC.c with the already patched dumpOSC.c in the same directory before compiling dumpOSC).</p>

<p class="footnote"><a class="footnum" name="fn.2" href="#fnr.2">2.</a> By default, only a single element is available in the arguments <code>Args.outputScores</code> and  <code>Args.inputScores</code> in order to save RAM (many previous solutions may accumulate otherwise, and they may be copied often during the search process). However, the maximum length of these arguments can be changed, see the <a href="../contributions/anders/Realtime/doc/node1.html">RT documentation</a> for details.</p>

<p class="footnote"><a class="footnum" name="fn.3" href="#fnr.3">3.</a> The <code>RT.scoreSearcherWithTimeout</code> argument <code>distroArgs</code> expects a record in the same format as solvers like <code>SDistro.exploreOne</code> and friends used in the examples before, see the <a href="../doc/api/node8.html">SDistro documentation</a>.</p>



<!-- Page published by Emacs Muse ends here -->
<!-- Footer -->
<div id="footer">
<div id="author">&copy; 
Torsten Anders</div>
<div id="date">Last time edited: 2008.04.22</div>
</div>
  </body>
</html>
