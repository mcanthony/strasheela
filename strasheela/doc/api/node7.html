<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>SMapping</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="12" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">Init</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">GUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">LUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">MUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">Score</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">SMapping</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">SDistro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">Midi</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> The functor defines higher-order means to traverse a score and/or apply procedures (e.g. rules) on a score.<BR>
 <BR>
 For instance, the functor exports a mixin class which understands various higher-order mapping methods. The methods recursively traverse an hierarchic score data structure. Mapping here means applying a given function/procedure to all elements of a specified set of items in the score, collecting or counting all items fulfilling a given predicate etc.<BR>
</span>
</span>
<h3>Functor</h3>
<ul>SMapping ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/source/ScoreMapping.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li><a href="node4.html">LUtils</a> at "<span class="string">ListUtils.ozf"
</span></li><li><a href="node3.html">GUtils</a> at "<span class="string">GeneralUtils.ozf"
</span></li><li>Pattern at "<span class="string">x-ozlib://anders/strasheela/Pattern/Pattern.ozf"
</span></li><li>Browser(browse:Browse)</li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;C:<a href="#entity326"><span class="type">FlagsMixin</span></a>&gt;
</li><li>&lt;C:<a href="#entity327"><span class="type">MappingMixin</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity328"><span class="functionname">ApplyToContext</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity329"><span class="functionname">ApplyToContext2</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity330"><span class="functionname">ApplyToContextR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity331"><span class="functionname">ForContexts</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity332"><span class="functionname">MapContexts</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity333"><span class="functionname">ForContextsR</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity334"><span class="functionname">PatternMatchingApply</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity335"><span class="functionname">PatternMatchingApply2</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity336"><span class="functionname">ForNumericRange</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity337"><span class="functionname">ForNumericRange2</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity338"><span class="functionname">ForNumericRangeArgs</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity339"><span class="functionname">MapSimultaneousPairs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity340"><span class="functionname">ForSimultaneousPairs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity341"><span class="functionname">FilterSimultaneous</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity342"><span class="functionname">FindSimultaneous</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity343"><span class="functionname">MapScore</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<a name="entity326">
<p class="margin"><div align="right"><a href="class27.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [auxiliary class] adds flag support to score objects. <BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">FlagsMixin</span>

<ul><li><span class="functionname">initFlags</span>()<br>
</li><li><span class="functionname">addFlag</span>(F)<br>
</li><li><span class="functionname">hasFlag</span>(?B F)<br>
</li><li><span class="functionname">removeFlag</span>(F)<br>
</li><li><span class="functionname">removeAllFlags</span>()<br>
</li></ul>
<span class="keyword">end</span>
</code><br>

<a name="entity327">
<p class="margin"><div align="right"><a href="class28.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [abstract class] A mixin class for various traversing and mapping methods on the whole score hierarchy.<BR>
</span>
<span class="keyword">class</span> <span class="type">MappingMixin</span>&nbsp;<span class="keyword">from</span>&nbsp;<a href="#entity326">FlagsMixin</a>

<ul><li><span class="functionname">collect</span>(?Xs excludeSelf:ExcludeSelf level:Level mode:Mode test:Test)<br>
</li><li><span class="functionname">forAll</span>(Proc excludeSelf:ExcludeSelf level:Level mode:Mode test:Test)<br>
</li><li><span class="functionname">forAllThreaded</span>(Proc excludeSelf:ExcludeSelf level:Level mode:Mode test:Test)<br>
</li><li><span class="functionname">map</span>(?Xs Fn excludeSelf:ExcludeSelf level:Level mode:Mode test:Test)<br>
</li><li><span class="functionname">mappend</span>(?Xs Fn excludeSelf:ExcludeSelf level:Level mode:Mode test:Test)<br>
</li><li><span class="functionname">count</span>(?N excludeSelf:ExcludeSelf level:Level mode:Mode test:Test)<br>
</li><li><span class="functionname">filter</span>(?Xs Fn excludeSelf:ExcludeSelf level:Level mode:Mode)<br>
</li><li><span class="functionname">find</span>(?Xs Fn excludeSelf:ExcludeSelf level:Level mode:Mode)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>

<code>
<a name="entity328">
<span class="keyword">proc</span>{<span class="functionname">ApplyToContext</span> Context P}<br>
<span class="string"> P (a unary proc or method) is applied to Context (any data structure), if this context is not empty. An empty context is represented by nil -- for such a context the application of P is skipped.<BR>
 NB: Application of P blocks until the context is determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity329">
<span class="keyword">fun</span>{<span class="functionname">ApplyToContext2</span> Context Fn}<br>
<span class="string"> Variant of ApplyToContext: Fn (a unary function or method) is applied to Context and the result is returned. For an empty context, nil is returned<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity330">
<span class="keyword">proc</span>{<span class="functionname">ApplyToContextR</span> Args}<br>
<span class="string"> B=1 <-> Rule holds for N non-empty context Candidates which pass the test IsContext.<BR>
 Args is a record with the five feats 'candidates', 'isContext', 'rule', 'n' and 'b'. Candidates is a list of context candidates (any data). IsContext (a unary function or method) expects such a context candidate and returns a 0/1-int reflecting whether the context is a valid or not. Rule (a unary function or method) is a reified constraint applied to any context candidate returning a 0/1-int. N (the atom 'any' or a FD int) specifies for how many contexts IsContext holds (i.e. returns 1). B=1 constrains that Rule holds for all these contexts. Nevertheless, Rule may hold for more candidates.<BR>
 Candidates, IsContext, and Rule are required arguments. N is optional (default is 'any') and B is optional (default is 1).<BR>
<BR>
 NB: some internal FD ints (in IsContextBs and RuleBs) possibly remain undetermined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity331">
<span class="keyword">proc</span>{<span class="functionname">ForContexts</span> Xs GetContext P}<br>
<span class="string"> P (a unary proc) is applied to the context of every element in Xs (a list) for which the context is not empty.<BR>
 GetContext (a unary function) returns the context of an element in Xs. A context may be any data structure (e.g. a list or record of Strasheela objects). An empty context is reprented by nil, for such contexts the application is skipped.<BR>
 NB: Application of P blocks until the context is determined (i.e. until GetContext returns value).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity332">
<span class="keyword">fun</span>{<span class="functionname">MapContexts</span> Xs GetContext Fn}<br>
<span class="string"> Fn (a unary function) is applied to the context of every element in Xs (a list) for which the context is not empty. The results are collected and returned.<BR>
 GetContext (a unary function) returns the context of an element in Xs. A context may be any data structure (e.g. a list or record of Strasheela objects). An empty context is reprented by nil. For an empty context the application is skipped and nothing is collected in the result.<BR>
 NB: Application of P blocks until the context is determined (i.e. until GetContext returns value).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity333">
<span class="keyword">proc</span>{<span class="functionname">ForContextsR</span> Args}<br>
<span class="string"> N=every <-> Rule holds for the context of every element in Xs (context candidates of each element returned by GetCandidates) which passes the test IsContext.<BR>
 Args is a record with the five feats 'xs', 'getCandidates', 'isContext', 'rule', and 'n'.  GetCandidates (a unary function) returns a list of context candidates (any data) of an element in Xs (a list). IsContext (a unary function or method) expects such a context candidate and returns a 0/1-int reflecting whether the context is a valid or not. Rule (a unary function or method) is a reified constraint applied to any context candidate returning a 0/1-int. N (the atom 'every' or a FD int) specifies for how many elements of Xs at least one non-empty context candidate complies both IsContext and Rule.<BR>
 Xs, GetCandidates, IsContext, and Rule are required arguments. N is optional (default is 'every').<BR>
<BR>
 NB: some internal FD ints (in IsContextBs and RuleBs) possibly remain undetermined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity334">
<span class="keyword">proc</span>{<span class="functionname">PatternMatchingApply</span> Self Xs PatternMatchingExpr P}<br>
<span class="string"> Apply unary procedure P (expecting a list) to the sublist from Xs (a list) matching PatternMatchingExpr (a list of atoms: a single 'x' and any number of 'o' in any order). PatternMatchingExpr expresses a sublist of Xs positionally related to Self (an element of Xs). The atom 'x' in PatternMatchingExpr reprents Self and one or more 'o' atoms around 'x' express predecessors or successors of Self in Xs. For instance, <code>{PatternMatchingApply Self Xs [o o x] P}</code> applies P to the list consisting in the two predecessors of Self in Xs and Self (in that order). <BR>
 PatternMatchingApply reduces to skip in case there is no matching sublist in Xs (e.g. the PatternMatchingExpr = [o x] and X is already the first element in Xs).<BR>
 An exeception is raised in case Self is not contained in Xs or there is no 'x' in PatternMatchingExpr.<BR>
<BR>
 BTW: PatternMatchingApply corresponds roughly to the rule application mechanism of PWConstraints. However, PWConstraints always applies a rule to all object sets matching the pattern whereas PatternMatchingApply applies the rule only to a single set (or score context). That way, the user controls to which matching sets the rule is applied.<BR>
 PWConstraints introduces also pattern vars denoting numeric indices which can not be mixed with the other pattern variables.  ForNumericRange (see below) defines a similar alternative rule application mechanism.<BR>
 BTW: PatternMatchingApply allows to apply a procedure to non-uniform context (e.g. a single chord and multiple notes related by their position): a part of the context (e.g. the single note) is not contained in Xs but in the lexical scope of P.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity335">
<span class="keyword">proc</span>{<span class="functionname">PatternMatchingApply2</span> Self Xs PatternMatchingExpr P ElseP}<br>
<span class="string"> Generalised variant of PatternMatchingApply: in case no sublist in Xs matches PatternMatchingExpr, PatternMatchingApply2 does _not_ reduce to skip (as PatternMatchingApply) but instead applies the null-ary procedure ElseP.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity336">
<span class="keyword">proc</span>{<span class="functionname">ForNumericRange</span> Xs Decl P}<br>
<span class="string"> Applies unary procedure P to each element in Xs which index is expressed by Decl. Decl is a list which contains single index integers, or index ranges of the form Min#Max (Min and Max are integers).<BR>
 BTW: ForNumericRange corresponds roughly to one of the rule application mechanisms of Situation. The rule applicator `mapIndex' in Strasheela publications is the function equivalent.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity337">
<span class="keyword">proc</span>{<span class="functionname">ForNumericRange2</span> Xs Decl P ElseP}<br>
<span class="string"> Generalised variant of ForNumericRange: to every element in Xs to which P is not applied, ElseP (a unary procedure) is applied instead.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity338">
<span class="keyword">proc</span>{<span class="functionname">ForNumericRangeArgs</span> Xs Decl P ElseP}<br>
<span class="string"> Applies binary procedure P to each element in Xs which index is expressed by Decl -- together with additional arguments for that index. To all other elements of Xs the unary procedure ElseP is applied instead.<BR>
 Decl is a list which contains single index integers plus constraint arguments in the form Ind#Args, or index ranges plus constraint arguments in the form (Min#Max)#Args. The index Ind and the range boundaries Min and Max are integers, Args is a list of arbitrary values (and can be nil).<BR>
  ForNumericRangeArgs implements a generalised variant of ForNumericRange (and ForNumericRange2) which implements an extended syntax for Decl.<BR>
 The rule applicator `mapIndexArgs' in Strasheela publications is the function equivalent.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity339">
<span class="keyword">fun</span>{<span class="functionname">MapSimultaneousPairs</span> Xs Fn Args}<br>
<span class="string"> MapSimultaneousPairs traverses Xs (a list of score objects), applies the binary function Fn to pairs of simultaneous score objects, and returns the collected results. <BR>
 MapSimultaneousPairs applies {Fn X Y ?Result} to all pairs X and Y, where X is an element in Xs and Y is a score object which is simultaneous to X, but which is not necessarily contained in Xs. In order to avoid applying the same constraint twice in case both X and Y are contained in Xs, there is an additional restriction related to the hierarchic nesting of X and Y. Simplified, this restriction states that the container of Y must be at a lower position than the container of X -- which usually means that Y is in a higher voice than X. However, MapSimultaneousPairs is more general and works for arbitrary nesting.<BR>
<BR>
 Args: <BR>
 'test': a Boolean function or method for pre-filtering potential Y values.<BR>
 'cTest': a Boolean function or method applied within the concurrent filtering done for isSimultaneousItemR. See doc of the Score.item method getSimultaneousItems for details. <BR>
<BR>
 Note that MapSimultaneousPairs even works if the rhythmical structure is indetermined in the CSP definition, but it will block until the rhythmic structure is determined enough to tell which score objects are simultaneous. Therefore, a distribution strategy which determines the rhythmical structure relatively early (e.g., left to right) is recommended.<BR>
<BR>
 See ForSimPairs doc for an example. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity340">
<span class="keyword">proc</span>{<span class="functionname">ForSimultaneousPairs</span> Xs P Args}<br>
<span class="string"> ForSimultaneousPairs traverses Xs (a list of score objects) and applies the binary procedure P to pairs of simultaneous score objects. <BR>
 ForSimultaneousPairs applies {Fn X Y} to all pairs X and Y, where X is an element in Xs and Y is a score object which is simultaneous to X, but which is not necessarily contained in Xs. In order to avoid applying the same constraint twice in case both X and Y are contained in Xs, there is an additional restriction related to the hierarchic nesting of X and Y. Simplified, this restriction states that the container of Y must be at a lower position than the container of X -- which usually means that Y is in a higher voice than X. However, ForSimultaneousPairs is more general and works for arbitrary nesting.<BR>
<BR>
 Args: <BR>
 'test': a Boolean function or method for pre-filtering potential Y values.<BR>
 'cTest': a Boolean function or method applied within the concurrent filtering done for isSimultaneousItemR. See doc of the Score.item method getSimultaneousItems for details. <BR>
<BR>
 Note that ForSimultaneousPairs even works if the rhythmical structure is indetermined in the CSP definition, but it will block until the rhythmic structure is determined enough to tell which score objects are simultaneous. Therefore, a distribution strategy which determines the rhythmical structure relatively early (e.g., left to right) is recommended.<BR>
<BR>
 Examples:<BR>
 Application of a harmonic constraint to all pairs of simultaneous notes. This approach works for any number of voices and arbitrarily complex rhythmic structures. <BR>
      {ForSimPairs {MyScore collect($ test:isNote)} IsConsonant isNote}<BR>
 Application of a harmonic constraint to all note pairs consisting of a bass note and a note from a higher voice. MyBass is a container which contains all the bass notes. <BR>
      {ForSimPairs {MyBass collect($ test:isNote)} IsConsonant isNote}<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity341">
<span class="keyword">fun</span>{<span class="functionname">FilterSimultaneous</span> Xs Y}<br>
<span class="string"> Traverses Xs (a list of temporal items) and returns those from Xs which are simultaneous with Y (a temporal item).<BR>
 Uses internally LUtils.cFilter, i.e. returns score objects as soon as enough information is available whether or not they are simultaneous, but not necessarily in their order in Xs.<BR>
 Implicitly wraps filtering in a thread. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity342">
<span class="keyword">fun</span>{<span class="functionname">FindSimultaneous</span> Xs Y}<br>
<span class="string"> Traverses Xs (a list of temporal items) and returns the first which is simultaneous with Y (a temporal item).<BR>
 Uses internally LUtils.cFind, i.e. returns score objects as soon as enough information is available whether or not they are simultaneous, but not necessarily in their order in Xs.<BR>
 Implicitly wraps filtering in a thread. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity343">
<span class="keyword">fun</span>{<span class="functionname">MapScore</span> MyScore Fn}<br>
<span class="string"> Expects a _textual_ score MyScore (a record) and applies Fn to every contained textual score object. Returns a score where the score object are replaced by the results of Fn. However, any 'items' features are ignored in the result of Fn. Instead, the original nesting is preserved. <BR>
 NB: presently, only tree topology is supported<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>