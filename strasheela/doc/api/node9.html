<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Out</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="12" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">Init</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">GUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">LUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">MUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">Score</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">SMapping</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">SDistro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">Midi</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Functor defines means for output, e.g. means to output a Strasheela score to a csound score and play the result.<BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Out ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/source/Output.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>Open</li><li>OS</li><li>Tk</li><li>System</li><li>Compiler</li><li>FD</li><li>FS</li><li>Browser(browse:Browse)</li><li>Inspector(inspect:Inspect)</li><li>CompilerPanel</li><li>Application</li><li>Combinator</li><li>Connection</li><li>DistributionPanel</li><li>DPControl</li><li>DPInit</li><li>DPStatistics</li><li>DefaultURL</li><li>Discovery</li><li>Emacs</li><li>Error</li><li>ErrorListener</li><li>ErrorRegistry</li><li>EvalDialog</li><li>Explorer</li><li>Fault</li><li>Finalize</li><li>Gump</li><li>GumpParser</li><li>GumpScanner</li><li>Listener</li><li>Macro</li><li>Module</li><li>Narrator</li><li>OPI</li><li>OPIEnv</li><li>OPIServer</li><li>ObjectSupport</li><li>OsTime</li><li>Ozcar</li><li>OzcarClient</li><li>Panel</li><li>Pickle</li><li>Profiler</li><li>Property</li><li>RecordC</li><li>Remote</li><li>Resolve</li><li>Schedule</li><li>Search</li><li>Service</li><li>Space</li><li>Tix</li><li>TkTools</li><li>Type</li><li>URL</li><li>VirtualSite</li><li>Path at "<span class="string">x-ozlib://anders/tmp/Path/Path.ozf"
</span></li><li><a href="node3.html">GUtils</a> at "<span class="string">GeneralUtils.ozf"
</span></li><li><a href="node4.html">LUtils</a> at "<span class="string">ListUtils.ozf"
</span></li><li><a href="node5.html">MUtils</a> at "<span class="string">MusicUtils.ozf"
</span></li><li><a href="node6.html">Score</a> at "<span class="string">ScoreCore.ozf"
</span></li><li><a href="node2.html">Init</a> at "<span class="string">Init.ozf"
</span></li><li><a href="node11.html">Midi</a> at "<span class="string">MidiOutput.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;P/2:<a href="#entity407"><span class="functionname">WriteToFile</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity408"><span class="functionname">ReadFromFile</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity409"><span class="functionname">RecordToVS</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity410"><span class="functionname">ListToVS</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity411"><span class="functionname">ListToLines</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity412"><span class="functionname">MakeEventlist</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity413"><span class="functionname">OutputEventlist</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity414"><span class="functionname">ScoreToEvents</span></a>&gt;
</li><li>&lt;P/6:<a href="#entity415"><span class="functionname">MakeHierarchicVSScore</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity416"><span class="functionname">ToScoreConstructor</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity417"><span class="functionname">OutputScoreConstructor</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity418"><span class="functionname">SaveScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity419"><span class="functionname">LoadScore</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity420"><span class="functionname">MakeEvent2CsoundFn</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity421"><span class="functionname">MakeCsoundScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity422"><span class="functionname">OutputCsoundScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity424"><span class="functionname">RenderCsound</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity425"><span class="functionname">RenderAndPlayCsound</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity423"><span class="functionname">CallCsound</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity432"><span class="functionname">ToLilypond</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity433"><span class="functionname">OutputLilypond</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity434"><span class="functionname">CallLilypond</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity435"><span class="functionname">ViewPDF</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity437"><span class="functionname">RenderLilypond</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity436"><span class="functionname">RenderAndShowLilypond</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity429"><span class="functionname">LilyMakePitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity430"><span class="functionname">LilyMakeFromMidiPitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity426"><span class="functionname">LilyMakeRhythms</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity427"><span class="functionname">LilyMakeMicroPitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity428"><span class="functionname">LilyMakeEt72MarkFromMidiPitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity431"><span class="functionname">MakeNoteToLily</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity440"><span class="functionname">OutputSCScore</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity439"><span class="functionname">MakeSCScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity438"><span class="functionname">MakeSCEventOutFn</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity441"><span class="functionname">SendOsc</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity442"><span class="functionname">SendSCserver</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity443"><span class="functionname">SendSClang</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity451"><span class="functionname">ToNonmensuralENP</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity452"><span class="functionname">OutputNonmensuralENP</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity453"><span class="functionname">ToFomus</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity454"><span class="functionname">OutputFomus</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity455"><span class="functionname">RenderFomus</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity456"><span class="functionname">MakeCMEvent</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity457"><span class="functionname">MakeCMScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity458"><span class="functionname">OutputCMScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity444"><span class="functionname">ToDottedList</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity445"><span class="functionname">LispList</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity446"><span class="functionname">RecordToLispKeywordList</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity447"><span class="functionname">ToLispKeywordList</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity448"><span class="functionname">OzToLisp</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity449"><span class="functionname">Note2ClmP</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity450"><span class="functionname">MakeClmScoreFn</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity459"><span class="functionname">PlaySound</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity460"><span class="functionname">Exec</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity461"><span class="functionname">ExecNonQuitting</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity462"><span class="functionname">ExecWithOutput</span></a>&gt;
</li><li>&lt;C:<a href="#entity465"><span class="type">Shell</span></a>&gt;
</li><li><span class="variablename">Midi</span>
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity407">
<span class="keyword">proc</span>{<span class="functionname">WriteToFile</span> Output Path}<br>
<span class="string"> Writes/overwrites Output (a virtual string) to file at Path.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity408">
<span class="keyword">proc</span>{<span class="functionname">ReadFromFile</span> Path Result}<br>
<span class="string"> Reads the content of the text file at Path and returns it as string.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity409">
<span class="keyword">fun</span>{<span class="functionname">RecordToVS</span> X}<br>
<span class="string"> Transforms a (possibly nested) record into a single virtual string with Oz record syntax. RecordToVS also transforms the special Oz records with the labels '|' (i.e. lists) and '#' into their shorthand syntax. However, the virtual string output is not indented, every record feature (or list element) starts a new line. As the output is basically a text value (i.e. no 'normal' Oz value anymore), FD and FS variables are transformed into a constructor call (FD.int and FS.var.bounds) which would create these variables when evaluated. <BR>
 NB: Value.toVirtualString does something very similar: it transforms nested data into their print representation. Instead, RecordToVS does not expect any max width/depth arguments and attempts to format the output. <BR>
 NB: if X (or some value in X) is not of any of the types record (or list or #-pair) or virtual string, Value.toVirtualString is called on this value.<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity410">
<span class="keyword">fun</span>{<span class="functionname">ListToVS</span> Xs Delimiter}<br>
<span class="string"> Transforms Xs, a list of virtual strings, into a single virtual string. Delimiter is the virtual string between all list elements.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity411">
<span class="keyword">fun</span>{<span class="functionname">ListToLines</span> Xs}<br>
<span class="string"> Transforms a list of virtual strings into a single virtual string without any sign between the list elements.<BR>
 */<BR>
    fun {ListToVS2 Xs}<BR>
       {ListToVS Xs ''}<BR>
       case Xs<BR>
       of X|nil then X<BR>
       [] X|Tail then X#{ListToVS2 Tail}<BR>
       [] nil then nil<BR>
       end<BR>
    end<BR>
    /** % Transforms a list of virtual strings into a single virtual string with a single whitespace between the list elements.<BR>
 */<BR>
    fun {ListToVS3 Xs}<BR>
       {ListToVS Xs " "}<BR>
       case Xs<BR>
       of X|nil then X<BR>
       [] X|Tail then X#" "#{ListToVS Tail}<BR>
       [] nil then nil<BR>
       end<BR>
    end<BR>
<BR>
<BR>
/** % Transforms a list of virtual strings into a single virtual string, every list element starts at a new line.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity412">
<span class="keyword">fun</span>{<span class="functionname">MakeEventlist</span> Score EventOut ScoreOut}<br>
<span class="string"> [Temp def? Def. not general enough] MakeEventlist generates a virtual string for output from Score. The unary function EventOut generates the output of a single event. The binary function ScoreOut combines all events to a score.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity413">
<span class="keyword">proc</span>{<span class="functionname">OutputEventlist</span> Score EventOut ScoreOut Path}<br>
<span class="string"> [Temp def -- use WriteToFile directly instead] OutputEventlist transforms Score for output and outputs it at Path. The unary function EventOut generates the output of a single event. The binary function ScoreOut combines all events to a score.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity414">
<span class="keyword">fun</span>{<span class="functionname">ScoreToEvents</span> MyScore Specs Args}<br>
<span class="string"> Transforms MyScore (a Strasheela score) into a list of events. Specs is a list of pairs in the form [Test1#Transform1 ...]. Each Test is a unary function (or method) expecting a score object and returning a boolean. Each Transform is a unary function expecting a score object and returning a list of events.<BR>
 The record Args expects the only optional argument test, a unary boolean function used to filter the set of score objects in MyScore: only  objects for which the test returns true are considered for processing. This test defaults to<BR>
   fun {Test X} {X isEvent($)} andthen {X isDet($)} andthen {X getDuration($)} > 0 end<BR>
  For every score object in MyScore which passes this Test, the appropriate Test#Transform pair is found out (i.e. the first pair which test returns true for the score object). If no matching pair is found, the object is skipped. Otherwise, the respective Transform is applied to this score object and the result appended to the full result of ScoreToEvents.<BR>
 The following example implements a simple Strasheela score -> Csound score transformation. Only the notes in the Strasheela score are considered (everything else is ignored) and these notes are transformed into a csound score event.<BR>
   {Out.scoreToEvents MyScore [isNote#fun {$ MyNote}<BR>
					 [{Out.listToVS<BR>
					   [i1<BR>
					    {MyNote getStartTimeInSeconds($)}<BR>
					    {MyNote getDurationInSeconds($)}<BR>
					    {MyNote getPitchInMidi($)}<BR>
					    {MyNote getAmplitudeInVelocity($)}]<BR>
					   " "}]<BR>
				      end]<BR>
    unit}<BR>
   <BR>
 For example, the result returned could look like this:<BR>
   ["i1 0.0 1.0 60.0"<BR>
    "i1 1.0 2.0 62.0"<BR>
    "i1 2.0 4.0 64.0"]<BR>
   <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity415">
<span class="keyword">fun</span>{<span class="functionname">MakeHierarchicVSScore</span> Score EventOut SimOut SeqOut FurtherClauses}<br>
<span class="string"> [Temp def? Def. not general enough] Translates Score into some hierarchic score (a tree, not a graph) for output. EventOut, SimOut, and SeqOut are all functions which output a VS representation of the output format. The functions SimOut and SeqOut return something in the form [BeginVS Delimiter EndVS] -- the representation of their items will be placed between these "tags". FurtherClauses is a list to define additional output alternatives as in the form [testFnOrMeth1#Fn1 ..]. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity416">
<span class="keyword">fun</span>{<span class="functionname">ToScoreConstructor</span> MyScore Spec}<br>
<span class="string"> Creates an Oz program (as a VS) which re-constructs MyScore.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity417">
<span class="keyword">proc</span>{<span class="functionname">OutputScoreConstructor</span> MyScore Spec}<br>
<span class="string"> Stores an Oz program in a file which re-constructs MyScore. For example, this file can also be used for editing purposes. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity418">
<span class="keyword">proc</span>{<span class="functionname">SaveScore</span> MyScore Args}<br>
<span class="string"> Saves MyScore into a text file which can be compiled and loaded again later with LoadScore.<BR>
 NB: SaveScore internally uses toInitRecord (because a stateful data structure like an object can not be pickled). Therefore, all present restrictions of toInitRecord apply:  getInitInfo must be defined correctly for all classes and only tree-form score topologys are supported.<BR>
<BR>
 Saves MyScore into a pickle which can be loaded again later with LoadScore.<BR>
 NB: Only a fully determiend score can be pickled, otherwise an exception is raised.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity419">
<span class="keyword">fun</span>{<span class="functionname">LoadScore</span> Args}<br>
<span class="string"> Loads a pickeled score from path.<BR>
 NB: If the class definitions for the classes used in the score will have changed meanwhile, the loaded score will still use the new class definitions (it is re-created from the textual specification). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity420">
<span class="keyword">fun</span>{<span class="functionname">MakeEvent2CsoundFn</span> Instrument Spec}<br>
<span class="string"> Outputs unary function which transforms an Score.event into a csound note virtual string. <BR>
 Spec is a list of accessor functions/methods. However, for every accessor function/method a transformation function/method for the accessed data can be specified using the syntax Accessor#Transformator. All accessors mmust return a parameters (e.g. use getPitchParameter instead of getPitch).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity421">
<span class="keyword">fun</span>{<span class="functionname">MakeCsoundScore</span> EventVSs Header}<br>
<span class="string"> Returns a Csound score as a virtual string. EventVSs is a note list. Each note is a virtual string. Header is the Csound header, e.g. f statements.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity422">
<span class="keyword">proc</span>{<span class="functionname">OutputCsoundScore</span> MyScore Spec}<br>
<span class="string"> Create a csound score file of MyScore, but only include fully determined events. The defaults for Spec are:<BR>
   unit(file:"test" % without extension<BR>
	scoDir:{Init.getStrasheelaEnv defaultCsoundScoDir}<BR>
	header:nil<BR>
	event2CsoundFn:&lt;see source&gt;<BR>
	test:&lt;see source&gt;)<BR>
 header is the csound header VS (e.g. for f-tables).<BR>
 The default event2CsoundFn of OutputCsoundScore supports parameter unit specifications for the transformation process (see the Parameter documentation). Without determined Parameter unit the unit defaults to seconds for TimeParameters and midi for Pitches. The event2CsoundFn always returns seconds and midi pitches. <BR>
   always transforms timing parameters into seconds and <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity424">
<span class="keyword">proc</span>{<span class="functionname">RenderCsound</span> MyScore Spec}<br>
<span class="string"> Creates a csound score of all (determined) events in MyScore, and renders the score. See the documentation of OutputCsoundScore, CallCsound, and PlaySound for arguments in Spec (the PlaySound argument extension is substituted by the argument soundExtension).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity425">
<span class="keyword">proc</span>{<span class="functionname">RenderAndPlayCsound</span> MyScore Spec}<br>
<span class="string"> Creates a csound score of all (determined) events in MyScore, renders the score and plays the resulting sound. See the documentation of OutputCsoundScore, CallCsound, and PlaySound for arguments in Spec (the PlaySound argument extension is substituted by the argument soundExtension).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity423">
<span class="keyword">proc</span>{<span class="functionname">CallCsound</span> Spec}<br>
<span class="string"> Calls Csound with args in Spec and writes Csound messages on standard output (Oz emulator). Spec is a record with optional arguments. The defaults are:<BR>
   unit(orc:{Init.getStrasheelaEnv defaultOrcFile} % with extension!, e.g. "pluck.orc"<BR>
	file:"test" % without extension!<BR>
	soundExtension:{Init.getStrasheelaEnv defaultCsoundSoundExtension} % ".aiff"<BR>
	orcDir:{Init.getStrasheelaEnv defaultCsoundOrcDir}<BR>
	scoDir:{Init.getStrasheelaEnv defaultCsoundScoDir}<BR>
	soundDir:{Init.getStrasheelaEnv defaultSoundDir}<BR>
	csound:{Init.getStrasheelaEnv csound}<BR>
	flags:{Init.getStrasheelaEnv defaultCsoundFlags})<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity432">
<span class="keyword">fun</span>{<span class="functionname">ToLilypond</span> MyScore FurtherClauses}<br>
<span class="string"> Transforms a score object into a Lilypond score virtual string. The score layout is hardwired: the Items in the outmost Simultaneous container are put in their own staff. [currently, if outmost Simultaneous containers are contained in surround Sequentials, new staffs will be draw for each Item contained in each Simultaneous.]<BR>
 The argument FurtherClauses allows for specifying what Lilypond shows for specific score objects. FurtherClauses expects a list of the form [TypeCheck1#ProcessingFun1 ...].  TypeCheckN is a boolean function or method (e.g. isNote) and ProcessingFunN is a function which expects score objects for which TypeCheckN returns true as argument. ProcessingFunN returns a Lilypond VS. For example, the user may define a subclass of Score.note with an additional articulation attribute (e.g. values may be staccato, tenuto etc.) and the user then defines a clause which causes Lilypond to show the articulation by its common sign in the sheetmusic score.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity433">
<span class="keyword">proc</span>{<span class="functionname">OutputLilypond</span> MyScore Spec}<br>
<span class="string"> Transforms MyScore into a Lilypond score. See the documentation of ToLilypond for an explanation of the argument clauses in Spec. <BR>
   The defaults of Spec are<BR>
   unit(dir: {Init.getStrasheelaEnv defaultLilypondDir}<BR>
	file: "test" % !! file name without extention<BR>
	clauses:nil)<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity434">
<span class="keyword">proc</span>{<span class="functionname">CallLilypond</span> Spec}<br>
<span class="string"> Calls lilypond on a lilypond file specified by Spec. The defaults of Spec are:<BR>
   unit(dir: {Init.getStrasheelaEnv defaultLilypondDir}<BR>
	file: test) % !! file name without extention<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity435">
<span class="keyword">proc</span>{<span class="functionname">ViewPDF</span> Spec}<br>
<span class="string"> Calls ghostview on a postscript file specified by Spec. The name of the lilypond file is given without extension. The defaults of Spec are:<BR>
   unit(dir: {Init.getStrasheelaEnv defaultLilypondDir}<BR>
	file: test)<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity437">
<span class="keyword">proc</span>{<span class="functionname">RenderLilypond</span> MyScore Spec}<br>
<span class="string"> Outputs a Lilypond file for MyScore and calls Lilypond to process it. See OutputLilypond and CallLilypond for details on Spec.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity436">
<span class="keyword">proc</span>{<span class="functionname">RenderAndShowLilypond</span> MyScore Spec}<br>
<span class="string"> Outputs a Lilypond file for MyScore, calls Lilypond to process it, and calls the PDF viewer with the result. See OutputLilypond, CallLilypond, and ViewPDF for details on Spec.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity429">
<span class="keyword">fun</span>{<span class="functionname">LilyMakePitch</span> PitchParam}
</code><br>

<code>
<a name="entity430">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeFromMidiPitch</span> MidiPitch}
</code><br>

<code>
<a name="entity426">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeRhythms</span> DurationParam}
</code><br>

<code>
<a name="entity427">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeMicroPitch</span> PitchParam}
</code><br>

<code>
<a name="entity428">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeEt72MarkFromMidiPitch</span> MidiPitch}<br>
<span class="string"> Returns a Lily fingering mark (a virtual string) which represents a micro-tonal tuning deviation in 72ET temperament.<BR>
 */<BR>
    fun {LilyMakeEt72MarkFromMidiPitch MidiPitch}<BR>
       Marks = unit("-0" "-1" "-2" "-3" "-4" "-5" "-6")<BR>
Pitch = {PitchParam getValueInMidi($)}<BR>
       Micro = {FloatToInt ((MidiPitch - {Round MidiPitch}) * 6.0)} + 4<BR>
    in<BR>
       Marks.Micro<BR>
    end<BR>
/** %% Returns a Lily fingering mark (a virtual string) which represents a micro-tonal tuning deviation in 72ET temperament.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity431">
<span class="keyword">fun</span>{<span class="functionname">MakeNoteToLily</span> MakeAddedSigns}<br>
<span class="string"> Returns unary function expecting note. MakeAddedSigns is unary fun expecting the note and returning VS of arbitrary added signs (e.g. fingering marks, articulation marks etc.)<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity440">
<span class="keyword">proc</span>{<span class="functionname">OutputSCScore</span> Score SCEventOut Spec}
</code><br>

<code>
<a name="entity439">
<span class="keyword">fun</span>{<span class="functionname">MakeSCScore</span> Score SCEventOut MkContainerOut FurtherClauses}<br>
<span class="string"> Generate a SuperCollider score in hierarchic score format (a VS). SCEventOut is a unary function transforming a single SDL event into a SC event (a VS). The TimeParameter units must be determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity438">
<span class="keyword">fun</span>{<span class="functionname">MakeSCEventOutFn</span> PlayerOut}<br>
<span class="string"> [aux means for MakeSCScore] Outputs a unary function which transforms a SDL event into a SC event (a VS). PlayerOut is a unary function with the event a argument which returns a SC player call (a VS). The TimeParameter units must be determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity441">
<span class="keyword">proc</span>{<span class="functionname">SendOsc</span> Host Port OSCcmd}<br>
<span class="string"><BR>
 NB: the network address must be set by setting the environment var REMOTE_ADDR (defaults to '127.0.0.1').<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity442">
<span class="keyword">proc</span>{<span class="functionname">SendSCserver</span> OSCcmd}<br>
<span class="string">[tmp restricted def?]<BR>
</span>
</code><br>

<code>
<a name="entity443">
<span class="keyword">proc</span>{<span class="functionname">SendSClang</span> OSCcmd}<br>
<span class="string">[tmp restricted def?]<BR>
</span>
</code><br>

<code>
<a name="entity451">
<span class="keyword">fun</span>{<span class="functionname">ToNonmensuralENP</span> TheScore Args}<br>
<span class="string"> Exports TheScore (a Strasheela score) into a non-mensural ENP score (a VS). The ENP format is rather fixed, whereas the information contained in the Strasheela score format is highly user-customisable. Therefore, the export-process is also highly user-customisable. <BR>
 An ENP score has a fixed topology. The non-mensural ENP has the following nesting: <code>score(part(voice(chord(note+)+)+)+)</code>. See the PWGL documentation for details. <BR>
 Strasheela, on the other hand, supports various topologies. However, ToNonmensuralENP does not automatically perform a score topology transformation into the ENP topology. Instead, ToNonmensuralENP expects a number of optional accessor functions as arguments (e.g. getScore, getParts, getVoices) which allow for a user-defined topology transformation. These functions expect a (subpart of the) score and return the contained objects according to the ENP topology. For instance, the function getVoices expects a Strasheela object corresponding to an ENP part and returns a list of Strasheela object corresponding to ENP voices. The default values for these accessor functions require that the topology of TheScore fully corresponds with the ENP score topology. That is, for the default accessor functions, TheScore must have the following topology: <code>sim(sim(seq(sim(note+)+)+)+)</code>. The set of all supported accessor functions (together with their default values) is given below.<BR>
 Any ENP attribute of a score object can be specified by the user. For this purpose, ToNonmensuralENP expects a number of optional attribute accessor functions (e.g. getScoreKeywords, getPartKeywords). These functions expect a Strasheela object corresponding to an ENP part and returns an Oz record whose features are the ENP keywords for this objects and the feature values are the values for these ENP keywords. See the default of getNoteKeywords for an example. <BR>
<BR>
 Default arguments: <BR>
   unit(getScore:fun {$ X} X end<BR>
	getParts:fun {$ MyScore} {MyScore getItems($)} end<BR>
	getVoices:fun {$ MyPart} {MyPart getItems($)} end<BR>
	getChords:fun {$ MyVoice} {MyVoice getItems($)} end<BR>
	getNotes:fun {$ MyChord} {MyChord getItems($)} end<BR>
	getScoreKeywords:fun {$ MyScore}<BR>
			    unit % put further ENP score keywords here<BR>
			 end<BR>
	getPartKeywords:fun {$ MyPart}<BR>
			   unit % put further ENP part keywords here<BR>
			end<BR>
	getVoiceKeywords:fun {$ MyVoice}<BR>
			    unit % put further ENP voice keywords here<BR>
			 end<BR>
	getChordKeywords:fun {$ MyChord}<BR>
			    unit % put further ENP chord keywords here<BR>
			 end<BR>
	getNoteKeywords:fun {$ MyNote}<BR>
 put further ENP note keywords here<BR>
			   unit('offset-time': {MyNote getOffsetTimeInSeconds($)})<BR>
			end)<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity452">
<span class="keyword">proc</span>{<span class="functionname">OutputNonmensuralENP</span> MyScore Args}<br>
<span class="string">  Exports MyScore (a Strasheela score) into a text file with a non-mensural ENP score. The file path is specified with the arguments file, extension and dir. For further arguments see the ToNonmensuralENP documentation.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity453">
<span class="keyword">fun</span>{<span class="functionname">ToFomus</span> MyScore Args}<br>
<span class="string"> Exports MyScore into Fomus format (as a VS). The Fomus format is rather fixed, whereas the information contained in the Strasheela score format is highly user-customisable. Therefore, the export-process is also highly user-customisable.<BR>
 A Fomus score has a fixed topology: <code>score(part(event+)+)</code> (see the Fomus documentation at http://common-lisp.net/project/fomus/doc/). Strasheela, on the other hand, supports various topologies. However, ToFomus does not automatically perform a score topology transformation into the Fomus topology. Instead, ToFomus expects two optional accessor functions as arguments which allow for a user-defined topology transformation: getParts and getEvents. The function given to the argument getParts expects MyScore and returns a list of values corresponding to the Fomus parts. The function given to the argument getEvents expects a part and returns a list of values corresponding to the Fomus events. The default values for these accessor functions require that the topology of MyScore corresponds with the Fomus score topology. That is, for the default accessor functions, MyScore must have the following topology: <code>sim(seq(&lt;arbitrarily nested note&gt;+)+)</code>.<BR>
 Any Fomus setting for the score, a part, or event can be specified by the user as well. For this purpose, ToFomus expects three optional attribute accessor functions: getScoreKeywords, getPartKeywords, and getEventKeywords. These functions expect a Strasheela object corresponding to a Fomus score/part/event and return an Oz record whose features are the Fomus keywords for this objects and the feature values are the values for these keywords. For example, getEventKeywords may be set to the following function.<BR>
   fun {$ MyEvent}<BR>
      unit(off:{MyEvent getStartTimeInBeats($)}<BR>
	   dur:{MyEvent getDurationInBeats($)}<BR>
	   note:{MyEvent getPitchInMidi($)})<BR>
   end<BR>
<BR>
 Please inspect the implementation code to see the default values for the arguments. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity454">
<span class="keyword">proc</span>{<span class="functionname">OutputFomus</span> MyScore Args}<br>
<span class="string"> Outputs a fomus file with optional Args. The defaults are<BR>
   unit(file:"test"<BR>
	extension:".fms"<BR>
	dir:{Init.getStrasheelaEnv defaultFomusDir}<BR>
	...)<BR>
 See the doc of ToFomus for further optional arguments.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity455">
<span class="keyword">proc</span>{<span class="functionname">RenderFomus</span> MyScore Args}<br>
<span class="string"> Creates a fomus file from MyScore and calls the fomus command-line application on this file. The argument flags expects a list of fomus flags (default is nil). See the doc of OutputFomus for further arguments.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity456">
<span class="keyword">fun</span>{<span class="functionname">MakeCMEvent</span> Note Spec}<br>
<span class="string"> Returns CM note VS. Spec is a record of the form class(keywordSymbol1: noteAccessor1 ..). class is an atom, each keywordSymbol are an atom and each noteAccessor is funtions or method.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity457">
<span class="keyword">fun</span>{<span class="functionname">MakeCMScore</span> Score Args}<br>
<span class="string"> Transforms Score to Common Music score (VS). Common Music in turn can be used to output to various formats (e.g. MIDI, SuperCollider, Csound, music notation formats via FOMUS) or used to edit the score (e.g. with the CM Plotter). Optional Args features are containerOut (unary function, expecting a container and outputting a list of VS in the form [BeginVS Delimiter EndVS]), eventOut (unary function, expecting an event and outputting a VS), and furtherClauses (list of declarations, see MakeHierarchicVSScore for further details). The default eventOut outputs a CM 'midi' (i.e. events must be notes), the default containerOut outputs a CM 'seq' with the contained items as 'subobjects'.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity458">
<span class="keyword">proc</span>{<span class="functionname">OutputCMScore</span> Score Args}<br>
<span class="string"> Outputs Score into a CM score file. Optional Args features are dir (a VS, defaults to default CM dir in Strasheela env), file (VS, defaults to test), extension (VS, defaults to '.cm'), wrapper (a list of two VS as [WrapperHeader WrapperFooter]) and ioExtension (a VS). The Args feature wrapper specifies a Lisp expression surrounding the CM score in the output, it defaults to a var binding and an 'events' call for output with the same file name as specified by Args or Defaults and an extension as specified by ioExtension.<BR>
 Additionally, Args features are the Args supported by MakeCMScore (see there).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity444">
<span class="keyword">fun</span>{<span class="functionname">ToDottedList</span> X}<br>
<span class="string"> Recursively transform X into virtual string representing a Lisp list (a dotted list). X is a (possibly nested) list of virtual strings or a virtual string.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity445">
<span class="keyword">fun</span>{<span class="functionname">LispList</span> X}<br>
<span class="string"> Outputs virtual string with round paranthesis wrapped around X. X is either a virtual string or an Oz list of virtual strings<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity446">
<span class="keyword">fun</span>{<span class="functionname">RecordToLispKeywordList</span> X}<br>
<span class="string"> This functions transforms a 'literal' Oz value (i.e. a value with a textual representation) into a corresponding literal Lisp value. It transforms an Oz record or list (possibly nested) into a virtual strings representing a Lisp keyword list. Each Oz record feature is transformed into a Lisp keyword (i.e. there is a colon in front of it) and the Oz value into a the corresponding Lisp value. Any record label is omitted (except the whole record is a plain Oz atom). In case a feature is an integer the keyword is omitted.<BR>
 !! NB: Currently, a value must be either (i) a literal which can be used directly in a VS and doesn't need to be further translated into a Lisp value (e.g. an atom, number, or string), (ii) an Oz list of supported values, or (iii) a record of supported values. <BR>
 <BR>
 A record feature can only be an integer or a symbol<BR>
<BR>
 NB: The list is output without any line breaks. Use the pprint Lisp function for a more human-readable format.<BR>
 NB: Oz strings are lists of integers between 0 and 255, i.e. it can not be distinguished from a plain list of integers (e.g. denoting an all-interval series). Therefore, strings are not transformed into Lisp syntax!<BR>
 NB: Oz atoms can contain whitespace list 'Hi there' which result into two Lisp values!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity447">
<span class="keyword">fun</span>{<span class="functionname">ToLispKeywordList</span> X Spec}<br>
<span class="string"> Returns a lisp keyword list (a VS). X is a Strasheela score object (e.g. a note) and Spec is a record of the form unit(keyword1: accessor1 ..). The returned keyword list contains the record features as keywords and at these keywords the values of returned by the accessor (a unary function or method expecting X), i.e. ToLispKeywordList returns a VS of the form '(:keyword1'#{accessor1 X}# .. #')'<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity448">
<span class="keyword">fun</span>{<span class="functionname">OzToLisp</span> X Args}<br>
<span class="string"> OzToLisp transforms a literal Oz value (i.e. a value with a textual representation) into a corresponding literal Lisp value expressed by a VS. <BR>
 Supported Oz values are integers, floats, atoms, records/tuples, lists and virtual strings. These values can be freely nested. In principle, characters and strings are supported as well, see below. Not supported are Oz values without a textual representation (e.g. names, procedures, and chunks).<BR>
 Oz characters are equivalent to integers and Oz strings are equivalent to lists of integers. Therefore, the users must decide for either integer or character/string transformation. For this purpose, Arg expects the optional arguments charTransform and stringTransform (both default to false, i.e. characters and strings are per default transformed into Lisp integers / integers lists).<BR>
 The following list details how values are transformed:  <BR>
<BR>
 boolean -> boolean: true -> T, false -> nil [NB: Lisp2Oz: nil can also be empty list..]<BR>
 integer -> integer: 1 -> 1 [only decimal notation supported, NB: tilde ~ as unary minus for int and float supported]<BR>
 float -> float: 1.0 -> 1.0  [exponential notation supported]<BR>
 atom -> symbol: abc -> abc <BR>
 record -> keyword list: unit(a:1 b:2) -> (:a 1 :b 2 :record-label unit)<BR>
 tuple -> keyword list: unit(a b) -> (a b :record-label unit)<BR>
 list -> list: [a b c] -> (a b c)<BR>
 VS -> unaltered VS: "("#'some Test'#")" -> (some Test)<BR>
<BR>
 character -> character: &a -> (code-char 97) equivalent to 97 -> #\a<BR>
 string -> string: "Hi there" -> "Hi there"<BR>
<BR>
 NB: Virtual strings are passed unaltered: the user is responsible that any (composite) VS results in a valid Lisp value.<BR>
 <BR>
 NB: OzToLisp is very similar to RecordToLispKeywordList. The main difference is that OzToLisp can handle more cases truely in Lisp syntax (e.g. outputs something as 'Hi there' as |Hi there|). Moreover, the values are transformed in such a way that no information is lost and backtransformation (LispToOz) would be possible as well (e.g. the label of a record is preserved and the presence of the label marks a difference to a plain list).<BR>
<BR>
 TODO:<BR>
 <BR>
 * Lisp does not distinguish between cases, but for back-transformation of symbols etc in CamelCase I should possibly use symbols like |CamelCase|.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity449">
<span class="keyword">fun</span>{<span class="functionname">Note2ClmP</span> Note}
</code><br>

<code>
<a name="entity450">
<span class="keyword">fun</span>{<span class="functionname">MakeClmScoreFn</span> WithSoundArgs}<br>
<span class="string"> [a quick and probably temp. hack]<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity459">
<span class="keyword">proc</span>{<span class="functionname">PlaySound</span> Spec}<br>
<span class="string"> If a sndPlayer is specified, Strasheela assumes it has an own GUI and just calls it with the sound file. If a cmdlineSndPlayer is specified, Strasheela provides a minimal GUI for the cmdline soundPlayer. Spec is a record with optional arguments, the defaults are:<BR>
      unit(file:"test" % without extension<BR>
	   extension:".aiff"<BR>
	   soundDir:{Init.getStrasheelaEnv defaultSoundDir}<BR>
	   title:"Play Sound")<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity460">
<span class="keyword">proc</span>{<span class="functionname">Exec</span> Cmd Args}<br>
<span class="string"> Execute shell Cmd with Args, show standard out/error in the emulator and exit.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity461">
<span class="keyword">proc</span>{<span class="functionname">ExecNonQuitting</span> Cmd Args}<br>
<span class="string"> Execute shell Cmd with Args, show standard out/error in the emulator and exit. This is very similar to Exec, however the application Cmd does not automatically quit after finishing.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity462">
<span class="keyword">proc</span>{<span class="functionname">ExecWithOutput</span> Cmd Args Output}<br>
<span class="string"> Execute shell Cmd with Args, bind standard out/error to Output and exit.<BR>
<BR>
</span>
</code><br>

<a name="entity465">
<p class="margin"><div align="right"><a href="class29.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Provides an interface to interactive commandline programs like a shell or an interpreter. Start interactive program with the method init (see below), close it with the method close.<BR>
 More specialised classes (e.g. an interface to Common Lisp) may be obtained by subclasses..<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">Shell</span>&nbsp;<span class="keyword">from</span>&nbsp;<span class="reference">Open.pipe</span>&nbsp;<span class="reference">Open.text</span>

<ul><li><span class="functionname">init</span>(args:Args cmd:Cmd)<br>
</li><li><span class="functionname">cmd</span>(Cmd)<br>
</li><li><span class="functionname">showAll</span>()<br>
</li><li><span class="functionname">outputLine</span>($)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>
<h3>End</h3>
</div></body>
</html>