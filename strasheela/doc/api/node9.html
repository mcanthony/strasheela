<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Out</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="12" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">Init</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">GUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">LUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">MUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">Score</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">SMapping</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">SDistro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">Midi</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Functor defines means for output, e.g. means to output a Strasheela score to a csound score and play the result.<BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Out ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/source/Output.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>Open</li><li>OS</li><li>Tk</li><li>System</li><li>Compiler</li><li>FD</li><li>FS</li><li>Browser(browse:Browse)</li><li>OPIEnv at "<span class="string">x-oz://system/OPIEnv.ozf"
</span></li><li>Path at "<span class="string">x-ozlib://anders/tmp/Path/Path.ozf"
</span></li><li><a href="node3.html">GUtils</a> at "<span class="string">GeneralUtils.ozf"
</span></li><li><a href="node4.html">LUtils</a> at "<span class="string">ListUtils.ozf"
</span></li><li><a href="node5.html">MUtils</a> at "<span class="string">MusicUtils.ozf"
</span></li><li><a href="node6.html">Score</a> at "<span class="string">ScoreCore.ozf"
</span></li><li><a href="node2.html">Init</a> at "<span class="string">Init.ozf"
</span></li><li><a href="node11.html">Midi</a> at "<span class="string">MidiOutput.ozf"
</span></li><li>HS at "<span class="string">x-ozlib://anders/strasheela/HarmonisedScore/HarmonisedScore.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;P/1:<a href="#entity520"><span class="functionname">Show</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity521"><span class="functionname">WriteToFile</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity522"><span class="functionname">ReadFromFile</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity523"><span class="functionname">RecordToVS</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity524"><span class="functionname">RecordToVS_simple</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity525"><span class="functionname">ListToVS</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity526"><span class="functionname">ListToLines</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity527"><span class="functionname">MakeEventlist</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity528"><span class="functionname">OutputEventlist</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity529"><span class="functionname">ScoreToEvents</span></a>&gt;
</li><li>&lt;P/6:<a href="#entity530"><span class="functionname">MakeHierarchicVSScore</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity531"><span class="functionname">ToScoreConstructor</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity532"><span class="functionname">OutputScoreConstructor</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity533"><span class="functionname">SaveScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity534"><span class="functionname">LoadScore</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity535"><span class="functionname">MakeEvent2CsoundFn</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity536"><span class="functionname">MakeCsoundScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity537"><span class="functionname">OutputCsoundScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity539"><span class="functionname">RenderCsound</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity540"><span class="functionname">RenderAndPlayCsound</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity538"><span class="functionname">CallCsound</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity563"><span class="functionname">ToLilypond</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity562"><span class="functionname">ToLilypond2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity564"><span class="functionname">OutputLilypond</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity565"><span class="functionname">CallLilypond</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity566"><span class="functionname">ViewPDF</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity568"><span class="functionname">RenderLilypond</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity567"><span class="functionname">RenderAndShowLilypond</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity561"><span class="functionname">MakeLilyTupletClauses</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity555"><span class="functionname">SeqToLily</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity552"><span class="functionname">SimToLily</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity548"><span class="functionname">MakeNoteToLily</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity549"><span class="functionname">MakeNoteToLily2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity546"><span class="functionname">LilyMakePitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity547"><span class="functionname">LilyMakeFromMidiPitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity544"><span class="functionname">LilyMakeMicroPitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity545"><span class="functionname">LilyMakeEt72MarkFromMidiPitch</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity551"><span class="functionname">PauseToLily</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity550"><span class="functionname">LilyRest</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity542"><span class="functionname">LilyMakeRhythms</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity543"><span class="functionname">LilyMakeRhythms2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity556"><span class="functionname">IsOutmostSeq</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity557"><span class="functionname">IsOutmostSim</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity559"><span class="functionname">IsSingleStaffPolyphony</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity560"><span class="functionname">SingleStaffPolyphonyToLily</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity553"><span class="functionname">IsLilyChord</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity554"><span class="functionname">SimToLilyChord</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity558"><span class="functionname">GetUserLily</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity541"><span class="functionname">SetMaxLilyRhythm</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity571"><span class="functionname">OutputSCScore</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity570"><span class="functionname">MakeSCScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity569"><span class="functionname">MakeSCEventOutFn</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity572"><span class="functionname">SendOsc</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity573"><span class="functionname">SendSCserver</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity574"><span class="functionname">SendSClang</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity582"><span class="functionname">ToNonmensuralENP</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity583"><span class="functionname">OutputNonmensuralENP</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity584"><span class="functionname">ToFomus</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity585"><span class="functionname">OutputFomus</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity586"><span class="functionname">RenderFomus</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity587"><span class="functionname">MakeCMEvent</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity588"><span class="functionname">MakeCMScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity589"><span class="functionname">OutputCMScore</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity575"><span class="functionname">ToDottedList</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity576"><span class="functionname">LispList</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity577"><span class="functionname">RecordToLispKeywordList</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity578"><span class="functionname">ToLispKeywordList</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity579"><span class="functionname">OzToLisp</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity580"><span class="functionname">Note2ClmP</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity581"><span class="functionname">MakeClmScoreFn</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity590"><span class="functionname">PlaySound</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity591"><span class="functionname">Exec</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity592"><span class="functionname">ExecNonQuitting</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity593"><span class="functionname">ExecWithOutput</span></a>&gt;
</li><li>&lt;C:<a href="#entity596"><span class="type">Shell</span></a>&gt;
</li><li><span class="variablename">Midi</span>
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity520">
<span class="keyword">proc</span>{<span class="functionname">Show</span> X}<br>
<span class="string"> Simple tool for showing results in the emulator. The idea is, that sometimes we need to copy/paste results. Note that values without a print-representation (e.g., FD ints, procedures, objects) are *not* transformed into any contructor call, but output similarily to how they would be shown in the Browser.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity521">
<span class="keyword">proc</span>{<span class="functionname">WriteToFile</span> Output Path}<br>
<span class="string"> Writes/overwrites Output (a virtual string) to file at Path.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity522">
<span class="keyword">proc</span>{<span class="functionname">ReadFromFile</span> Path Result}<br>
<span class="string"> Reads the content of the text file at Path and returns it as string.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity523">
<span class="keyword">fun</span>{<span class="functionname">RecordToVS</span> X}<br>
<span class="string"> Transforms a (possibly nested) record into a single virtual string with Oz record syntax. RecordToVS also transforms the special Oz records with the labels '|' (i.e. lists) and '#' into their shorthand syntax. The virtual string output is not indented, but every record feature (or list element) starts a new line. As the output is basically a text value (i.e. no 'normal' Oz value anymore), FD and FS variables are transformed into a constructor call (FD.int and FS.var.bounds) which would create these variables when evaluated. <BR>
 NB: Value.toVirtualString does something very similar: it transforms nested data into their print representation. However, RecordToVS tries to create code which when executed results in same value, whereas Value.toVirtualString creates print representation. Also, RecordToVS does not expect any max width/depth arguments and attempts to format the output. <BR>
 NB: if X (or some value in X) is not of any of the types record (or list or #-pair) or virtual string, Value.toVirtualString is called on this value and the result is output as atom (i.e. surrounded by 'quotes').<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity524">
<span class="keyword">fun</span>{<span class="functionname">RecordToVS_simple</span> X}<br>
<span class="string"> A simpler form of RecordToVS which does not handle variables, and virtual strings are preseved as is.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity525">
<span class="keyword">fun</span>{<span class="functionname">ListToVS</span> Xs Delimiter}<br>
<span class="string"> Transforms Xs, a list of virtual strings, into a single virtual string. Delimiter is the virtual string between all list elements.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity526">
<span class="keyword">fun</span>{<span class="functionname">ListToLines</span> Xs}<br>
<span class="string"> Transforms a list of virtual strings into a single virtual string, every list element starts at a new line.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity527">
<span class="keyword">fun</span>{<span class="functionname">MakeEventlist</span> Score EventOut ScoreOut}<br>
<span class="string"> [Temp def? Def. not general enough] MakeEventlist generates a virtual string for output from Score. The unary function EventOut generates the output of a single event. The binary function ScoreOut combines all events to a score.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity528">
<span class="keyword">proc</span>{<span class="functionname">OutputEventlist</span> Score EventOut ScoreOut Path}<br>
<span class="string"> [Temp def -- use WriteToFile directly instead] OutputEventlist transforms Score for output and outputs it at Path. The unary function EventOut generates the output of a single event. The binary function ScoreOut combines all events to a score.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity529">
<span class="keyword">fun</span>{<span class="functionname">ScoreToEvents</span> MyScore Specs Args}<br>
<span class="string"> Transforms MyScore (a Strasheela score) into a list of events. Specs is a list of pairs in the form [Test1#Transform1 ...]. Each Test is a unary function (or method) expecting a score object and returning a boolean. Each Transform is a unary function expecting a score object and returning a list of events.<BR>
 The record Args expects the only optional argument test, a unary boolean function used to filter the set of score objects in MyScore: only  objects for which the test returns true are considered for processing. This test defaults to<BR>
   fun {Test X} {X isEvent($)} andthen {X isDet($)} andthen {X getDuration($)} > 0 end<BR>
  For every score object in MyScore which passes this Test, the appropriate Test#Transform pair is found out (i.e. the first pair whose test returns true for the score object). If no matching pair is found, the object is skipped. Otherwise, the respective Transform is applied to this score object and the result appended to the full result of ScoreToEvents.<BR>
 The following example implements a simple Strasheela score -> Csound score transformation. Only the notes in the Strasheela score are considered (everything else is ignored) and these notes are transformed into a csound score event.<BR>
   {Out.scoreToEvents MyScore [isNote#fun {$ MyNote}<BR>
					 [{Out.listToVS<BR>
					   [i1<BR>
					    {MyNote getStartTimeInSeconds($)}<BR>
					    {MyNote getDurationInSeconds($)}<BR>
					    {MyNote getPitchInMidi($)}<BR>
					    {MyNote getAmplitudeInVelocity($)}]<BR>
					   " "}]<BR>
				      end]<BR>
    unit}<BR>
   <BR>
 For example, the result returned could look like this:<BR>
   ["i1 0.0 1.0 60.0"<BR>
    "i1 1.0 2.0 62.0"<BR>
    "i1 2.0 4.0 64.0"]<BR>
   <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity530">
<span class="keyword">fun</span>{<span class="functionname">MakeHierarchicVSScore</span> Score EventOut SimOut SeqOut FurtherClauses}<br>
<span class="string"> [Temp def? Def. not general enough] Translates Score into some hierarchic score (a tree, not a graph) for output. EventOut, SimOut, and SeqOut are all functions which output a VS representation of the output format. The functions SimOut and SeqOut return something in the form [BeginVS Delimiter EndVS] -- the representation of their items will be placed between these "tags". FurtherClauses is a list to define additional output alternatives as in the form [testFnOrMeth1#Fn1 ..]. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity531">
<span class="keyword">fun</span>{<span class="functionname">ToScoreConstructor</span> MyScore Spec}<br>
<span class="string"> Creates an Oz program (as a VS) which re-constructs MyScore. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity532">
<span class="keyword">proc</span>{<span class="functionname">OutputScoreConstructor</span> MyScore Spec}<br>
<span class="string"> Stores an Oz program in a file which re-constructs MyScore. For example, this file can also be used for editing purposes.<BR>
 Args<BR>
<BR>
 'prefix' and 'postfix': VSs added before and after code for creating score object<BR>
 'exclude' and 'clauses': arguments of method toInitRecord<BR>
<BR>
 Defaults:<BR>
<BR>
   unit(file:"test"<BR>
	extension:".ssco"<BR>
	dir:{Init.getStrasheelaEnv defaultSScoDir}<BR>
	prefix:"declare \n MyScore \n = "<BR>
	postfix:""<BR>
       )<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity533">
<span class="keyword">proc</span>{<span class="functionname">SaveScore</span> MyScore Args}<br>
<span class="string"> Saves MyScore into a text file which can be compiled and loaded again later with LoadScore.<BR>
 NB: SaveScore internally uses toInitRecord (because a stateful data structure like an object can not be pickled). Therefore, all present restrictions of toInitRecord apply:  getInitInfo must be defined correctly for all classes and only tree-form score topologys are supported.<BR>
<BR>
 Saves MyScore into a pickle which can be loaded again later with LoadScore.<BR>
 NB: Only a fully determiend score can be pickled, otherwise an exception is raised.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity534">
<span class="keyword">fun</span>{<span class="functionname">LoadScore</span> Args}<br>
<span class="string"> Loads a pickeled score from path.<BR>
 NB: If the class definitions for the classes used in the score will have changed meanwhile, the loaded score will still use the new class definitions (it is re-created from the textual specification). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity535">
<span class="keyword">fun</span>{<span class="functionname">MakeEvent2CsoundFn</span> Instrument Spec}<br>
<span class="string"> Outputs unary function which transforms an Score.event into a csound note virtual string. <BR>
 Spec is a list of accessor functions/methods. However, for every accessor function/method a transformation function/method for the accessed data can be specified using the syntax Accessor#Transformator. All accessors mmust return a parameters (e.g. use getPitchParameter instead of getPitch).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity536">
<span class="keyword">fun</span>{<span class="functionname">MakeCsoundScore</span> EventVSs Header}<br>
<span class="string"> Returns a Csound score as a virtual string. EventVSs is a note list. Each note is a virtual string. Header is the Csound header, e.g. f statements.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity537">
<span class="keyword">proc</span>{<span class="functionname">OutputCsoundScore</span> MyScore Spec}<br>
<span class="string"> Create a csound score file of MyScore, but only include fully determined events. The defaults for Spec are:<BR>
   unit(file:"test" % without extension<BR>
	scoDir:{Init.getStrasheelaEnv defaultCsoundScoDir}<BR>
	header:nil<BR>
	event2CsoundFn:&lt;see source&gt;<BR>
	test:&lt;see source&gt;)<BR>
 header is the csound header VS (e.g. for f-tables).<BR>
 The default event2CsoundFn of OutputCsoundScore supports parameter unit specifications for the transformation process (see the Parameter documentation). Without determined Parameter unit the unit defaults to seconds for TimeParameters and midi for Pitches. The event2CsoundFn always returns seconds and midi pitches. <BR>
   always transforms timing parameters into seconds and <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity539">
<span class="keyword">proc</span>{<span class="functionname">RenderCsound</span> MyScore Spec}<br>
<span class="string"> Creates a csound score of all (determined) events in MyScore, and renders the score. See the documentation of OutputCsoundScore, CallCsound, and PlaySound for arguments in Spec (the PlaySound argument extension is substituted by the argument soundExtension).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity540">
<span class="keyword">proc</span>{<span class="functionname">RenderAndPlayCsound</span> MyScore Spec}<br>
<span class="string"> Creates a csound score of all (determined) events in MyScore, renders the score and plays the resulting sound. See the documentation of OutputCsoundScore, CallCsound, and PlaySound for arguments in Spec (the PlaySound argument extension is substituted by the argument soundExtension).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity538">
<span class="keyword">proc</span>{<span class="functionname">CallCsound</span> Spec}<br>
<span class="string"> Calls Csound with args in Spec and writes Csound messages on standard output (Oz emulator). Spec is a record with optional arguments. The defaults are:<BR>
   unit(orc:{Init.getStrasheelaEnv defaultOrcFile} % with extension!, e.g. "pluck.orc"<BR>
	file:"test" % without extension!<BR>
	soundExtension:{Init.getStrasheelaEnv defaultCsoundSoundExtension} % ".aiff"<BR>
	orcDir:{Init.getStrasheelaEnv defaultCsoundOrcDir}<BR>
	scoDir:{Init.getStrasheelaEnv defaultCsoundScoDir}<BR>
	soundDir:{Init.getStrasheelaEnv defaultSoundDir}<BR>
	csound:{Init.getStrasheelaEnv csound}<BR>
	flags:{Init.getStrasheelaEnv defaultCsoundFlags})<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity563">
<span class="keyword">fun</span>{<span class="functionname">ToLilypond</span> MyScore Args}<br>
<span class="string"> ToLilypond transforms a score object into a Lilypond score virtual string.<BR>
 By default, Strasheela supports the following cases for Lilypond score output. Strasheela temporal containers are transformed into their Lilypond counterpart. A simultaneous container becomes "<< .. >>" and a sequential container becomes "{ ... }". Nevertheless, there are a few special cases supported by default.<BR>
 By default, a staff is implicitly created for a sequential container which is either at the top-level or contained in a top-level simultaneous container. In typical Strasheela score topology for Lilypond output, a simultaneous is the top-level container and its items are sequential containers corresponding to staffs. If top-level is a sequential, then there is only a single staff. You can define arbitrary other nestings, but in such cases you should explicitly specify which container corresponds to a staff using the lily info-tag (see below). Moreover, you can also explicitly create staff or staff groups which last for the duration of their container only with the lily info-tag. The implicit staff creation can be switched off entirely by setting the optional argument 'implicitStaffs' to false.<BR>
 A simultaneous container within a staff containing only notes with common start and end times result in a chord (notes on a single staff sharing a stem). Single staff polyphony is supported: multiple (nested) sequentials and simultaneous container representing chords which are contained in a simultaneous (and which corresponds to or is situated in a staff) are output as single staff polyphony. Note that the description of these special cases is slightly simplified in this explanation, see the clause test function sources in Output.oz, when exactly these clauses apply.<BR>
 Note and pause objects (rests) are notated as expected, including ties for complex durations. However, their duration must exceed the minimum duration value supported (a 64th), shorted durations (or shorter tired fractions) are ignored. Also, offset times of score objects are notated as rests in front of the objects (again, except its duration is less than the minimum duration value supported (offset time notation is not supported by default for a top-level simultaneous container). <BR>
 Enharmonic notation is supported for enharmonic note objects (subclasses of HS.score.enharmonicSpellingMixinForNote such as HS.score.enharmonicNote). Tuplet output is supported via clauses conveniently created with the function MakeLilyTupletClauses (see there).<BR>
 <BR>
 Args: <BR>
 'clauses' (list of function or method pairs): The optional argument 'clauses' provides much control on how the Lilypond output is conducted. Internally, almost all functionality of ToLilypond is also defined by such clauses: further special cases (as described above) can be defined, or the default ones overwritten. 'clauses' expects a list of the form [Test1#ProcessingFun1 ...]. TestN and ProcessingFunN are both unary functions expecting a score object (an item instance such as notes or containers). If the Boolean function TestN is the first clause test which returns true for a score object in MyScore, then ProcessingFunN will create the Lilypond VS for this object. For example, the user may define a subclass of Score.note with an additional articulation attribute (e.g. values may be staccato, tenuto etc.) and the user then defines a clause which causes Lilypond to show the articulation by its common sign in the printed score.<BR>
 'wrapper' (list of two strings): The argument 'wrapper' expects a list of two VSs with legal Lilypond code. These VSs are inserted at the beginning and the end respecitively of the Lilypond score. Note that the Lilypond version statement is hardwired -- you should not add a version statement to your header (there is a 'version' argument expecting the version number as a VS, use at own risk).<BR>
 'implicitStaffs' (Boolean): whether staff declarations are created automatically.<BR>
 'hasImplicitStaff' (unary Boolan function): test for which containers staff declarations are created automatically (only supported for containers).<BR>
 'hasBreak' (Boolean): test after which container \break is inserted.<BR>
<BR>
 Arbitrary Lilypond code can be added to container and note objects via a tuple with the label 'lily' given to the info attribute of the score object. This tuple must only contain VSs which are legal Lilypond code. For containers, this lilypond code is always inserted in the Lilypond output before the container, for notes it is inserted after the note.<BR>
<BR>
 The argument defaults are shown below. <BR>
   <BR>
   unit(clauses:nil<BR>
	wrapper:["\\paper {}\n\n\\score{" %% empty paper def<BR>
		 "\n}"]<BR>
	implicitStaffs:true<BR>
	hasImplicitStaff: IsOutmostSeq<BR>
	hasBreak: fun {$ X} false end<BR>
	version:"2.10.0")<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity562">
<span class="keyword">fun</span>{<span class="functionname">ToLilypond2</span> MyScore Args}<br>
<span class="string"> [for clause definitions] like ToLilypond, except only the bare Lilypond score is created. That is, no Lilypond version number is inserted in the output, nor is the wrapper Lilypond code inserted (see wrapper argument of ToLilypond).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity564">
<span class="keyword">proc</span>{<span class="functionname">OutputLilypond</span> MyScore Args}<br>
<span class="string"> Transforms MyScore into a Lilypond score and writes it to a file. The default values for the optional arguments are shown below. See the documentation of ToLilypond for an explanation of additional arguments.<BR>
   <BR>
   unit(dir: {Init.getStrasheelaEnv defaultLilypondDir}<BR>
	file: "test" % !! file name without extention<BR>
       )<BR>
					  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity565">
<span class="keyword">proc</span>{<span class="functionname">CallLilypond</span> Args}<br>
<span class="string"> Calls Lilypond on a Lilypond file specified by Args. The defaults of Args are:<BR>
   unit(dir: {Init.getStrasheelaEnv defaultLilypondDir}<BR>
	file: test) % !! file name without extention<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity566">
<span class="keyword">proc</span>{<span class="functionname">ViewPDF</span> Args}<br>
<span class="string"> Calls a PDF viewer on a PDF file specified by Args. The name of the PDF file is given without extension. The PDF viewer application defaults to the value of the Strasheela environment variable pdfViewer. The defaults of Spec are:<BR>
   unit(dir: {Init.getStrasheelaEnv defaultLilypondDir}<BR>
	file: test<BR>
	pdfViewer: {Init.getStrasheelaEnv pdfViewer}<BR>
	extension:".pdf")<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity568">
<span class="keyword">proc</span>{<span class="functionname">RenderLilypond</span> MyScore Args}<br>
<span class="string"> Outputs a Lilypond file for MyScore and calls Lilypond to process it. See ToLilypond, OutputLilypond and CallLilypond for details on Spec.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity567">
<span class="keyword">proc</span>{<span class="functionname">RenderAndShowLilypond</span> MyScore Args}<br>
<span class="string"> Outputs a Lilypond file for MyScore, calls Lilypond to process it, and calls the PDF viewer with the result. See ToLilypond, OutputLilypond, CallLilypond, and ViewPDF for details on Args.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity561">
<span class="keyword">fun</span>{<span class="functionname">MakeLilyTupletClauses</span> Fractions}<br>
<span class="string"> [for clause definitions] MakeLilyTupletClauses creates a list of Lilypond clauses for tuplet output. Fractions is a list of pairs Numerator#Denominator indicating the fractions of the tuplets. For example, clauses for triplets are created with he fraction 2#3 and clauses for quintuplets with the fraction 2#5. Tuplets are recognised automatically in the score by the duration of score elements (notes and pause objects). The time unit must be set to beats(N), where N is some quarter note division which allows to express all required durations. For example, if the time unit is beats(60) then the duration 60 indicates a quarter note, 30 indicates an eigth note, three notes of duration 20 form an eigth note triplet and 5 notes of duration 6 form a sixteenth note quintuplet.   <BR>
 LIMITATIONS: Rests must be expressed explicitly with pause objects, rests expressed by the offset time of score objects are not notated correctly if their duration should be part of a tuplet. Dotted notes at the beginning of a tuplet do not work. Tuplets only work correctly for score elements within a single sequential container: a tuplet must not extend across container boundaries. Also, tuplets cannot be nested. Due to these shortcomings, the default Lilypond output does not support tuplets.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity555">
<span class="keyword">fun</span>{<span class="functionname">SeqToLily</span> Seq Args}<br>
<span class="string"> [for clause definitions] creates Lilypond output (a VS) for a sequential container. Args is a record of optional args (clauses and implicitStaffs).<BR>
 Default Lilypond output uses this definition. Using this function may simplify writing custom output clauses which overwrite the default output.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity552">
<span class="keyword">fun</span>{<span class="functionname">SimToLily</span> Sim Args}<br>
<span class="string"> [for clause definitions] creates Lilypond output (a VS) for a simultaneous container. Args is a record of optional args (clauses and implicitStaffs).<BR>
 Default Lilypond output uses this definition. Using this function may simplify writing custom output clauses which overwrite the default output.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity548">
<span class="keyword">fun</span>{<span class="functionname">MakeNoteToLily</span> MakeAddedSigns}<br>
<span class="string"> [for clause definitions] Returns unary function which expects a note object and returns a Lilypond note output (a VS). Simplified version of MakeNoteToLily2.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity549">
<span class="keyword">fun</span>{<span class="functionname">MakeNoteToLily2</span> MakePitch MakeAddedSigns}<br>
<span class="string"> [for clause definitions] Returns unary function which expects a note object and returns a Lilypond note output (a VS). MakePitch is a unary function expecting the note and returning a Lilypond pitch (a VS). MakeAddedSigns is unary function expecting the note and returning a VS of arbitrary added signs (e.g. fingering marks, articulation marks etc.). MakeNoteToLily2 adds the rhythmic information and cares for ties.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity546">
<span class="keyword">fun</span>{<span class="functionname">LilyMakePitch</span> PitchParam}<br>
<span class="string"> [for clause definitions] creates Lilypond pitch output (a VS) for a pitch parameter.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity547">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeFromMidiPitch</span> MidiPitch}<br>
<span class="string"> [for clause definitions] creates Lilypond pitch output (a VS) for a midi pitch value (an integer).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity544">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeMicroPitch</span> PitchParam}<br>
<span class="string"> [for clause definitions] creates Lilypond 72 ET microtonal pitch output (a VS) for a pitch parameter. Note: works only if the pitch unit is et72.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity545">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeEt72MarkFromMidiPitch</span> MidiPitch}<br>
<span class="string"> [for clause definitions] Returns a Lily fingering mark (a virtual string) which represents a micro-tonal tuning deviation in 72 ET temperament.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity551">
<span class="keyword">fun</span>{<span class="functionname">PauseToLily</span> MyPause}<br>
<span class="string"> [for clause definitions] Expects a pause object and returns a Lilypond rest (a VS).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity550">
<span class="keyword">fun</span>{<span class="functionname">LilyRest</span> PauseDurInBeats}<br>
<span class="string"> [for clause definitions] Expects a pause duration in beats (a float) and returns a Lilypond rest (a VS).  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity542">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeRhythms</span> DurationParam}<br>
<span class="string"> [for clause definitions] creates Lilypond duration output (a list of Lilypond rhythm values, which in the end are tied together) for a duration parameter.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity543">
<span class="keyword">fun</span>{<span class="functionname">LilyMakeRhythms2</span> DurationInBeats}<br>
<span class="string"> [for clause definitions] creates Lilypond duration output (a list of Lilypond rhythm values, which in the end are tied together) for a duration measured in beats (a float).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity556">
<span class="keyword">fun</span>{<span class="functionname">IsOutmostSeq</span> X}<br>
<span class="string"> [for clause definitions and arg hasImplicitStaff] Tests whether X is an Outmost sequential container, i.e. a container which has no direct or indirect temporal container which is also a sequential container. X is either the top-level container, or (the most common case) contained in a top-level simultaneous container.<BR>
 An outmost sequential implicitly creates a staff by default. 			%%<BR>
</span>
</code><br>

<code>
<a name="entity557">
<span class="keyword">fun</span>{<span class="functionname">IsOutmostSim</span> X}<br>
<span class="string"> [for clause definitions and arg hasImplicitStaff] Tests whether X is a simultaneous container and there is no simultaneous container in which X is nested.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity559">
<span class="keyword">fun</span>{<span class="functionname">IsSingleStaffPolyphony</span> X}<br>
<span class="string"> [for clause definitions] Returns true if X is a simultaneous container which containes multiple voices; each voice is a sequential which contains only (i) notes, (ii) simultaneous containers which are chords or (iii) sequentials which in turn contain only notes or chords.<BR>
 By default, such a simultaneous container creates a single staff polyphony.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity560">
<span class="keyword">fun</span>{<span class="functionname">SingleStaffPolyphonyToLily</span> Sim Args}<br>
<span class="string"> [for clause definitions] Outputs X (for which IsSingleStaffPolyphony must return true) as a single staff polyphony Lily VS. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity553">
<span class="keyword">fun</span>{<span class="functionname">IsLilyChord</span> X}<br>
<span class="string"> [for clause definitions] Returns true if X can be notated as a chord, i.e. X is a simultaneous which contains only notes with equal offset time, start and end times<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity554">
<span class="keyword">fun</span>{<span class="functionname">SimToLilyChord</span> Sim}<br>
<span class="string"> [for clause definitions] Outputs Sim (for which IsLilyChord must return true) as a Lilypond chord VS. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity558">
<span class="keyword">fun</span>{<span class="functionname">GetUserLily</span> X}<br>
<span class="string"> [for clause definitions] Accesses tuple with label 'lily' in info feature of X, and returns VS (concatenating all lily tuple elements). The lily tuple must only contain VSs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity541">
<span class="keyword">proc</span>{<span class="functionname">SetMaxLilyRhythm</span> Dur}<br>
<span class="string"> When outputting a Lilypond file, Strasheela automatically splits very long notes (or other score objects notated by notes such as chords or scales) into multiple notes connected by ties. The maximum duration notated by a single note can be set with this procedure. Dur is a float measured in quarternotes. For example, 2.0 indicates a halve note and 0.5 an eighth note. The maximum duration supported by Lilypond is a longa (16.0). The default is 4.0 (a whole note).<BR>
 It is recommended to set Dur to the length of your bars (e.g., 4.0 for 4/4).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity571">
<span class="keyword">proc</span>{<span class="functionname">OutputSCScore</span> Score SCEventOut Spec}
</code><br>

<code>
<a name="entity570">
<span class="keyword">fun</span>{<span class="functionname">MakeSCScore</span> Score SCEventOut MkContainerOut FurtherClauses}<br>
<span class="string"> Generate a SuperCollider score in hierarchic score format (a VS). SCEventOut is a unary function transforming a single SDL event into a SC event (a VS). The TimeParameter units must be determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity569">
<span class="keyword">fun</span>{<span class="functionname">MakeSCEventOutFn</span> PlayerOut}<br>
<span class="string"> [aux means for MakeSCScore] Outputs a unary function which transforms a SDL event into a SC event (a VS). PlayerOut is a unary function with the event a argument which returns a SC player call (a VS). The TimeParameter units must be determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity572">
<span class="keyword">proc</span>{<span class="functionname">SendOsc</span> Host Port OSCcmd}<br>
<span class="string"><BR>
 NB: the network address must be set by setting the environment var REMOTE_ADDR (defaults to '127.0.0.1').<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity573">
<span class="keyword">proc</span>{<span class="functionname">SendSCserver</span> OSCcmd}<br>
<span class="string">[tmp restricted def?]<BR>
</span>
</code><br>

<code>
<a name="entity574">
<span class="keyword">proc</span>{<span class="functionname">SendSClang</span> OSCcmd}<br>
<span class="string">[tmp restricted def?]<BR>
</span>
</code><br>

<code>
<a name="entity582">
<span class="keyword">fun</span>{<span class="functionname">ToNonmensuralENP</span> TheScore Args}<br>
<span class="string"> Exports TheScore (a Strasheela score) into a non-mensural ENP score (a VS). The ENP format is rather fixed, whereas the information contained in the Strasheela score format is highly user-customisable. Therefore, the export-process is also highly user-customisable. <BR>
 An ENP score has a fixed topology. The non-mensural ENP has the following nesting: <code>score(part(voice(chord(note+)+)+)+)</code>. See the PWGL documentation for details. <BR>
 Strasheela, on the other hand, supports various topologies. However, ToNonmensuralENP does not automatically perform a score topology transformation into the ENP topology. Instead, ToNonmensuralENP expects a number of optional accessor functions as arguments (e.g. getScore, getParts, getVoices) which allow for a user-defined topology transformation. These functions expect a (subpart of the) score and return the contained objects according to the ENP topology. For instance, the function getVoices expects a Strasheela object corresponding to an ENP part and returns a list of Strasheela object corresponding to ENP voices. The default values for these accessor functions require that the topology of TheScore fully corresponds with the ENP score topology. That is, for the default accessor functions, TheScore must have the following topology: <code>sim(sim(seq(sim(note+)+)+)+)</code>. The set of all supported accessor functions (together with their default values) is given below.<BR>
 Any ENP attribute of a score object can be specified by the user. For this purpose, ToNonmensuralENP expects a number of optional attribute accessor functions (e.g. getScoreKeywords, getPartKeywords). These functions expect a Strasheela object corresponding to an ENP part and returns an Oz record whose features are the ENP keywords for this objects and the feature values are the values for these ENP keywords. See the default of getNoteKeywords for an example.<BR>
 In addition, enp syntax can be given directly to score objects via an info tag/record with the label 'enp' where the keywords are the record features with their associated values (e.g., enp(expression: [accent])). In case a keyword is defined both with an acessor function (e.g., getVoiceKeywords) and directly as an enp info tag, then the info tag is taken instead. <BR>
<BR>
 Default arguments: <BR>
   unit(getScore:fun {$ X} X end<BR>
	getParts:fun {$ MyScore} {MyScore getItems($)} end<BR>
	getVoices:fun {$ MyPart} {MyPart getItems($)} end<BR>
	getChords:fun {$ MyVoice} {MyVoice getItems($)} end<BR>
	getNotes:fun {$ MyChord} {MyChord getItems($)} end<BR>
	getScoreKeywords:fun {$ MyScore}<BR>
			    unit % put further ENP score keywords here<BR>
			 end<BR>
	getPartKeywords:fun {$ MyPart}<BR>
			   unit % put further ENP part keywords here<BR>
			end<BR>
	getVoiceKeywords:fun {$ MyVoice}<BR>
			    unit % put further ENP voice keywords here<BR>
			 end<BR>
	getChordKeywords:fun {$ MyChord}<BR>
			    unit % put further ENP chord keywords here<BR>
			 end<BR>
	getNoteKeywords:fun {$ MyNote}<BR>
 put further ENP note keywords here<BR>
			   unit('offset-time': {MyNote getOffsetTimeInSeconds($)})<BR>
			end)<BR>
<BR>
 Note: this function also works for the format expected by the simple format of the PWGL library KSQuant. You need to set the argument toKSQuant to true for this purpose.<BR>
 <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity583">
<span class="keyword">proc</span>{<span class="functionname">OutputNonmensuralENP</span> MyScore Args}<br>
<span class="string">  Exports MyScore (a Strasheela score) into a text file with a non-mensural ENP score. The file path is specified with the arguments file, extension and dir. For further arguments see the ToNonmensuralENP documentation.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity584">
<span class="keyword">fun</span>{<span class="functionname">ToFomus</span> MyScore Args}<br>
<span class="string"> Exports MyScore into Fomus format (as a VS). The Fomus format is rather fixed, whereas the information contained in the Strasheela score format is highly user-customisable. Therefore, the export-process is also highly user-customisable.<BR>
 A Fomus score has a fixed topology: <code>score(part(event+)+)</code> (see the Fomus documentation at http://common-lisp.net/project/fomus/doc/). Strasheela, on the other hand, supports various topologies. However, ToFomus does not automatically perform a score topology transformation into the Fomus topology. Instead, ToFomus expects two optional accessor functions as arguments which allow for a user-defined topology transformation: getParts and getEvents. The function given to the argument getParts expects MyScore and returns a list of values corresponding to the Fomus parts. The function given to the argument getEvents expects a part and returns a list of values corresponding to the Fomus events. The default values for these accessor functions require that the topology of MyScore corresponds with the Fomus score topology. That is, for the default accessor functions, MyScore must have the following topology: <code>sim(seq(&lt;arbitrarily nested note&gt;+)+)</code>.<BR>
 Any Fomus setting for the score, a part, or event can be specified by the user as well. For this purpose, ToFomus expects three optional attribute accessor functions: getScoreKeywords, getPartKeywords, and getEventKeywords. These functions expect a Strasheela object corresponding to a Fomus score/part/event and return an Oz record whose features are the Fomus keywords for this objects and the feature values are the values for these keywords. For example, getEventKeywords may be set to the following function.<BR>
   fun {$ MyEvent}<BR>
      unit(off:{MyEvent getStartTimeInBeats($)}<BR>
	   dur:{MyEvent getDurationInBeats($)}<BR>
	   note:{MyEvent getPitchInMidi($)})<BR>
   end<BR>
<BR>
 Please inspect the implementation code to see the default values for the arguments. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity585">
<span class="keyword">proc</span>{<span class="functionname">OutputFomus</span> MyScore Args}<br>
<span class="string"> Outputs a fomus file with optional Args. The defaults are<BR>
   unit(file:"test"<BR>
	extension:".fms"<BR>
	dir:{Init.getStrasheelaEnv defaultFomusDir}<BR>
	...)<BR>
 See the doc of ToFomus for further optional arguments.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity586">
<span class="keyword">proc</span>{<span class="functionname">RenderFomus</span> MyScore Args}<br>
<span class="string"> Creates a fomus file from MyScore and calls the fomus command-line application on this file. The argument flags expects a list of fomus flags (default is nil). See the doc of OutputFomus for further arguments.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity587">
<span class="keyword">fun</span>{<span class="functionname">MakeCMEvent</span> Note Spec}<br>
<span class="string"> Returns CM note VS. Spec is a record of the form class(keywordSymbol1: noteAccessor1 ..). class is an atom, each keywordSymbol are an atom and each noteAccessor is funtions or method.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity588">
<span class="keyword">fun</span>{<span class="functionname">MakeCMScore</span> Score Args}<br>
<span class="string"> Transforms Score to Common Music score (VS). Common Music in turn can be used to output to various formats (e.g. MIDI, SuperCollider, Csound, music notation formats via FOMUS) or used to edit the score (e.g. with the CM Plotter). Optional Args features are containerOut (unary function, expecting a container and outputting a list of VS in the form [BeginVS Delimiter EndVS]), eventOut (unary function, expecting an event and outputting a VS), and furtherClauses (list of declarations, see MakeHierarchicVSScore for further details). The default eventOut outputs a CM 'midi' (i.e. events must be notes), the default containerOut outputs a CM 'seq' with the contained items as 'subobjects'.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity589">
<span class="keyword">proc</span>{<span class="functionname">OutputCMScore</span> Score Args}<br>
<span class="string"> Outputs Score into a CM score file. Optional Args features are dir (a VS, defaults to default CM dir in Strasheela env), file (VS, defaults to test), extension (VS, defaults to '.cm'), wrapper (a list of two VS as [WrapperHeader WrapperFooter]) and ioExtension (a VS). The Args feature wrapper specifies a Lisp expression surrounding the CM score in the output, it defaults to a var binding and an 'events' call for output with the same file name as specified by Args or Defaults and an extension as specified by ioExtension.<BR>
 Additionally, Args features are the Args supported by MakeCMScore (see there).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity575">
<span class="keyword">fun</span>{<span class="functionname">ToDottedList</span> X}<br>
<span class="string"> Recursively transform X into virtual string representing a Lisp list (a dotted list). X is a (possibly nested) list of virtual strings or a virtual string.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity576">
<span class="keyword">fun</span>{<span class="functionname">LispList</span> X}<br>
<span class="string"> Outputs virtual string with round paranthesis wrapped around X. X is either a virtual string or an Oz list of virtual strings<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity577">
<span class="keyword">fun</span>{<span class="functionname">RecordToLispKeywordList</span> X}<br>
<span class="string"> This functions transforms a 'literal' Oz value (i.e. a value with a textual representation) into a corresponding literal Lisp value. It transforms an Oz record or list (possibly nested) into a virtual strings representing a Lisp keyword list. Each Oz record feature is transformed into a Lisp keyword (i.e. there is a colon in front of it) and the Oz value into a the corresponding Lisp value. Any record label is omitted (except the whole record is a plain Oz atom). In case a feature is an integer the keyword is omitted.<BR>
 !! NB: Currently, a value must be either (i) a literal which can be used directly in a VS and doesn't need to be further translated into a Lisp value (e.g. an atom, number, or string), (ii) an Oz list of supported values, or (iii) a record of supported values. <BR>
 <BR>
 A record feature can only be an integer or a symbol<BR>
<BR>
 NB: The list is output without any line breaks. Use the pprint Lisp function for a more human-readable format.<BR>
 NB: Oz strings are lists of integers between 0 and 255, i.e. it can not be distinguished from a plain list of integers (e.g. denoting an all-interval series). Therefore, strings are not transformed into Lisp syntax!<BR>
 NB: Oz atoms can contain whitespace list 'Hi there' which result into two Lisp values!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity578">
<span class="keyword">fun</span>{<span class="functionname">ToLispKeywordList</span> X Spec}<br>
<span class="string"> Returns a lisp keyword list (a VS). X is a Strasheela score object (e.g. a note) and Spec is a record of the form unit(keyword1: accessor1 ..). The returned keyword list contains the record features as keywords and at these keywords the values of returned by the accessor (a unary function or method expecting X), i.e. ToLispKeywordList returns a VS of the form '(:keyword1'#{accessor1 X}# .. #')'<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity579">
<span class="keyword">fun</span>{<span class="functionname">OzToLisp</span> X Args}<br>
<span class="string"> OzToLisp transforms a literal Oz value (i.e. a value with a textual representation) into a corresponding literal Lisp value expressed by a VS. <BR>
 Supported Oz values are integers, floats, atoms, records/tuples, lists and virtual strings. These values can be freely nested. In principle, characters and strings are supported as well, see below. Not supported are Oz values without a textual representation (e.g. names, procedures, and chunks).<BR>
 Oz characters are equivalent to integers and Oz strings are equivalent to lists of integers. Therefore, the users must decide for either integer or character/string transformation. For this purpose, Arg expects the optional arguments charTransform and stringTransform (both default to false, i.e. characters and strings are per default transformed into Lisp integers / integers lists).<BR>
 The following list details how values are transformed:  <BR>
<BR>
 boolean -> boolean: true -> T, false -> nil [NB: Lisp2Oz: nil can also be empty list..]<BR>
 integer -> integer: 1 -> 1 [only decimal notation supported, NB: tilde ~ as unary minus for int and float supported]<BR>
 float -> float: 1.0 -> 1.0  [exponential notation supported]<BR>
 atom -> symbol: abc -> abc <BR>
 record -> keyword list: unit(a:1 b:2) -> (:a 1 :b 2 :record-label unit)<BR>
 tuple -> keyword list: test(a b) -> (a b :record-label test)<BR>
 list -> list: [a b c] -> (a b c)<BR>
 VS -> unaltered VS: "("#'some Test'#")" -> (some Test)<BR>
<BR>
 character -> character: &a -> (code-char 97) equivalent to 97 -> #\a<BR>
 string -> string: "Hi there" -> "Hi there"<BR>
<BR>
 NB: Virtual strings are passed unaltered: the user is responsible that any (composite) VS results in a valid Lisp value.<BR>
 NB: the keyword-value pair :record-label <label> is always the last two elements in a record/tuple list.<BR>
 <BR>
 NB: OzToLisp is very similar to RecordToLispKeywordList. The main difference is that OzToLisp can handle more cases truely in Lisp syntax (e.g. outputs something as 'Hi there' as |Hi there|). Moreover, the values are transformed in such a way that no information is lost and backtransformation (LispToOz) would be possible as well (e.g. the label of a record is preserved and the presence of the label marks a difference to a plain list).<BR>
<BR>
 TODO:<BR>
 <BR>
 * Lisp does not distinguish between cases, but for back-transformation of symbols etc in CamelCase I should possibly use symbols like |CamelCase|.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity580">
<span class="keyword">fun</span>{<span class="functionname">Note2ClmP</span> Note}
</code><br>

<code>
<a name="entity581">
<span class="keyword">fun</span>{<span class="functionname">MakeClmScoreFn</span> WithSoundArgs}<br>
<span class="string"> [a quick and probably temp. hack]<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity590">
<span class="keyword">proc</span>{<span class="functionname">PlaySound</span> Spec}<br>
<span class="string"> If a sndPlayer is specified, Strasheela assumes it has an own GUI and just calls it with the sound file. If a cmdlineSndPlayer is specified, Strasheela provides a minimal GUI for the cmdline soundPlayer. Spec is a record with optional arguments, the defaults are:<BR>
      unit(file:"test" % without extension<BR>
	   extension:".aiff"<BR>
	   soundDir:{Init.getStrasheelaEnv defaultSoundDir}<BR>
	   title:"Play Sound")<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity591">
<span class="keyword">proc</span>{<span class="functionname">Exec</span> Cmd Args}<br>
<span class="string"> Execute shell Cmd with Args, show standard out/error in the emulator and exit.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity592">
<span class="keyword">proc</span>{<span class="functionname">ExecNonQuitting</span> Cmd Args}<br>
<span class="string"> Execute shell Cmd with Args, show standard out/error in the emulator and exit. This is very similar to Exec, however the application Cmd does not automatically quit after finishing.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity593">
<span class="keyword">proc</span>{<span class="functionname">ExecWithOutput</span> Cmd Args Output}<br>
<span class="string"> Execute shell Cmd with Args, bind standard out/error to Output and exit.<BR>
<BR>
</span>
</code><br>

<a name="entity596">
<p class="margin"><div align="right"><a href="class29.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Provides an interface to interactive commandline programs like a shell or an interpreter. Start interactive program with the method init (see below), close it with the method close. The Shell object features cmd and args bind the respective init arguments.<BR>
<BR>
 More specialised classes (e.g. an interface to Common Lisp) may be obtained by subclasses..<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">Shell</span>&nbsp;<span class="keyword">from</span>&nbsp;<span class="reference">Open.pipe</span>&nbsp;<span class="reference">Open.text</span>
<br>&nbsp;&nbsp;&nbsp;<span class="keyword">feat</span>&nbsp;cmd&nbsp;args

<ul><li><span class="functionname">init</span>(args:Args cmd:Cmd)<br>
</li><li><span class="functionname">cmd</span>(Cmd)<br>
</li><li><span class="functionname">showAll</span>()<br>
</li><li><span class="functionname">outputLine</span>($)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>
<h3>End</h3>
</div></body>
</html>