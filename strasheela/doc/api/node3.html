<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>GUtils</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="12" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">Init</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">GUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">LUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">MUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">Score</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">SMapping</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">SDistro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">Midi</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor defines some general utilities<BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>GUtils ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/source/GeneralUtils.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>Module</li><li>OS</li><li>Combinator</li><li>Property</li><li>QTk at "<span class="string">x-oz://system/wp/QTk.ozf"
</span></li><li>FD</li><li>FS</li><li><a href="node4.html">LUtils</a> at "<span class="string">ListUtils.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li><span class="variablename">Pi</span>
</li><li>&lt;P/3:<a href="#entity86"><span class="functionname">XOr</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity87"><span class="functionname">Cases</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity88"><span class="functionname">IsFS</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity89"><span class="functionname">MakeSingletonSet</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity90"><span class="functionname">IntsToFS</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity91"><span class="functionname">Percent</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity92"><span class="functionname">Identity</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity93"><span class="functionname">Random</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity94"><span class="functionname">RandIntoRange</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity95"><span class="functionname">MakeRandomGenerator</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity96"><span class="functionname">SetRandomGeneratorSeed</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity97"><span class="functionname">Log</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity98"><span class="functionname">Mod_Float</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity99"><span class="functionname">IsDivisible</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity102"><span class="functionname">ToProc</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity103"><span class="functionname">ToFun</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity104"><span class="functionname">Procs2Proc</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity107"><span class="functionname">ExtendedScriptToScript</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity101"><span class="functionname">ApplySelected</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity100"><span class="functionname">EncodeRatio</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity108"><span class="functionname">SelectArg</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity109"><span class="functionname">TimeVString</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity110"><span class="functionname">GetCounterAndIncr</span></a>&gt;
</li><li>&lt;P/0:<a href="#entity111"><span class="functionname">ResetCounter</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity105"><span class="functionname">UnarySkip</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity106"><span class="functionname">BinarySkip</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity112"><span class="functionname">TakeFeatures</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity113"><span class="functionname">RecursiveAdjoin</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity114"><span class="functionname">ModuleLink</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity115"><span class="functionname">ModuleApply</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity116"><span class="functionname">TimeSpend</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity117"><span class="functionname">Assert</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity118"><span class="functionname">WarnGUI</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity119"><span class="functionname">InfoGUI</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity120"><span class="functionname">ErrorGUI</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity86">
<span class="keyword">fun</span>{<span class="functionname">XOr</span> B1 B2}<br>
<span class="string"> Defines exclusive or: XOr returns true if only B1 or B2 are true. XOr returns false if B1 and B2 are both false or both true.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity87">
<span class="keyword">fun</span>{<span class="functionname">Cases</span> X Clauses}<br>
<span class="string"> Cases defines a general conditional similar to an 'if then elseif ...' statement. X is some datum to process dependent on boolean tests. Clauses is a list of test and action functions/methods in the form [Test1#Process1 Test2#Process2 ...]. The first test returning true for X 'fires' its Process and Cases returns the result of {Process X}. If no test returns true for X Cases returns nil.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity88">
<span class="keyword">fun</span>{<span class="functionname">IsFS</span> X}<br>
<span class="string"> IsFS returns true if X is a FS variable (determined or not) and false otherwise. This function is necessary, because the primitive Oz functions FS.var.is and FS.value.is behave differently for determined and undetermined FS variables.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity89">
<span class="keyword">proc</span>{<span class="functionname">MakeSingletonSet</span> D MyFS}<br>
<span class="string"> Expects D (a FD int) and returns a singleton FS which contains only D.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity90">
<span class="keyword">proc</span>{<span class="functionname">IntsToFS</span> Ds MyFS}<br>
<span class="string"> Constraints that Ds (a list of FD ints) are all contained in MyFS (a FS, implicitly declared), but no other integer. This definition is similar to FS.int.match, but Ds must not be in increasing order.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity91">
<span class="keyword">proc</span>{<span class="functionname">Percent</span> N NoAll Result}<br>
<span class="string"> Expects MyFS (a FS) and returns Ds, a list of FD ints which are all contained in MyFS.<BR>
 This definition is similar to FS.int.match, but Ds must not be in increasing order. This definiiton is also similar to IntsToFS, but Ds are created by FsToInts. The length of Ds is the cardiality of MyFS, and all elements in Ds are constrained to be pairwise distinct.<BR>
<BR>
 Note: blocks until cardiality of MyFS is determined<BR>
 */<BR>
    proc {FsToInts MyFS ?Ds}<BR>
       Ds = {FD.list {FS.card MyFS} 0#FD.sup}<BR>
    in<BR>
       {FS.unionN {Map Ds fun {$ D} {MakeSingletonSet D} end}<BR>
        MyFS}<BR>
       {FD.distinct Ds}<BR>
    end<BR>
<BR>
<BR>
/** %% Constrains percentage of N (FD int) if NoAll (FD int) indicates 100 percent. Result is implicitly declared a FD int.<BR>
 Example:  {Percent 4 6} = 66  <BR>
 Note the rounding to 66 percent (better do not rely on exact value of Result but constraint it, e.g., by a comparison such as Result >: 50).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity92">
<span class="keyword">fun</span>{<span class="functionname">Identity</span> X}<br>
<span class="string"> The Identity function returns its argument.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity93">
<span class="keyword">fun</span>{<span class="functionname">Random</span> Max}<br>
<span class="string"> Returns a random integer in interval [0, Max-1]. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity94">
<span class="keyword">fun</span>{<span class="functionname">RandIntoRange</span> Rand Min Max}<br>
<span class="string"> Expects a random integer generated by {OS.rand} and returns a random integer in Min - Max (Min and Max are integers).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity95">
<span class="keyword">fun</span>{<span class="functionname">MakeRandomGenerator</span> }<br>
<span class="string"> Returns a random number generator (a null-ary function) which returns a pseudo-random integer whenever it is called. Every returned random number generator will always produce the same number sequence: all random values are 'recorded' behind the scene in the top-level space. In other words, the random number generator is deterministic. Such a random generator can be used for a randomised value ordering, and the resulting distribution strategy can still apply recomputation (see SDistro.makeRandomDistributionValue). In such as case, MakeRandomGenerator must be called inside script. The convenient Strasheela solvers in SDistro do that implicitly. <BR>
 MakeRandomGenerator can be (re)-initialised with SetRandomGeneratorSeed.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity96">
<span class="keyword">proc</span>{<span class="functionname">SetRandomGeneratorSeed</span> Seed}<br>
<span class="string"> Sets the seed for the random number generator used by MakeRandomGenerator (which internally uses OS.rand). If Seed is 0, the seed will be generated from the current time.<BR>
 NOTE: calling SetRandomGeneratorSeed will corrupt any random number generator previously created with MakeRandomGenerator. Either call {SetRandomGeneratorSeed 0} only once after starting Mozart (so a 'random' seed is used), or re-feed your code calling MakeRandomGenerator after using SetRandomGeneratorSeed (e.g., re-call your solver).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity97">
<span class="keyword">fun</span>{<span class="functionname">Log</span> X Base}<br>
<span class="string"> Returns the logarithm to the base Base of X. X and Base must be floats and a float is returned.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity98">
<span class="keyword">fun</span>{<span class="functionname">Mod_Float</span> X1 X2}<br>
<span class="string"> Similar to the mod operation, but arguments and return value are floats.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity99">
<span class="keyword">fun</span>{<span class="functionname">IsDivisible</span> X Y}<br>
<span class="string"> Returns a Boolean value whether X is divisible by Y. X and Y are ints.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity102">
<span class="keyword">proc</span>{<span class="functionname">ToProc</span> X Res}<br>
<span class="string"> Function ToProc transforms a method to a procedure. The argument X represents the method and its interface. X may be an atom (representing a method with no argument), or a record (e.g. representing a method with multiple arguments). For convenience, X may also be a procedure, which will be returned unchanged.<BR>
<BR>
 The returned procedure expects one, two or three arguments. The first argument is always the object to which the method is passed. If X is an atom, this is the only argument. E.g. <code> {ToProc test}</code> returns the procedure <code> proc {$ O} {O test} end</code>.<BR>
<BR>
 If the returned procedure expects more than only one argument, the last argument of the procedure is always the value at feature 1 of the method record. In the score description language, the first method feature is usually defined as the return value of the method. If the method expects only that argument, the procedure returned expects two arguments. E.g. <code> {ToProc isTest(x)} </code> results in the procedure <code> proc {$ O Result} {O test(Result)} end</code>.<BR>
<BR>
 If the method defines multiple arguments, all other arguments are collected in a record in the second argument of the procedure. E.g. <code> {ToProc isTest(x test:x)} </code> results in the procedure <code> proc {$ O Args Result} {O test(Result test:Args.test)} end</code>.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity103">
<span class="keyword">proc</span>{<span class="functionname">ToFun</span> X Res}<br>
<span class="string"> Transforms an atom -- representing the label of a unary method -- into a unary function which expects as argument the object the method shall be send to. For convenience, X may also be a procedure, which will be returned unchanged.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity104">
<span class="keyword">fun</span>{<span class="functionname">Procs2Proc</span> Procs}<br>
<span class="string"> Returns a single unary procedure which applies all elements in Procs -- a list of unary procedures -- to its argument (example application: transforms a list of unary compositional rules into a single rule).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity107">
<span class="keyword">fun</span>{<span class="functionname">ExtendedScriptToScript</span> MyExtendedScript Args}<br>
<span class="string"> Convenience function for parameterised CSP scripts. An extended script is a binary procedure, i.e., a script where the first argument is a record of arguments expected by the script and the second argument is the script root variable. <BR>
 ExtendedScriptToScript expects an extended script plus its Args, and returns a plain script (i.e. a unary procedure).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity101">
<span class="keyword">proc</span>{<span class="functionname">ApplySelected</span> Procs I}<br>
<span class="string"> The Ith element in Procs is applied. Procs is list of null-ary procedures. I is a FD integer, the domain of I is implicitly reduced to 1#{Length Procs}.<BR>
 This is quasi a selection constraint, however, there are no constraint propagators created by ApplySelected. Instead, ApplySelected uses the deep-guard combinator Combinator.'or', i.e. a backtracking-free disjunction. ApplySelected suspends until a decision is made elsewhere (e.g. by determining I or by ruling out the cause of the application of all but one procedure in Procs).<BR>
<BR>
 See also Pattern.transformDisj<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity100">
<span class="keyword">proc</span>{<span class="functionname">EncodeRatio</span> X Y Factor Q}<br>
<span class="string"> Q encodes X/Y by an integer as X/Y * Factor. Possible values for X/Y depend on Factor, e.g., 1/3 can not truely be represented if Factor=2. Factor should be an determined integer. For example, if Factor=12 then Q can represent 1/6 (Q=2), 1/4 (Q=3) etc.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity108">
<span class="keyword">fun</span>{<span class="functionname">SelectArg</span> Feature Spec Defaults}<br>
<span class="string"> SelectArg is a tool, e.g., to define functions with quasi optional values. SelectArg returns the value at Feature in record Spec, if Spec has this feature. Otherwise the value at Feature in the record Defaults is returned. Defaults must have this record.<BR>
 !! Often the buildin Adjoin is a better solution: {Adjoin Defaults Args} = EffectiveArgs<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity109">
<span class="keyword">fun</span>{<span class="functionname">TimeVString</span> }<br>
<span class="string"> Returns a VS of the current time in the form<BR>
 'hour:min:sec, day-month-year'.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity110">
<span class="keyword">proc</span>{<span class="functionname">GetCounterAndIncr</span> X}<br>
<span class="string"> Return an integer and as a side effect increment the integer for the next access.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity111">
<span class="keyword">proc</span>{<span class="functionname">ResetCounter</span> }<br>
<span class="string"> Resets the counter for GetCounterAndIncr.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity105">
<span class="keyword">proc</span>{<span class="functionname">UnarySkip</span> X}
</code><br>

<code>
<a name="entity106">
<span class="keyword">proc</span>{<span class="functionname">BinarySkip</span> X Y}
</code><br>

<code>
<a name="entity112">
<span class="keyword">fun</span>{<span class="functionname">TakeFeatures</span> R MyFeats}<br>
<span class="string"> Fun R (a record) and MyFeats (a list of symbols -- potential features in R). TakeFeatures returns a record which consists in all features and their values of MyFeats contained in R. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity113">
<span class="keyword">proc</span>{<span class="functionname">RecursiveAdjoin</span> R1 R2 Result}<br>
<span class="string"> Like Adjoin, but nested records are processed recursively.<BR>
 R1 and R2 must have the same nesting for recursive processing, otherwise R2 features are taken (like Adjoin).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity114">
<span class="keyword">fun</span>{<span class="functionname">ModuleLink</span> UrlVs}<br>
<span class="string"> ModuleLink is like Module.link except that multiple calls of ModuleLink share the same module manager (and don't create new managers as Module.link does). For instance, when ModuleLink links multiple functors which refer to a stateful datum in some functor, then all refer to the same datum instance. By constrast, linking with Module.link results into multiple stateful datum instances.<BR>
 !! On second though, ModuleLink seems to solve a non-existing problem. ModuleLink is an attempt to avoids problems in case some functor is linked more then once in the OPI. Actually, this should happen only in two cases: either you want to create two module instances (with independent stateful data) or you want to reload a functor (e.g. after compilation) without restarting the whole program. In both cases, Module.link does the right thing. So, why did I ever need ModuleLink???<BR>
 -> A buffer with this ModuleLink can be re-fed multiple times without problems. A call to Module.link should not be re-fed... <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity115">
<span class="keyword">fun</span>{<span class="functionname">ModuleApply</span> UFs}<br>
<span class="string"> ModuleApply is like Moduel.apply expect that it always uses the same module manager (cf. ModuleLink). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity116">
<span class="keyword">fun</span>{<span class="functionname">TimeSpend</span> P}<br>
<span class="string"> Returns the time (in msecs) the application of P (a null-ary procedure) took.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity117">
<span class="keyword">proc</span>{<span class="functionname">Assert</span> B MyException}<br>
<span class="string"> If B is false, then MyException is raised.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity118">
<span class="keyword">proc</span>{<span class="functionname">WarnGUI</span> VS}<br>
<span class="string"> Opens a warning dialog which displays VS.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity119">
<span class="keyword">proc</span>{<span class="functionname">InfoGUI</span> VS}<br>
<span class="string"> Opens a warning dialog which displays VS. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity120">
<span class="keyword">proc</span>{<span class="functionname">ErrorGUI</span> VS}<br>
<span class="string"> Opens an error dialog which displays VS. <BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>