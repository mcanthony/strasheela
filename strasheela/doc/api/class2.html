<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Class ScoreObject</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="13" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">Init</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">GUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">LUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">MUtils</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">Score</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">SMapping</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">SDistro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Strasheela</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">FD_edited</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node12.html">Midi</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><p align="right" class="margin"><div align="right">inheritance tree</div></p>
<pre>
 <a class="pre" href="node6.html#entity346">NonType</a> <a class="pre" href="node6.html#entity347">Reflection</a>
    |        |
    `-----+--'
          |
     <a class="pre" href="node6.html#entity348">ScoreObject</a>
</pre>
<hr><p class="margin"><div align="right">class definition</div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [abstract class] The most general data type for score data is a ScoreObject.<BR>
<BR>
 The feature label binds an atom naming the class. The attribute info can be used for arbitrary user information.<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">ScoreObject</span> (Inheritance-free)<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">feat</span>&nbsp;!ScoreObjectType&nbsp;label
<br>
&nbsp;&nbsp;&nbsp;<span class="keyword">attr</span>&nbsp;id&nbsp;info
<br>
<ul><li><span class="functionname">addInfo</span>(X)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [destructive method] Adds X to list in attribute info. The tail of the list at attribute info is the info that was specified before with addInfo and was give at the init method (default is nil).<BR>
<BR>
</span>
</li><li><span class="functionname">addInfos</span>(Xs)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [destructive method] Adds every element in list Xs to list in attribute info. <BR>
<BR>
</span>
</li><li><span class="functionname">getAttr</span>($ A)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns the value at attribute A.<BR>
<BR>
</span>
</li><li><span class="functionname">getAttrNames</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns a list of all attributes (atoms) defined for self. <BR>
<BR>
</span>
</li><li><span class="functionname">getAttrSources</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Alias for getAttrNames.<BR>
 */<BR>
       meth getAttributes($) {self getAttrNames($)} end<BR>
/** %% Returns a record where the features are the attributes defined for self and the values are the classes which define these attributes. <BR>
<BR>
</span>
</li><li><span class="functionname">getClass</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">getClassName</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns the print name of the class of self as specified in its definition. The name is an atom derived from a variable and thus starting with a capital letter, e.g., 'ScoreObject'.<BR>
<BR>
</span>
</li><li><span class="functionname">getFeat</span>($ F)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns the value at feature F.<BR>
<BR>
</span>
</li><li><span class="functionname">getFeatNames</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns a list of all features (atoms) defined for self. <BR>
<BR>
</span>
</li><li><span class="functionname">getFeatSources</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns a record where the features are the features defined for self and the values are the classes which define these features. <BR>
<BR>
</span>
</li><li><span class="functionname">getFeatures</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Alias for getFeatNames.<BR>
<BR>
</span>
</li><li><span class="functionname">getID</span>(X)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">getInfo</span>(X)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">getInfoRecord</span>($ L)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns first record with label L in the list in attribute info.<BR>
<BR>
</span>
</li><li><span class="functionname">getInitArgDefaults</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns a record where the features are all supported arguments of the init method of self with their default as value (_ indicates that no default exist).<BR>
 NB: this method relies on the correct implementation of the method getInitArgs for its class and all its superclasses. <BR>
<BR>
</span>
</li><li><span class="functionname">getInitArgSources</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">getInitClasses</span>(Classes)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Collects all classes of the objects in self in the format expected by the second argument of Score.makeScore, i.e., a record of the form unit(label1:Class1 ... labelN:ClassN)<BR>
<BR>
</span>
</li><li><span class="functionname">getInitClassesVS</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Like getInitClasses, getInitClassesVS collects all classes of the objects in self in the format expected by the second argument of Score.makeScore. However, the result record is returned as a VS (e.g., for outputting into Oz source text files). The Strasheela classes are specified by accessing them in Strasheela functors (e.g., Strasheeala.score.note). The toplevel Strasheela functors are taken from {Init.getStrasheelaEnv strasheelaFunctors}.<BR>
 NB: getInitClassesVS examines every class in these functors (and their subfunctors) and requires that whenever a class defines an init method, all init method arguments must be optional.<BR>
<BR>
</span>
</li><li><span class="functionname">getInitInfo</span>($&nbsp;...)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns information required to reconstruct the init method. Every newly defined ScoreObject subclass which introduces new init arguments should define its own getInitInfo. This documentation therefore explains also implementational details for this method.<BR>
<BR>
 The returned information hase the following form:<BR>
      <BR>
      unit(superclass:Super<BR>
	   args:[Argument1#Accessor1#Default1<BR>
		 ...<BR>
		 ArgumentN#AccessorN#DefaultN])<BR>
      <BR>
 Super is a single superclass of self which defines/inherits a method getInitInfo extending the present method definition (can be nil in case of no superclass). Argument is an init method argument (an atom), Accessor is a unary accessor function or method returning the value of the object corresponding with Argument, and Default is the default value or 'noMatch' if no default value was given. Excluded is the same arg as for toInitRecord: this argument is only required if getInitInfo recuresively calls toInitRecord. A typical getInitInfo definition follows<BR>
<BR>
<BR>
      meth getInitInfo($ ...)<BR>
	 unit(superclass:MySuperClass<BR>
	      args:[myParameter#getMyParameter#noMatch])<BR>
      end<BR>
      <BR>
<BR>
</span>
</li><li><span class="functionname">getMethNames</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns a list of all methods (atoms) defined for self. <BR>
<BR>
</span>
</li><li><span class="functionname">getMethSources</span>($)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns a record where the features are the methods defined for self and the values are the classes which define these methods. <BR>
<BR>
</span>
</li><li><span class="functionname">hasThisInfo</span>(B Info)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Returns boolean whether the list at the attr info of self contains Info. In case some info value is a record, then it is checked whether its label is Info.<BR>
<BR>
</span>
</li><li><span class="functionname">init</span>(handle:H id:ID info:Info&nbsp;...)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> The argument handle is bound to the score object itself (cf. the handle in QTk). The argument info is either a list of infos or a single info (arbitrary value, usually is each info an atom)<BR>
<BR>
</span>
</li><li><span class="functionname">isAbstractElement</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isAmplitude</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isAspect</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isContainer</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isElement</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isEvent</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isItem</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isModifier</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isNote</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isParameter</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isPause</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isPitch</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isScoreObject</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isSequential</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isSimultaneous</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isTemporalAspect</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isTemporalElement</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isTimeInterval</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isTimeMixin</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isTimeParameter</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">isTimePoint</span>(B)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</li><li><span class="functionname">makeInitRecord</span>(X Attrs)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [aux method for toInitRecord]: returns a record intended to facilitate the init method creation of an object for archive purposes. Attrs has the form [Key1#Accessor1#Default1 ...], keys are the record features of the init record, accessors the respective accessor for some object attributes (unary function or method), defaults are the respective attribute default values (the special default value noMatch matches nothing).<BR>
</span>
</li><li><span class="functionname">makePPrintRecord</span>(X Features Slots Excluded functions:Fns)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [aux method for toPPrintRecord] Returns a record with the label of self (the value at the feature label of self) and the values of selected features/attributes of self at record labels. All atoms in the list Features which are member in the list Slots are features of the returned record. <BR>
 Usually, the record feature is just bound to the value at the features/attributes of self. However, for certain features/attributes there are special access functions defined. The return value of these functions will be bound to the record features. These features and their functions are either given in a record to the optional method feature functions. Other features and their functions are predefined in the variable PPrintRecordFns.<BR>
<BR>
</span>
</li><li><span class="functionname">setAttribute</span>(A X)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [destructive method] Statefully sets attribute A to value X. The method is indented for editing a score after search, the search itself is indented to be fully stateless.<BR>
<BR>
</span>
</li><li><span class="functionname">setParameterValue</span>(Param X)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> [destructive method, for experts only] Statefully sets the value of parameter Param to value X (there must be an attribute Param). Remember that the search itself is indented to be fully stateless.<BR>
<BR>
</span>
</li><li><span class="functionname">toFullRecord</span>(X exclude:Exclude unbind:Unbind)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Outputs the whole score object tree as a record with the the object label as record label and with all the object attributes and object features as record features. All attributes/features containing score objects themself are called recursively, dictionaries and extendable lists (see LUtils) are transformed to records resp. lists.<BR>
<BR>
 Args: <BR>
 'exclude' (default nil): list of attribute names (list of atoms) recursively excluded in the output.<BR>
 'unbind' (default nil): list of attribute names (list of atoms) which are output, but whose value is set to a free variable.<BR>
<BR>
 !! Temp: The attributes 'item' and 'containers' are always excluded to avoid endless loops. Therefore, score graphs with items having more then a single container can not be shown.<BR>
<BR>
</span>
</li><li><span class="functionname">toInitRecord</span>($ clauses:Clauses exclude:Excluded)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Outputs the full init record for self which allows to re-create the score.<BR>
 Excluded is a list of arguments (atoms) which must be excluded concurrently.<BR>
 Clauses is a list of pairs TestI#FunI which can be used to overwrite the default init record creation (defined by the class' method getInitInfo) of specific score objects. TestI is a Boolean function or method, and FunI is a unary function expecting a score object and returning a record. For each object for which some TestI returns true, the corresponding FunI will be used for creating the init records for this object.<BR>
<BR>
 NB: toInitRecord depends on correct definitions of the method getInitInfo for all subclasses with specific inialisiation arguments.<BR>
<BR>
 NB: toInitRecord presently only works properly for tree-form score topologys (e.g. score graphs are not supported yet).<BR>
 *<BR>
</span>
</li><li><span class="functionname">toPPrintRecord</span>(?X excluded:Excluded features:Features)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Method returns a record with essential data of self. The method is intended to view self uncluttered. The method feature <code>features</code> allows to freely select a list of score object features/attributes to include. <BR>
<BR>
</span>
</li><li><span class="functionname">unify</span>(ScoreObject derive:Derive exclude:Exclude overwrite:Overwrite)<br>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Effectively unifies self and ScoreObject. This method is useful for constraining various forms of repetitions. Stateful data (including class instances) can not be unified in Oz. So, unify transforms self and ScoreObject to records (using toFullRecord) and unifies those records. <BR>
<BR>
 Args:<BR>
 'exclude' (default [startTime endTime]): list of attribute names (list of atoms) to ignore, see arg 'exclude' for toFullRecord. (The internal attributes 'parameters' and 'flags' are always excluded.)<BR>
 'overwrite' (default nil): list of attribute names (list of atoms) to keep as declared in self (i.e. the setting in ScoreObject is quasi overwritten).<BR>
 'derive' (default nil): for unifying derived score information (e.g., exclude the pitches, but unify pitch intervals, see example below). List of unary functions expecting the full score (self or ScoreObject) and returning a data structure to unify.<BR>
<BR>
 Example:<BR>
      {Score1 unify(Score2<BR>
		    exclude:[pitch]<BR>
		    derive:[proc {$ MyScore Intervals}<BR>
			       Ps = {MyScore mapItems($ getPitch)}<BR>
			    in<BR>
			       Intervals = {Pattern.map2Neighbours Ps<BR>
					    proc {$ P1 P2 ?Interval}<BR>
					       Interval = {FD.decl}<BR>
					       P2 - P1 + 100000 =: Interval<BR>
					    end}<BR>
			    end])}<BR>
 NB: only works properly for tree-form score topologys (because of limitation of toFullRecord). <BR>
<BR>
</span>
</li></ul>
<span class="keyword">end</span>
</code>
</div></body>
</html>