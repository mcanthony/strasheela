<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Segs</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="4" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Segments</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">HCP</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">Segs</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor defines re-usable musical segments. These segments are defined as sub-CSPs (extended scripts). They implement relatively specific musical ideas (e.g., a contrapuntual line, a specific motif, or a homophonic chord progression), but they support a number of arguments in order to make them flexible enough that they are interesting for re-use.<BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Segs ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/Segments/Segments.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li>FS</li><li>Browser(browse:Browse)</li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>MUtils at "<span class="string">x-ozlib://anders/strasheela/source/MusicUtils.ozf"
</span></li><li>Score at "<span class="string">x-ozlib://anders/strasheela/source/ScoreCore.ozf"
</span></li><li>Pattern at "<span class="string">x-ozlib://anders/strasheela/Pattern/Pattern.ozf"
</span></li><li>HS at "<span class="string">x-ozlib://anders/strasheela/HarmonisedScore/HarmonisedScore.ozf"
</span></li><li>Fenv at "<span class="string">x-ozlib://anders/strasheela/Fenv/Fenv.ozf"
</span></li><li><a href="node2.html">HCP</a> at "<span class="string">source/HomophonicChordProgression.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;P/2:<a href="#entity86"><span class="functionname">GetNoteIndex</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity87"><span class="functionname">MakeParametersAccessor</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity88"><span class="functionname">PitchContourAccessor</span></a>&gt;
</li><li><span class="variablename">MakeCounterpoint</span>
</li><li><span class="variablename">MakeCounterpoint_Seq</span>
</li><li><span class="variablename">MakeCounterpoint_PatternMotifs</span>
</li><li><span class="variablename">MkPitchPattern</span>
</li><li><span class="variablename">MkFenvContour</span>
</li><li><span class="variablename">MkArpeggio</span>
</li><li><span class="variablename">MkArc</span>
</li><li><span class="variablename">MkRepetitions</span>
</li><li><span class="variablename">MkHook</span>
</li><li><span class="variablename">MkStairs</span>
</li><li><span class="variablename">MakeAkkord</span>
</li><li><span class="variablename">MakeAkkords</span>
</li><li>&lt;P/2:<a href="#entity89"><span class="functionname">MakeAkkords_Seq</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity90"><span class="functionname">MakeChordSlicesForm</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity91"><span class="functionname">PatternedPhrase</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity92"><span class="functionname">PatternedSlices</span></a>&gt;
</li><li><span class="variablename">HomophonicChordProgression</span>
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity86">
<span class="keyword">fun</span>{<span class="functionname">GetNoteIndex</span> N}<br>
<span class="string"> Expects a note with index parameter and returns the index variable value.  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity87">
<span class="keyword">fun</span>{<span class="functionname">MakeParametersAccessor</span> Accessor}<br>
<span class="string"> Returns accessor function expecting a list of items (notes) and returning list of variables returned by Accessor (unary function or method). Example<BR>
   {MakeParametersAccessor getPitch}<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity88">
<span class="keyword">fun</span>{<span class="functionname">PitchContourAccessor</span> Ns}<br>
<span class="string"> <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity89">
<span class="keyword">fun</span>{<span class="functionname">MakeAkkords_Seq</span> Args}<br>
<span class="string"> Same as MakeAkkords, but returns sequential container of akkords.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity90">
<span class="keyword">proc</span>{<span class="functionname">MakeChordSlicesForm</span> Args MyScore}<br>
<span class="string"> Returns extended script for musical section where each segment in the section expresses a single chord. <BR>
<BR>
 Args:<BR>
 'segments' (required): list of textual score specs: each spec which "express" one chord. <BR>
 'chords' (required): function returning list of chord objects (wrapped in function to protect variables).<BR>
 'constructors' (required): constructors as expected by Score.make.<BR>
 further args: handed to top-level sequential.<BR>
<BR>
 NB: Each segment must be sim, and sim items are specified at feat 1.<BR>
 NB: List of segments and list of chords must be of the same length (shorter list of chords causes fail).<BR>
<BR>
 Note: this def is rather restricted in generality.. Alternatives are, e.g., HS.score.harmoniseScore.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity91">
<span class="keyword">fun</span>{<span class="functionname">PatternedPhrase</span> Args}<br>
<span class="string"> Generates extended script for creating a phrase consisting of multiple segments, and for applying pattern constraints on these segments.  The resulting score topology is as follows, where the segmenents are form segments created by other extended scripts. <BR>
<BR>
 seq(segment+)<BR>
<BR>
 Args:<BR>
 'constructors': constructor spec for the top-level sims and seq, format as expected by Score.make. Features should be 'sim' and 'seq'. <BR>
 'pAccessor' (default GUtils.identity): unary function applied to each segment, returning a value for the argument pattern, e.g, a parameter value (FD int) or a score object (see below). <BR>
 'pattern' (default proc {$ Xs} skip end): unary procedure expecting/constraining the list of values returned by 'pAccessor' for all segments. <BR>
 All other top-level arguments are given to the top-level seq.<BR>
<BR>
 Args.segments:<BR>
 tuple of segment specifications, where each segment specifications is a record of the following arguments. (In principle it can be a record, but then the temporal order of segments depends on the order of features in the record)<BR>
 'constructor': extended script (binary procedure) for creating the layer, commonly created with Score.defSubscript. Should return a score object (not a list of score objects).<BR>
 All other arguments in Args.segments are given to this constructor.<BR>
<BR>
 The arguments of the returned extended script correspond to Args.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity92">
<span class="keyword">proc</span>{<span class="functionname">PatternedSlices</span> Args MyScore}<br>
<span class="string"> Extended script for creating a sequence of polyphonic form segments, resulting score topology, where the segmenents are form segments created by other extended scripts. <BR>
<BR>
 seq(sim(segment+)+)<BR>
<BR>
 The simultaneous containers can be though of as formal "slices", consisting of layers (the segmenents). Note that all slices are uniform in the sense that each slices consists of the same layers (i.e. the layers of each slices are created with the same constructors). However, depending on the flexibility of these layer constructors (e.g., their set of arguments) corresponding layers can also considerably differ across slices. Also, pattern constraints can be applied conveniently to lists of corresponding layers accross slices.<BR>
<BR>
 PatternedSlices can be used, for example, to create the score with the actual notes for a harmonic CSP. For example, each slices could express its own harmony (e.g., sim chord object).<BR>
<BR>
 Args:<BR>
 'n': number of sims in the top-level seq (number of slices).<BR>
 'constructors': constructor spec for the top-level sims and seq, format as expected by Score.make. Features should be 'sim' and 'seq'. <BR>
<BR>
 Args.layer:<BR>
 record/tuple of layer specifications, where each layer specifications is a record of the following arguments. Each layer specification is used for creating all instances of this layer accross the slices. <BR>
 iargs.constructor: extended script (binary procedure) for creating the layer, commonly created with Score.defSubscript. Should return a score object (not a list of score objects).<BR>
 'pAccessor' (default GUtils.identity): unary function applied to each layer instance, returning a value for the argument pattern, e.g, a parameter value (FD int) or a score object (see below). <BR>
 'pattern' (default proc {$ Xs} skip end): unary procedure expecting/constraining the list of values returned by 'pAccessor' for all instances of the present layer across slices. <BR>
 In addition, (almost) all other constructor arguments are supported. These constructor arguments are supported in all formats introduced by Score.makeItems, such as each-args. However, it may be necessary to specify composite argument as each-args. For example, in order to specify an "rargs argument", the whole rargs record must be specified as each-args such as<BR>
   unit(rargs: each # [unit(<args1>) unit(<args2>) ...] ...)<BR>
<BR>
 NB: arguments expected by Score.makeItems (n, constructor, handle, rule) *cannot* be handed to the layer constructors! <BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>