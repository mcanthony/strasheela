<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>TSC</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="5" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Segments</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">HCP</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">TSC</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">Segs</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</span>
<h3>Functor</h3>
<ul>TSC ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/Segments/source/TransformableSubscript.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>Score at "<span class="string">x-ozlib://anders/strasheela/source/ScoreCore.ozf"
</span></li><li>Fenv at "<span class="string">x-ozlib://anders/strasheela/Fenv/Fenv.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;P/3:<a href="#entity83"><span class="functionname">DefSubscript</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity84"><span class="functionname">RemoveNotesAtEnd</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity85"><span class="functionname">RemoveShortNotes</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity86"><span class="functionname">SubstituteNote</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity87"><span class="functionname">DiminishAdditively</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity88"><span class="functionname">AugmentAdditively</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity89"><span class="functionname">DiminishMultiplicatively</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity90"><span class="functionname">AugmentMultiplicatively</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity91"><span class="functionname">TransformMotifLength</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity92"><span class="functionname">TransformMotifList</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity93"><span class="functionname">FenvMapMotifList</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity94"><span class="functionname">GetMotifLength</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity95"><span class="functionname">GetMotifList</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity83">
<span class="keyword">fun</span>{<span class="functionname">DefSubscript</span> DefArgs Body}<br>
<span class="string"> DefSubscript is an extended variant of Score.defSubscript that additionally provides means for defining and transforming motif features applied to the resulting subscript.<BR>
 Strasheela supports a number of motif models and several also provide some support for variation. Special about the variation support of DefSubscript is the fact that a description of the motif itself is varied, and the motif instance is created only afterwards using this varied description. This design as advantages and disadvantages.<BR>
 Advantages are the following. Variation definitions are more flexible. In particular, the length of the motif can be changed easily. For example, some short not can be inserted somewhere in the middle or the motif can be condensed (e.g., the first n notes can be dropped). Even if the number of motif notes is varied, there are no "non-existing" note objects of duration 0, which simplifies constraint application.<BR>
 The disadvantage is that variations that change the structure of the motif (e.g. change the note number of the note order) must be determined before the search starts (otherwise the search blocks). Nevertheless, this only determines the motif description (e.g., only the pitch contour or intervals, but the actual pitches are found during search). Also, the motif identity of a motif instance is determined in the CSP definition (the limitation is shared by other motif models, e.g., the prototype model and subscripts in general). Variation that could be expressed by constrained variables (e.g., motif transposition) can in principle be left undetermined in the problem definition (e.g., the amount of transposition is found during the search). However, if some arguments to the subscript require search decisions (distribution) then they must be encapsulated in item parameters (e.g., new parameters added to the notes of a motif). Another disadvantage is that this motif model is best suited for sequences of notes (a limitation shared by the motif models pattern motif and variation motif, but not by the protoype motif model and subscripts in general).<BR>
<BR>
 Like Score.defSubscript, DefSubscript expects arguments in DefArgs (a nested record of arguments) a Body that applies constraints, possibly using subscript arguments (a binary procedure or nil). It returns an extended script (a binary procedure). See the documentation of Score.defSubscript for further details.<BR>
<BR>
 DefSubscript adds two arguments to Score.defSubscript as features of DefArgs.<BR>
<BR>
 'motif' (default unit): a record that describes arbitrary motif features. These features are potentially varied. Each motif feature is specified by its own record feature/value of the following format: FeatureName: ValueList#Accessor. FeatureName is some arbitrary atom to denote the motif feature, ValueList is a list (usually of FD ints) and Accessor is a unary function or an n-ary method applied to the motif (the container). If it is a method, then all method arguments (except the container) must be specified. Accessor must return a list of variables and this list is unified with ValueList. In the following example, the note durations of the motif are set to the ValueList [2 2 4]. FeatureName is 'durations' and the accessor is a function that returns the list of note durations contained the the motif.<BR>
<BR>
   unit(durations: [2 2 4]#fun {$ X} {X mapItems($ getDuration)} end)<BR>
<BR>
 Using a method instead of a function results in a more concise specification. (Methods are automatically translated to functions with GUtils.toProc, aditional args given the function resulting from n-ary methods are always only unit) <BR>
<BR>
   unit(durations: [2 2 4]#mapItems(_ getDuration))<BR>
<BR>
 For a specification like the one above the resulting note number of the motif can be deduced automatically (the length of ValueList). If the number of notes does not equal the length of the specified value lists, then the note number must be specified as an integer given to the  optional argument 'n'. Example:<BR>
<BR>
   unit(n: 5<BR>
	durations: [2 2 4]#mapItems(_ getDuration)<BR>
	pitchContour: [2 0]#fun {$ X} {Pattern.direction {Pattern.map2Neighbours {X getItems($)}}} end)<BR>
<BR>
 The dummy value '_' can be used for list elements should be ignored (i.e. no constraint is applied). Only the first duration is constrained in the following example, but there are three items. <BR>
<BR>
   unit(durations: [2 '_' '_']#fun {$ X} {X mapItems($ getDuration)} end)<BR>
<BR>
<BR>
 'transformers' (default nil): a list of binary functions that define motif variations. Each function expects a full motif specification and the full argument record of the subscript (i.e. args given to the subscript call and default values for all other args) and returns a somehow transformed full motif specification. A transformer function typically defines its arguments as rarg features. The transformer function Foo below expects the argument 'foo', whose default is 'bar'.<BR>
<BR>
   fun {Foo MotifSpec Args}<BR>
      Default = unit(rargs: unit(foo: bar)) <BR>
      As = {GUtils.recursiveAdjoin Default Args}<BR>
   in<BR>
      <body><BR>
   end<BR>
   <BR>
 Arbitrary transformations of the motif specification are allowed, but typically the value lists of the motif features are somehow changed. Convenience functions simplify such transformations (see the source of the transformations below for examples).<BR>
<BR>
 Note that the transformer functions are accumulatively processing the motif specification: the second function processes the output of the first and so forth.<BR>
<BR>
<BR>
 NB: as the number of items in the resulting motif is specified otherwise, DefSubscript does not support the Score.defSubscript DefArgs argument unit(idefaults: unit(n:N)) nor unit(iargs(n:N)). <BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity84">
<span class="keyword">fun</span>{<span class="functionname">RemoveNotesAtEnd</span> MotifSpec Args}<br>
<span class="string"> Motif transformer that removes the specified number of items at the end of the motif, reducing all value lists of the motif and n.<BR>
<BR>
 Args.rargs:<BR>
 unit(removeNotesAtEnd: N) (default 0): number of items to remove.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity85">
<span class="keyword">fun</span>{<span class="functionname">RemoveShortNotes</span> MotifSpec Args}<br>
<span class="string"> Motif transformer that removes short notes in MotifSpec. Constraint requires a feature 'durations' in MotifSpec with determined durations.<BR>
<BR>
 Args.rargs:<BR>
 removeShortNotes (default 0): number of items to remove.<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity86">
<span class="keyword">fun</span>{<span class="functionname">SubstituteNote</span> MotifSpec Args}<br>
<span class="string"> Motif transformer that replaces the note at given position by notes of given motif spec. The features of MotifSpec and Args.rargs.substituteNote.motif should match. What varies are typically the lists of the motif features.<BR>
<BR>
 Args.rargs:<BR>
 substituteNote.motif (default unit): motif spec that is inserted. The format is the same as expected by DefSubscript, only accessors are not required. Example: unit(durations: [2 1]). An "empty" motif (e.g., unit(durations: nil)) results in a removal of the substituted note.<BR>
<BR>
 substituteNote.position (default nil): position of the note to substitute. If position is nil then no note is substituted.<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity87">
<span class="keyword">fun</span>{<span class="functionname">DiminishAdditively</span> MotifSpec Args}<br>
<span class="string"> Motif transformer that subtracts from the duration of each note in MotifSpec a specific value. Constraint requires a feature 'durations' in MotifSpec.<BR>
<BR>
 Args.rargs:<BR>
 diminishAdditively (FD int or fenv, default 0): amount subtracted from each duration. If arg is a fenv, then the fenv value at the note position is used (resulting in what Messian calls "inexact diminishing" if the fenv is not a constant function).<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity88">
<span class="keyword">fun</span>{<span class="functionname">AugmentAdditively</span> MotifSpec Args}<br>
<span class="string"> Motif transformer that adds to the duration of each note in MotifSpec a specific value. Constraint requires a feature 'durations' in MotifSpec.<BR>
<BR>
 Args.rargs:<BR>
 augmentAdditively (FD int or fenv, default 0): amount added to each duration. If arg is a fenv, then the fenv value at the note position is used (resulting in what Messian calls "inexact diminishing" if the fenv is not a constant function).<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity89">
<span class="keyword">fun</span>{<span class="functionname">DiminishMultiplicatively</span> MotifSpec Args}<br>
<span class="string"> Motif transformer that divides the duration of each note in MotifSpec by a specific value. Constraint requires a feature 'durations' in MotifSpec.<BR>
<BR>
 Args.rargs:<BR>
 diminishMultiplicatively (int or fenv, default 1): amount by which each duration is divided. If arg is a fenv, then the fenv value at the note position is used (resulting in what Messian calls "inexact diminishing" if the fenv is not a constant function).<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity90">
<span class="keyword">fun</span>{<span class="functionname">AugmentMultiplicatively</span> MotifSpec Args}<br>
<span class="string"> Motif transformer that multiplies the duration of each note in MotifSpec by a specific value. Constraint requires a feature 'durations' in MotifSpec.<BR>
<BR>
 Args.rargs:<BR>
 augmentAdditively (FD int or fenv, default 1): amount by which each duration is multiplied. If arg is a fenv, then the fenv value at the note position is used (resulting in what Messian calls "inexact diminishing" if the fenv is not a constant function).<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity91">
<span class="keyword">fun</span>{<span class="functionname">TransformMotifLength</span> MotifSpec TransformLists TransformN}<br>
<span class="string"> Convenience function for defining motif spec transformations that affect the number of notes in the motif. MotifSpec is the motif spec expected as first argument of a motif transformer, TransformMotifLength returns the transformed motif spec. TransformLists is a binary and TransformN a unary function. TransformLists is used to transform each value list (e.g., the list of durations): it expects the feature name of a value list and this list and returns the transformed list. TransformN is used for transforming the optional argument n (i.e. unit(iargs(n:N))): it expects and integer and returns the transformed integer. Note that if no arg n was specified in the input MotifSpec, then there will also be no arg n in the output.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity92">
<span class="keyword">fun</span>{<span class="functionname">TransformMotifList</span> MotifSpec Feat Fn}<br>
<span class="string"> Convenience function for defining motif spec transformations that transform a single value list (e.g., rotate the sequence of pitches). MotifSpec is the motif spec expected as first argument of a motif transformer, TransformMotifList returns the transformed motif spec. Feat is the feature in MotifSpec that holds the list to transform. Fn defines the transformation; it is a unary function that expects a list and returns the transformed list.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity93">
<span class="keyword">fun</span>{<span class="functionname">FenvMapMotifList</span> MotifSpec Feat Arg P}<br>
<span class="string"> Convenience function for defining motif spec transformations that transform a single value list given a transformation Arg that is either a FD int or a fenv. For example, FenvMapMotifList can be used to add a constant value to all durations of MotifSpec.<BR>
 MotifSpec is the motif spec expected as first argument of a motif transformer. Feat is the feature in MotifSpec that holds the list to transform. Arg is an FD int or a fenv. P defines the transformation, and is used quasi for mapping over the value list. P is a ternary proc with the interface {$ X Arg2 Y}, where X a value from the value list, Arg2 is either an FD int given with as Arg to FenvMapMotifList or, if Arg is a fenv, Arg2 is the fenv value at the position corresponding to X. Finally, Y is the transformed value. Y is implicitly declared a FD int. See the definition of DiminishAdditively for an example. Note that fenv values are rounded to integers.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity94">
<span class="keyword">fun</span>{<span class="functionname">GetMotifLength</span> MotifSpec}<br>
<span class="string"> [Util] Returns number of notes in motif. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity95">
<span class="keyword">fun</span>{<span class="functionname">GetMotifList</span> MotifSpec Feat}<br>
<span class="string"> [Util] Returns the value list at Feat of MotifSpec without the corresponding accessor.<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>