<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Rules</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="18" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">HarmonisedScore</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">DB</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">HS_Score</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">Rules</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">DBs</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">HS_Distro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">HS_Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">HS</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Schoenberg</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Default</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">Jazz</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node12.html">Partch</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node13.html">Johnston</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node14.html">Harrison</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node15.html">Chalmers</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node16.html">Catler</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node17.html">ArithmeticalSeriesChords</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor defines several general rules/constraints (i) on chords and/or scales and (ii) melodic rules etc.<BR>
<BR>
<BR>
<BR>
 Background info to melodic rules: conventional non-harmonic note pitch conditions (according to Piston. Counterpoint, Norton, 1947) <BR>
<BR>
   - appoggiatura (Vorhalt?): stressed dissonance: step or skip (more common than step, adds emphasis) from any direction into dissonance, resolved in second below or above. Dissonance on strong beat (requires metric position). Dissonance can be further stressed by a note duration longer than following note.<BR>
    Torsten added: 'likes' to resolve in semitone, specially if upwards (Mozart..)<BR>
<BR>
   - passing note (Durchgang): diatonic or chormatic progression continued in same direction. Passing note always weak rhythmical quality -- even when occuring on first beat of measure (!!). According to Piston, notes are analysed as either appoggiatura or passing only depending on their rhythmic weight.<BR>
     Exceptionally are 'passing notes' without any directly preceeding notes (this note sounded in other voice). <BR>
<BR>
   - suspension (vorbereiteter Vorhalt?): in classic case, a (comparatively long) harmonic note is 'tied over' -- the harmony changes and turnes the 'tied over' note into a non-harmonic note. Usually/often, this dissonance longs at least a beat. Suspensions are resolved in stepwise motion (usually downwards, upwards more likely in case of leading notes  or chormatically raised notes). The suspension may resolved into next harmony (i.e. after the harmony it formed a dissonance in). The suspendend note is (in all cases?) longer than its successor.<BR>
<BR>
   - anticipation (Vorausnahme): dissonant note on easy beat preceeding the same consonant note pitch on strong beat (i.e. the harmony changed). The dissonant anticipation is shorter than its consonant successor.<BR>
<BR>
   - auxiliary (Nebennote): ornamental single note, leaving and returning to the same note by a second up or down. The harmony may meanwhile change.<BR>
<BR>
   - echappee/cambiata (Torsten: standardised case of ornamental resolution?): stepwise movement of melody 'ornamented' note between. Echappee: leaves first note by stepwise motion in opposite direction and 'resolves' by skip of third to destination. Cambiata: first note by skip of third in opposite direction and 'resolves' by step to destination. Echappee and cambiata are rhythmically weak.<BR>
     Variants with more freedom: larger skip than third or all movements in same direction (quasi like passing note with skip). Combination to double auxiliary (or changing-tones): echappee and cambiata follow each other directly as two dissonances.  <BR>
<BR>
   - ornamental resolution: (i) multiple 'standard' dissonances directly following each other. E.g., appoggiatura directly followed by cambiata (i.e. with delayed resolution). (ii) arbitrary consonant chord note between 'standard' dissonance treatment. E.g., before passing note skip to some other chord note and (possibly) skip back to actual passing note. (iii) a group of interpolated tones (Piston recomments studying Bach 'Italian Concerto')<BR>
<BR>
<BR>
 Problem with specific non-harmonic pitches, especially appoggiatura, in this context: how to 'motivate' non-harmonic pitches. E.g. in case of melody harmonisation, obviously harmonic pitches followed by a passing note could be understood as non-harmonic pitches which resolve into a harmonic pitch..<BR>
<BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Rules ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/HarmonisedScore/source/Rules.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li>FS</li><li>Select at "<span class="string">x-ozlib://duchier/cp/Select.ozf"
</span></li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>MUtils at "<span class="string">x-ozlib://anders/strasheela/source/MusicUtils.ozf"
</span></li><li>SMapping at "<span class="string">x-ozlib://anders/strasheela/source/ScoreMapping.ozf"
</span></li><li>Pattern at "<span class="string">x-ozlib://anders/strasheela/Pattern/Pattern.ozf"
</span></li><li><a href="node8.html">HS</a> at "<span class="string">../HarmonisedScore.ozf"
</span></li><li><a href="node3.html">HS_Score</a> at "<span class="string">Score.ozf"
</span></li><li><a href="node2.html">DB</a> at "<span class="string">Database.ozf"
</span></li><li><a href="node9.html">Schoenberg</a> at "<span class="string">Schoenberg.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li><span class="variablename">Schoenberg</span>
</li><li>&lt;P/3:<a href="#entity292"><span class="functionname">GetInterval</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity293"><span class="functionname">ConstrainMaxIntervalR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity294"><span class="functionname">MakeIntervalConstraint</span></a>&gt;
</li><li><span class="variablename">PerfectConsonances</span>
</li><li><span class="variablename">IsPerfectConsonanceR</span>
</li><li><span class="variablename">Limit3Consonances</span>
</li><li><span class="variablename">IsLimit3ConsonanceR</span>
</li><li><span class="variablename">Limit3Intervals_2</span>
</li><li><span class="variablename">IsLimit3IntervalR_2</span>
</li><li><span class="variablename">Limit5Consonances</span>
</li><li><span class="variablename">IsLimit5ConsonanceR</span>
</li><li><span class="variablename">IsLimit_3_5_ConsonanceR</span>
</li><li><span class="variablename">IsLimit7ConsonanceR</span>
</li><li><span class="variablename">IsLimit_3_5_7_ConsonanceR</span>
</li><li>&lt;P/2:<a href="#entity295"><span class="functionname">MinCard</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity296"><span class="functionname">GetFeature</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity297"><span class="functionname">UnequalParameter</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity298"><span class="functionname">UnequalParameterR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity299"><span class="functionname">NeighboursWithUnequalParameter</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity300"><span class="functionname">Distinct</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity301"><span class="functionname">DistinctR</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity302"><span class="functionname">DistinctNeighbours</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity303"><span class="functionname">PairwiseDistinct</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity304"><span class="functionname">ButNDistinct</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity305"><span class="functionname">DistinctForN</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity306"><span class="functionname">CommonPCs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity307"><span class="functionname">CommonPCs_Card</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity308"><span class="functionname">CommonPCsR</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity309"><span class="functionname">NeighboursWithCommonPCs</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity310"><span class="functionname">ParameterDistance</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity311"><span class="functionname">ParameterDistanceR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity312"><span class="functionname">LimitParameterDistanceOfNeighbours</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity313"><span class="functionname">GetRootPCIntervals</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity314"><span class="functionname">GetRootDegreeIntervals</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity315"><span class="functionname">SetBoundaryRoots</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity316"><span class="functionname">SetBoundaryTypes</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity317"><span class="functionname">Cadence</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity318"><span class="functionname">DiatonicChord</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity319"><span class="functionname">NoteInPCCollection</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity320"><span class="functionname">ResolveDissonances</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity321"><span class="functionname">NoParallels</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity322"><span class="functionname">NoParallels2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity323"><span class="functionname">NoParallel</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity324"><span class="functionname">IndexCardinality</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity325"><span class="functionname">SetEachChordType</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity326"><span class="functionname">SetEachScaleType</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity327"><span class="functionname">RequireChordTypes</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity328"><span class="functionname">ExpressAllChordPCs</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity329"><span class="functionname">ExpressAllChordPCs_AtChordStart</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity330"><span class="functionname">ExpressAllChordPCs_AtChordEnd</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity331"><span class="functionname">ExpressEssentialChordPCs</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity332"><span class="functionname">ExpressEssentialPCs_AtChordStart</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity333"><span class="functionname">ClearHarmonyAtChordBoundaries</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity350"><span class="functionname">OnlyOrnamentalDissonance_Durations</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity334"><span class="functionname">VoiceLeadingDistance</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity335"><span class="functionname">VoiceLeadingDistance_Percent</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity336"><span class="functionname">SmallIntervalsInProgression</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity337"><span class="functionname">SmallIntervalsInProgression_Percent</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity338"><span class="functionname">RestrictPitchDomain</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity339"><span class="functionname">IsStep</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity340"><span class="functionname">IsStepR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity341"><span class="functionname">ResolveStepwiseR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity343"><span class="functionname">PassingNotePitches</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity344"><span class="functionname">PassingNotePitchesR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity345"><span class="functionname">IsPassingNoteR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity342"><span class="functionname">IsBetweenChordNotesR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity346"><span class="functionname">IsAuxiliaryR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity347"><span class="functionname">IsBetweenStepsR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity348"><span class="functionname">ResolveNonharmonicNotesStepwise</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity349"><span class="functionname">ClearDissonanceResolution</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity351"><span class="functionname">IntervalBetweenNonharmonicTonesIsConsonant</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity352"><span class="functionname">MaxInterval</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity353"><span class="functionname">MaxNonharmonicNoteSequence</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity354"><span class="functionname">MaxNonharmonicNotePercent</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity355"><span class="functionname">MaxRepetitions</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity356"><span class="functionname">MinPercentSteps</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity357"><span class="functionname">Ballistic</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity292">
<span class="keyword">proc</span>{<span class="functionname">GetInterval</span> Note1 Note2 Interval}<br>
<span class="string"> Returns the absolute pitch interval (a FD int) between the note objects Note1 and Note2. Interval is implicitly declared a FD int.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity293">
<span class="keyword">proc</span>{<span class="functionname">ConstrainMaxIntervalR</span> Note1 Note2 MaxInterval B}<br>
<span class="string"> B=1 <-> constraints the absolute pitch interval between Note1 and Note2 (note objects) to MaxInterval (an integer) at most.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity294">
<span class="keyword">fun</span>{<span class="functionname">MakeIntervalConstraint</span> Ratios}<br>
<span class="string"> Expects a list of ratios (pairs of ints) and returns a binary constraint {IsInRatios Interval B} with Interval (FD int) a pitch interval and B a 0/1 int.   <BR>
  B=1 <-> Interval reduced into a single octave is element in ratios, translated to pitch classes.   <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity295">
<span class="keyword">proc</span>{<span class="functionname">MinCard</span> Notes Card}<br>
<span class="string"> The cardiality of the set of pitchclasses of Notes (list of HS.score.note objects) is at least Card (FD int).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity296">
<span class="keyword">proc</span>{<span class="functionname">GetFeature</span> X Feat I}<br>
<span class="string"> Constraints the chord/scale X: the arbitrary (user defined) chord/scale database feature value at Feat is accessed/constrained to I (a FD int or FS var, depending on the feature). For instance, if X is a chord and the chord database defines a numeric 'dissonanceDegree' for each chord in the database, <code> {GetFeature X 'dissonanceDegree' 2} </code> constraints the index of X to point to a chord spec in the database which has a dissonanceDegree of 2.<BR>
 NB. GetFeature employs a selection constrain: multiple applications of GetFeature with the same Feat will accessed/constrain the same value I with multiple selection constraint propagators, which should be avoided..<BR>
<BR>
 !! NB: does not work for intervalDB, because there is no interval ADT which defines getDB and getIndex for interval.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity297">
<span class="keyword">proc</span>{<span class="functionname">UnequalParameter</span> X Y Fn}<br>
<span class="string"> The chords/scales X and Y differ in the parameter/attribute accessed by Fn (a unary function or method). For instance, <code> {UnequalParameter X Y getIndex} </code> constrains the indices of X and Y to differ.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity298">
<span class="keyword">proc</span>{<span class="functionname">UnequalParameterR</span> X Y Fn B}<br>
<span class="string"> Reified version of DistinctParameter: B=1 <-> chords/scales X and Y differ in the parameter/attribute accessed by Fn.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity299">
<span class="keyword">proc</span>{<span class="functionname">NeighboursWithUnequalParameter</span> Xs Fn}<br>
<span class="string"> All successive chord/scale pairs in list Xs differ in the parameter/attribute accessed by Fn.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity300">
<span class="keyword">proc</span>{<span class="functionname">Distinct</span> X Y}<br>
<span class="string"> The chords/scales X and Y have either different indices or different transpositions or both. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity301">
<span class="keyword">proc</span>{<span class="functionname">DistinctR</span> X Y B}<br>
<span class="string">  B=1 <-> The chords/scales X and Y have either different indices or different transpositions or both.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity302">
<span class="keyword">proc</span>{<span class="functionname">DistinctNeighbours</span> Xs}<br>
<span class="string"> All successive chord/scale pairs in list Xs have either different indices or different transpositions or both.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity303">
<span class="keyword">proc</span>{<span class="functionname">PairwiseDistinct</span> Xs}<br>
<span class="string"> All chords/scales in list Xs are pairwise distinct, i.e. they have either different indices or different transpositions or both.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity304">
<span class="keyword">proc</span>{<span class="functionname">ButNDistinct</span> Xs N}<br>
<span class="string"> All but N (a FD int) chords/scales in list Xs are pairwise distinct, i.e. they have either different indices or different transpositions or both. That is, N=4 <-> four chords/scales are not unique in Xs (either all four are the same or two different chords/scales repeated).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity305">
<span class="keyword">proc</span>{<span class="functionname">DistinctForN</span> Xs N}<br>
<span class="string"> Xs (a list of chords/scales) is split into sublists of length N: in each sublist, all chords/scales are pairwise distinct.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity306">
<span class="keyword">proc</span>{<span class="functionname">CommonPCs</span> X Y}<br>
<span class="string"> Constraints the chords/scales X and Y to have at least 1 common pitch class.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity307">
<span class="keyword">proc</span>{<span class="functionname">CommonPCs_Card</span> X Y N}<br>
<span class="string"> N (an FD int) is the cardiality of the set of common pitch classes between the chords/scales X and Y.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity308">
<span class="keyword">proc</span>{<span class="functionname">CommonPCsR</span> X Y B}<br>
<span class="string"> Reified version of CommonPCs: B=1 <-> chords/scales X and Y have at least 1 common pitch class. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity309">
<span class="keyword">proc</span>{<span class="functionname">NeighboursWithCommonPCs</span> Xs}<br>
<span class="string"> Each successive chord/scale pair in list Xs has at least 1 common pitch class.<BR>
 NB: The constraint introduces auxilary variables which possibly remain undetermined in the solution. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity310">
<span class="keyword">proc</span>{<span class="functionname">ParameterDistance</span> X Y Fn I}<br>
<span class="string"> Constraints the distance between the parameter/feature accessible with Fn of the chords/scales X and Y to I (a FD integer). For instance, if X and Y are chords and the chord database defines the numeric feature dissonanceDegree, the dissonanceDegree distance between X and Y is set to 1 by<BR>
 <code> {ParameterDistance X Y fun {$ X} {GetFeature X dissonanceDegree} end 1} </code><BR>
<BR>
</span>
</code><br>

<code>
<a name="entity311">
<span class="keyword">proc</span>{<span class="functionname">ParameterDistanceR</span> X Y Fn I B}<br>
<span class="string"> Reified version of ParameterDistance.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity312">
<span class="keyword">proc</span>{<span class="functionname">LimitParameterDistanceOfNeighbours</span> Xs Fn Max}<br>
<span class="string"> Limits the the distance between the parameter/feature accessible with Fn of the neigbouring chords/scales in Xs not to exceed Max (a FD integer, but in most cases an integer will do).<BR>
<BR>
 !! Better define LimitDistanceOfNeighbours as Pattern expecting list of FD ints..<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity313">
<span class="keyword">fun</span>{<span class="functionname">GetRootPCIntervals</span> Chords}<br>
<span class="string"> Returns the list of PC intervals between the roots of Chords (list of chord objects). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity314">
<span class="keyword">fun</span>{<span class="functionname">GetRootDegreeIntervals</span> Chords MyScale}<br>
<span class="string"> Expects a list of Chords and a scale, and returns the absolute distances between the scale degrees of the chord roots (list of FD ints).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity315">
<span class="keyword">proc</span>{<span class="functionname">SetBoundaryRoots</span> Chords Args}<br>
<span class="string"> Sets the pitch classe of the first chord root in Chords (list of chords) and potentially constrains the pitch class interval between the first and last chord root. <BR>
<BR>
 Args:<BR>
 'firstRoot' (default false): root of first chord (pc atom, see HS.pc)<BR>
 'firstToLastRootInterval' (default false): pc interval between first and last chord root (pc atom, e.g., 'C' is 0, or false).<BR>
 'lastRoot' (default false): root of last chord (pc atom, or false)<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity316">
<span class="keyword">proc</span>{<span class="functionname">SetBoundaryTypes</span> Chords Args}<br>
<span class="string"> Sets the types of the first and last chord in Chords (list of chords).<BR>
<BR>
 Args:<BR>
 'firstType' / 'lastType' (default false): sets the type (index) of the first/last chord in Chords to the type specified, an atom (chord name specified in the database). Disabled if false.<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity317">
<span class="keyword">proc</span>{<span class="functionname">Cadence</span> MyScale Chords}<br>
<span class="string"> Constraints the union of the pitch classes of Chords (a list of chord objects) to be the same set as the set of pitch classes of MyScale (a scale object). In other words, all chords only use scale tones (diatonic chords) and all scale tones are played.  Also, the root of the last chord is constrained to the root of the scale.<BR>
 In common usage, Chords has length three and is applied to the last three chords of a progression.<BR>
 This constraint goes well with HS.rules.schoenberg.ascendingProgressionR and frieds (results in the common cadences for major in 12 ET, and plagal cadences for natural minor).<BR>
<BR>
 Note: this constraint implements a particular strict notion of a cadence, were all scale notes must sound. A less strict version would require that only pitch classes which distinguish a scale among all other likely scales are sufficient (e.g., the pitch classes G, B, and F are sufficient to distinguish C-major between all major scales). However, such a constraint is more context dependent and requires information on all scales which are alternatively possible (e.g., G, B, and F are not sufficient to confirm C-major if the scale could also be Dorian). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity318">
<span class="keyword">proc</span>{<span class="functionname">DiatonicChord</span> MyChord MyScale}<br>
<span class="string"> All pitch classes of MyChord are in MyScale (scale must of course not diatonic, procedure name uses the phrase "diatonic to" as a synonym for "belonging to"). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity319">
<span class="keyword">proc</span>{<span class="functionname">NoteInPCCollection</span> MyNote MyPCCollection}<br>
<span class="string"> The pitch class of MyNote is in MyPCCollection (a chord or a scale).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity320">
<span class="keyword">proc</span>{<span class="functionname">ResolveDissonances</span> Chords Args}<br>
<span class="string"> Constraints that every chord in Chords which is not a consonant chord is resolved by an ascending chord progression. The last chord is implicitly constrained to be a consonant chord.<BR>
 This rule is inspired by Schoenberg, note however that it is never given by Schoenberg (When introducing 7th-chords, Schoenberg requires they are resolved by root progression a fourth up. Besides that, Schoenberg primarily discusses treatment dissonant tone in chord: it descends by one step or is held over.). <BR>
<BR>
 Args:<BR>
 'consonantChords' (default ['major' 'minor']): list of chord types (atoms of chord names or index integers) specifying which chords are considered consonant.<BR>
<BR>
 Note: this is an over-simplified dissonance resolution constraint.<BR>
 - Dissonance preparation not supported (preparation only required in early section of Schoenberg's harmony, later he even skips into dissoance, though stepwise introduction of dissonance is preferred)<BR>
 - Dissonances do not necessarily "fall" in resolution (which is OK in principle), but this resolution behaviour cannot be controlled<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity321">
<span class="keyword">proc</span>{<span class="functionname">NoParallels</span> NotePairs}<br>
<span class="string"> Open and hidden parallel fifths and fourth are not permitted: perfect consonances must not be reached by both voices in the same direction. NotePairs is a list of two-note-pairs. Each pair consists of consecutive notes in the same voice and NotePairs together are the simultaneous note pairs of all voices. In particular, the second element of each pair in NotePairs are all simultaneous notes -- if any of these form a perfect consonance, then the first notes of these pairs should not progress into these sim notes in the same direction. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity322">
<span class="keyword">proc</span>{<span class="functionname">NoParallels2</span> Notes Args}<br>
<span class="string"> Open and hidden parallel fifths and fourth are not permitted: perfect consonances must not be reached by both voices in the same direction. Notes is the list of all notes to which the constraint is applied (e.g., the list of all notes in the score).<BR>
<BR>
 Args:<BR>
 getPredecessor: unary function expecting a note and returning the preceding note in the same voice. Default:<BR>
   fun {$ N} {N getPredecessor($ {N getTemporalAspect($)})} end<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity323">
<span class="keyword">proc</span>{<span class="functionname">NoParallel</span> N1A#N1B N2A#N2B}<br>
<span class="string">  Open and hidden parallel fifths and fourth are not permitted: perfect consonances must not be reached by both voices in the same direction. The pairs N1A#N1B and N2A#N2B are pairs of consecutive melodic notes,  whereas N1B and N2B are simultaneous notes. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity324">
<span class="keyword">proc</span>{<span class="functionname">IndexCardinality</span> Chords N}<br>
<span class="string"> Sets the total number of different chord indices in all Chords (a list of chords or scale objects) to N (FD int). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity325">
<span class="keyword">proc</span>{<span class="functionname">SetEachChordType</span> Chords Types}<br>
<span class="string"> Expects a list of chords and a list of atoms specifying chord types (indices) by name (e.g. 'major') and sets the index of each chord to the union of these types.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity326">
<span class="keyword">proc</span>{<span class="functionname">SetEachScaleType</span> Scales Types}<br>
<span class="string"> Expects a list of scales and a list of atoms specifying scale types (indices) by name (e.g. 'major') and sets the index of each scale to the union of these types.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity327">
<span class="keyword">proc</span>{<span class="functionname">RequireChordTypes</span> Chords Types}<br>
<span class="string"> In union of all Chords (list of chords) all Types (chord names given as atom, e.g., 'major') are present.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity328">
<span class="keyword">proc</span>{<span class="functionname">ExpressAllChordPCs</span> MyChord}<br>
<span class="string"> The union of the pitch classes of all notes notes simultaneous to MyChord fully expresses the pitch class set of this chord (more pitch classes are possibly, but all chord pitch classes must be played). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity329">
<span class="keyword">proc</span>{<span class="functionname">ExpressAllChordPCs_AtChordStart</span> MyChord}<br>
<span class="string"> Like ExpressAllChordPCs, but browses warning is number of sim notes is insufficient for expressing all chord tones.<BR>
 */<BR>
 NOTE: is it a good idea to have extra constraint for this?<BR>
    proc {ExpressAllChordPCs_Warn MyChord}<BR>
       thread	% waits until sim notes are accessible<BR>
 	 Ns = {MyChord getSimultaneousItems($ test:isNote)}<BR>
 	 C_Card = {FD.decl}<BR>
 	 PCs = {Map Ns fun {$ N} {N getPitchClass($)} end}<BR>
 	 PCsFS = {GUtils.intsToFS PCs}<BR>
       in<BR>
 	  C_Card = {FS.card {MyChord getPitchClasses($)}}<BR>
 	  if {Length Ns} >= C_Card then <BR>
 	     {FS.subset {MyChord getPitchClasses($)} PCsFS}<BR>
 	  else {Browse warn('not enough notes for expressing full chord')}<BR>
 	  end<BR>
       end<BR>
    end<BR>
/** %% More strict variant of ExpressAllChordPCs: all pitch classes must sound when chord starts.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity330">
<span class="keyword">proc</span>{<span class="functionname">ExpressAllChordPCs_AtChordEnd</span> MyChord}<br>
<span class="string"> More strict variant of ExpressAllChordPCs: all pitch classes must sound when chord end.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity331">
<span class="keyword">proc</span>{<span class="functionname">ExpressEssentialChordPCs</span> MyChord}<br>
<span class="string"> The union of the pitch classes of all notes notes simultaneous to MyChord fully express at least all essential pitch classes of this chord.<BR>
 NB: the the essential pitch classes must be defined with the feature essentialPitchClasses in the chord DB.<BR>
<BR>
 BUG: this constraint failed where ExpressAllChordPCs worked -- so there is likely a serious bug.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity332">
<span class="keyword">proc</span>{<span class="functionname">ExpressEssentialPCs_AtChordStart</span> MyChord}<br>
<span class="string"> More strict variant of ExpressEssentialChordPCs: all essential pitch classes must sound when chord starts.<BR>
 Because constraint application is not delayed so long, this more strict version can actuallyt be more efficient. <BR>
<BR>
 BUG: this constraint failed where ExpressAllChordPCs worked -- so there is likely a serious bug.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity333">
<span class="keyword">proc</span>{<span class="functionname">ClearHarmonyAtChordBoundaries</span> Chords VoiceNotes}<br>
<span class="string"> Defines contrapuntal constraint which implements proper suspension and other things. Chords is a list of chord objects and VoiceNotes a list of note objects which all belong to a single voice. At the border between two chords, the last voice note simultaneous to the preceeding chord and the first note simultaneous to the succeeding chord, these two notes should not be both non-chord tones (note: these two notes can be the same or different score objects, and have the same or different pitches).<BR>
 If the first note of a chord is a non-chord tone, then it should have the same pitch as the last of the previous chord. In other words: if a chord starts with a non-chord tone, then it must be a suspension (suspension are of course less clear in a solo line...). <BR>
 NB: this constraint assumes that neighbouring chords differ (e.g., have a different root), otherwise it is too strict.<BR>
 NB: this constraint does not define that non-chord tones are resolved stepwise, but it can be combined, e.g.., with ResolveNonharmonicNotes.<BR>
<BR>
 Internally, each chord accesses its first/last simultaneous note within VoiceNotes. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity350">
<span class="keyword">proc</span>{<span class="functionname">OnlyOrnamentalDissonance_Durations</span> Notes}<br>
<span class="string"> Allows only for 'ornamental' in contrast to 'emphasized' non-harmonic tones. This definition only takes note durations into account. It restricts that a non-harmonic note must be preceeded and followed by a note that is at least as long as the non-harmonic note itself.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity334">
<span class="keyword">proc</span>{<span class="functionname">VoiceLeadingDistance</span> Chord1 Chord2 N}<br>
<span class="string"> Harmonic constraint on directionless voice-leading distance N (FD int, measured in steps of the present equal temperament) between two chords Chord1 and Chord2. The distance N is the minimal sum of intervals between Chord1 and Chord2. The voice-leading distance is directionless in the sense that regardless whether a voice moves up or down, always the smaller interval is taken into account. The lower N, the more "smooth" is the harmonic progression (repetition is quasi most smooth). <BR>
 <BR>
 Example (in 12 ET): {VoiceLeadingDistance C_Major Ab_Major} = 2<BR>
 C->C=0 + E->Eb=1 + G->Ab=1, so the sum is 2<BR>
<BR>
 Note: Only the minimal intervals from all Chord2 pitch classes to Chord1 pitch classes are taking into account. Swapping the arguments can lead to different results: there may be pitch classes in Chord1 which are ignored as all pitch classes of Chord2 may be closer to some other pitch classes of Chord1.<BR>
<BR>
 Example: C-maj -> F#-maj = 4<BR>
 C->C#=1, C->A#=2, G->F#=1 -- the E of C-maj is ignored in the computation  <BR>
<BR>
 Note: relatively expensive constraint. Also, only effective after of both Chord1 and Chord2 are (mostly) determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity335">
<span class="keyword">fun</span>{<span class="functionname">VoiceLeadingDistance_Percent</span> Chord1 Chord2}<br>
<span class="string"> Like VoiceLeadingDistance, but returns a percentage value depending on the cardiality of both Chord1 and Chord2. 100 percent is the theoretical maximum that all intervals are halve octaves.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity336">
<span class="keyword">proc</span>{<span class="functionname">SmallIntervalsInProgression</span> Chord1 Chord2 Args N}<br>
<span class="string"> Harmonic constraint for creating chord progressions where many pitch classes change by small intervals. N (FD int, implicitly declared) is the number of pitch class intervals between Chord1 and Chord2 which are =< some maximal interval, typically a semitone. The higher N, the more smooth is the transition (for VoiceLeadingDistance it is the other way round!).<BR>
<BR>
 Args:<BR>
 'maxInterval': the maximum size of the interval which counts into the percentage. Default is the septimal diatonic semitone (15#14, i.e. given as a pair of integers denoting a ratio).<BR>
 'ignoreUnisons': if true (the default), unisons do not count into the percentage.<BR>
 <BR>
 Examples:<BR>
<BR>
 {SmallIntervalProgression C_Major Ab_Major unit} = 2<BR>
 Small intervals counting: E->Eb, G->Ab <BR>
<BR>
 {SmallIntervalProgression C_Major Ab_Major unit(ignoreUnisons:false)} = 3<BR>
 Small intervals counting: C->C, E->Eb, G->Ab <BR>
<BR>
 Note: relatively expensive constraint. Also, only effective after of both Chord1 and Chord2 are (mostly) determined. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity337">
<span class="keyword">proc</span>{<span class="functionname">SmallIntervalsInProgression_Percent</span> Chord1 Chord2 Args Percent}<br>
<span class="string"> Like SmallIntervalsInProgression, but constraints the percentage depending on the cardiality of both Chord1 and Chord2. 100 percent denotes the cardiality of the chord with more notes, 0 percent means no note pair changes by a small interval.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity338">
<span class="keyword">proc</span>{<span class="functionname">RestrictPitchDomain</span> Notes MaxDom MinDom}<br>
<span class="string"> Expects a list of notes and two pitches MaxDom and MinDom (specified in the formats supported by HS.pitch, e.g., a pitch integer or an ET31 pitch specified like 'C'#4). These set the upper and lower pitch domain of all notes.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity339">
<span class="keyword">proc</span>{<span class="functionname">IsStep</span> Pitch1 Pitch2 MaxStep}<br>
<span class="string"> The interval between Pitch1 and Pitch2 is in [1, MaxStep].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity340">
<span class="keyword">proc</span>{<span class="functionname">IsStepR</span> Pitch1 Pitch2 MaxStep B}<br>
<span class="string"> In case B=1, the interval between Pitch1 and Pitch2 is in [1, MaxStep]. B is implicitly declared an 0/1 integer. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity341">
<span class="keyword">proc</span>{<span class="functionname">ResolveStepwiseR</span> Note Args B}<br>
<span class="string"> Constraints the interval between the pitches of Note and its successor to be in [0, MaxStep]. MaxStep defaults to 2 and can be set as optional feature of Args. Per default, the successor note is the successor of Note in the sequence of items contained in the temporal aspect of Note (i.e. the sequence/list returned by {GetTemporalAspectItems Note}). This setting can be changed with the optional Args feature getXs (e.g. to a function which does return the list of items recursively contained in the temporal aspect of the temporal aspect Note. Such setting would apply ResolveStepwiseR even across container boundaries when Note is the last element in its temporal aspect).<BR>
 In case Note has no successor, B=0.<BR>
<BR>
 BTW: ResolveStepwiseR defines a dissonance treatment simplification. Most of the conventional non-harmonic note pitch conditions identified by Piston (see above) are permitted: appoggiatura, passing note, suspension, anticipation, auxiliary, and cambiata. Only the echappee is excluded by ResolveStepwiseR.<BR>
 Nevertheless, the simplification ResolveStepwiseR allows also cases which are not permitted by the conventional non-harmonic note pitch treatment (e.g. an appoggiatura on an easy beat, or a long anticipation which preceeds a short note on an easy beat).<BR>
 Problem: if any note (even regardless of metric position) can be understood as appoggiatura, the implicit harmony is easily misread.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity343">
<span class="keyword">proc</span>{<span class="functionname">PassingNotePitches</span> [Pitch1 Pitch2 Pitch3] MaxStep}<br>
<span class="string"> Constraints [Pitch1 Pitch2 Pitch3] such that Pitch2 forms a passing note pitch. The intervals between neighbouring pitches are in [1, MaxStep] (usually, MaxStep = PitchesPerOctave div 6) and the pitch sequence is either monotonically increasing or decreasing. All pitches are FD ints, MaxStep is int.<BR>
 NB: for this rule, it is irrelevant whether any pitch is consonant, or dissonant and whether it is a chord pitch or not.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity344">
<span class="keyword">proc</span>{<span class="functionname">PassingNotePitchesR</span> [Pitch1 Pitch2 Pitch3] MaxStep B}<br>
<span class="string"> Reified version of PassingNotes (see above).<BR>
 NB: Introduces a FD int which may not be determined (in case B=0).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity345">
<span class="keyword">proc</span>{<span class="functionname">IsPassingNoteR</span> Note Args B}<br>
<span class="string"> In case B=1, Note is a passing note between its predecessor and successor. Args is a record of optional arguments: maxStep (defaults to 2) and getXs, a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note.<BR>
 See also PassingNotePitches and PassingNotePitchesR above.<BR>
 In case Note has no predecessor or successor, B=0.<BR>
 BTW: IsPassingNoteR is a generic passing note definition which can be applied, e.g., to a melody across container boundaries (e.g. a melody consisting in motifs which consist in note sequences) by returning the list of notes in this melody from getXs.<BR>
 NB: Predecessor and successor of Note must be notes as well!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity342">
<span class="keyword">proc</span>{<span class="functionname">IsBetweenChordNotesR</span> Note Args B}<br>
<span class="string"> In case B=1, both the predecessor and successor of Note return 1 (i.e. true) for the method isInChord (which means that both notes are harmonic notes: their pitch class is included in the pitch classes of their repsective chord).  Args is a record with the optional argument getXs, a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note.   <BR>
 In case Note has no predecessor or successor, B=0. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity346">
<span class="keyword">proc</span>{<span class="functionname">IsAuxiliaryR</span> Note Args B}<br>
<span class="string"> In case B=1, both the predecessor and successor of Note have the same pitch and the pitch of Note is only a step away.<BR>
 Args is a record with the optional argument maxStep (defaults to 2) and getXs (a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note). See also ResolveStepwiseR for an explaination of Args.<BR>
 In case Note has no predecessor or successor, B=0. <BR>
 NB: Predecessor and successor of Note must be notes as well!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity347">
<span class="keyword">proc</span>{<span class="functionname">IsBetweenStepsR</span> Note Args B}<br>
<span class="string"> In case B=1, both the pitches of the predecessor and successor are only a step away from Note's pitch.<BR>
 Args is a record with the optional argument maxStep (defaults to 2) and getXs (a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note). See also ResolveStepwiseR for an explaination of Args.<BR>
 In case Note has no predecessor or successor, B=0.<BR>
<BR>
 BTW: This rule generalises passing note and auxiliary. Nevertheless, a further case is also permitted: pitch contour between three successive notes as for an auxiliary, but predecessor and successor have different pitches. For instance, in case maxStep=2, predecessor and successor differ by a semitone.<BR>
 NB: Predecessor and successor of Note must be notes as well!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity348">
<span class="keyword">proc</span>{<span class="functionname">ResolveNonharmonicNotesStepwise</span> Notes Args}<br>
<span class="string"> Melodic constraint for list of Notes: non-chord tones are only permitted if they are reached and left by a step. The first and last element of Notes is constrained to a chord tone.<BR>
<BR>
 Args:<BR>
 'maxInterval': an ratio spec for the maximum step-size permitted. Default is a septimal second (8#7). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity349">
<span class="keyword">proc</span>{<span class="functionname">ClearDissonanceResolution</span> VoiceNotes}<br>
<span class="string"> Variant of ResolveNonharmonicNotesStepwise which accesses the predecessor and sucessor note from a given note explicitly. Non-chord tones are only permitted for MyNote if they are reached and left by a step. If no predecessor or successor is accessible for MyNote, then it must be a chord tone. <BR>
<BR>
 Args:<BR>
 'maxInterval': an integer specifying the maximum step-size permitted. Default is the interval corresponding to a septimal second (8/7). <BR>
 'getPredecessor' and 'getSuccessor': unary function returning the predecessor/successor for the given note. Default are the methods getTemporalPredecessor/getTemporalSuccessor.<BR>
 NOTE: If motifs are wrapped in containers, then the first (last) motif note has no predecessor (successor) and consequently must be a chord tone. This default behaviour can be changed using different 'getPredecessor' and 'getSuccessor' settings.<BR>
 NOTE: the default 'getPredecessor' and 'getSuccessor' do allow for pauses between chord tones and non-harmonic tones. Classical music theory does this as well, but not completely unrestricted. Again, this can be changed by using different 'getPredecessor' and 'getSuccessor' settings.<BR>
 */<BR>
 proc {ResolveNonharmonicNotesStepwise2 MyNote Args}<BR>
    Defaults = unit(getPredecessor: fun {$ N}<BR>
 				      X = {N getTemporalPredecessor($)}<BR>
 				   in <BR>
 replace X by comment if pauses should not occur between predecessor/successor and MyNote<BR>
 				      X<BR>
 				      if X == nil orelse {X isPause($)} orelse ({N getOffsetTime} >: 0) == 1<BR>
 				      then nil<BR>
 				      else X<BR>
 				      end<BR>
 				   end<BR>
 		   getSuccessor: fun {$ N}<BR>
 				    X = {N getTemporalSuccessor($)}<BR>
 				 in<BR>
 replace X by comment if pauses should not occur between predecessor/successor and MyNote<BR>
 				    X<BR>
 				    if X == nil orelse {X isPause($)} orelse ({X getOffsetTime} >: 0) == 1<BR>
 				    then nil<BR>
 				    else X<BR>
 				    end<BR>
 				 end<BR>
<BR>
 		   maxInterval: SeptimalSecond<BR>
 		  )<BR>
    As = {Adjoin Defaults Args}<BR>
    /** %% B=1 <-> MyNote is entered and left by a step.<BR>
 */<BR>
    proc {Aux MyNote B}<BR>
       Pre = {As.getPredecessor MyNote}<BR>
       Succ = {As.getSuccessor MyNote}<BR>
    in<BR>
       B = {FD.int 0#1}		% needed?<BR>
       if Pre \= nil andthen Succ \= nil<BR>
       then<BR>
 	 B = {FD.conj {ConstrainMaxIntervalR Pre MyNote As.maxInterval}<BR>
 	      {ConstrainMaxIntervalR MyNote Succ As.maxInterval}}<BR>
       else B=0			% otherwise always a consonance<BR>
       end<BR>
    end<BR>
 in<BR>
    thread			% accessors block<BR>
       {MyNote nonChordPCConditions([Aux])}<BR>
    end<BR>
 end<BR>
<BR>
<BR>
<BR>
<BR>
/** %% [contrapuntual constraint] If in one voice there occurs a non-chord tone followed by a chord tone (a dissonance resolution), then no other voice should obscure this resolution by a non-chord tone starting together with the tone resolving the dissonance. However, simultaneous dissonances can start more early or later.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity351">
<span class="keyword">proc</span>{<span class="functionname">IntervalBetweenNonharmonicTonesIsConsonant</span> Notes ConsonantIntervals}<br>
<span class="string"> [contrapuntual constraint] Constraints that all pairs of simultaneous non-harmonic tones (i.e. the inChordB parameter = 0) form consonant intervals among each other. Notes is the list of all notes which potentially are non-harmonic tones (e.g., all notes in the score). ConsonantIntervals is a FD int domain specification (e.g., a list of integers) which specifies the allowed intervals.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity352">
<span class="keyword">proc</span>{<span class="functionname">MaxInterval</span> Notes MaxInt}<br>
<span class="string"> Constraints that no pitch interval between consecutive Notes (list of note objects) exceeds MaxInt (FD int).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity353">
<span class="keyword">proc</span>{<span class="functionname">MaxNonharmonicNoteSequence</span> Notes N}<br>
<span class="string"> Restrict the number of consecutive non-harmonic Notes (list of note objects) to N a maximum. Non-harmonic notes are notes for which the method getInChordB returns 0 (i.e. false).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity354">
<span class="keyword">proc</span>{<span class="functionname">MaxNonharmonicNotePercent</span> Notes MaxPercent}<br>
<span class="string"> Restrict the maximum percentage of non-harmonic Notes (list of note objects) to MaxPercent.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity355">
<span class="keyword">proc</span>{<span class="functionname">MaxRepetitions</span> Notes N}<br>
<span class="string"> N specifies how many pitch repetitions occur at maximum between consecutive Notes (list of note objects), i.e. how many pitch intervals are 0. If N=0 then no repetitions are permitted.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity356">
<span class="keyword">proc</span>{<span class="functionname">MinPercentSteps</span> Notes MinPercent Args}<br>
<span class="string"> Constrains the interval between Notes (list of note objects): there are at least MinPercent steps. The optional argument 'step' sets the step size as a frequency ratio (default 8#7).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity357">
<span class="keyword">proc</span>{<span class="functionname">Ballistic</span> Pitches Args}<br>
<span class="string"> After a upward (downward) skip, either move into the same direction by a smaller (larger) skip or step, or move into the opposite direction. Pitches is a list of FD ints.<BR>
<BR>
 Args:<BR>
 'maxStep' (default 8#7): maximal step size, specified as ratio (pair of integers).<BR>
 'oppositeIsStep' (default false): if true and direction is changed after a skip, then this first interval into the opposite direction must be a step.<BR>
<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>