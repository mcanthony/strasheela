<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Rules</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="17" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">HarmonisedScore</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">DB</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">HSScore</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">Rules</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">DBs</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">Distro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">Schoenberg</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">Default</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Jazz</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Partch</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">Johnston</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node12.html">Harrison</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node13.html">Chalmers</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node14.html">Catler</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node15.html">ArithmeticalSeriesChords</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node16.html">HS</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor defines several general rules/constraints (i) on chords and/or scales and (ii) melodic rules etc.<BR>
<BR>
<BR>
<BR>
 Background info to melodic rules: conventional non-harmonic note pitch conditions (according to Piston. Counterpoint, Norton, 1947) <BR>
<BR>
   - appoggiatura (Vorhalt?): stressed dissonance: step or skip (more common than step, adds emphasis) from any direction into dissonance, resolved in second below or above. Dissonance on strong beat (requires metric position). Dissonance can be further stressed by a note duration longer than following note.<BR>
    Torsten added: 'likes' to resolve in semitone, specially if upwards (Mozart..)<BR>
<BR>
   - passing note (Durchgang): diatonic or chormatic progression continued in same direction. Passing note always weak rhythmical quality -- even when occuring on first beat of measure (!!). According to Piston, notes are analysed as either appoggiatura or passing only depending on their rhythmic weight.<BR>
     Exceptionally are 'passing notes' without any directly preceeding notes (this note sounded in other voice). <BR>
<BR>
   - suspension (vorbereiteter Vorhalt?): in classic case, a (comparatively long) harmonic note is 'tied over' -- the harmony changes and turnes the 'tied over' note into a non-harmonic note. Usually/often, this dissonance longs at least a beat. Suspensions are resolved in stepwise motion (usually downwards, upwards more likely in case of leading notes  or chormatically raised notes). The suspension may resolved into next harmony (i.e. after the harmony it formed a dissonance in). The suspendend note is (in all cases?) longer than its successor.<BR>
<BR>
   - anticipation (Vorausnahme): dissonant note on easy beat preceeding the same consonant note pitch on strong beat (i.e. the harmony changed). The dissonant anticipation is shorter than its consonant successor.<BR>
<BR>
   - auxiliary (Nebennote): ornamental single note, leaving and returning to the same note by a second up or down. The harmony may meanwhile change.<BR>
<BR>
   - echappee/cambiata (Torsten: standardised case of ornamental resolution?): stepwise movement of melody 'ornamented' note between. Echappee: leaves first note by stepwise motion in opposite direction and 'resolves' by skip of third to destination. Cambiata: first note by skip of third in opposite direction and 'resolves' by step to destination. Echappee and cambiata are rhythmically weak.<BR>
     Variants with more freedom: larger skip than third or all movements in same direction (quasi like passing note with skip). Combination to double auxiliary (or changing-tones): echappee and cambiata follow each other directly as two dissonances.  <BR>
<BR>
   - ornamental resolution: (i) multiple 'standard' dissonances directly following each other. E.g., appoggiatura directly followed by cambiata (i.e. with delayed resolution). (ii) arbitrary consonant chord note between 'standard' dissonance treatment. E.g., before passing note skip to some other chord note and (possibly) skip back to actual passing note. (iii) a group of interpolated tones (Piston recomments studying Bach 'Italian Concerto')<BR>
<BR>
<BR>
 Problem with specific non-harmonic pitches, especially appoggiatura, in this context: how to 'motivate' non-harmonic pitches. E.g. in case of melody harmonisation, obviously harmonic pitches followed by a passing note could be understood as non-harmonic pitches which resolve into a harmonic pitch..<BR>
<BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Rules ("<span class="string">/Users/t/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/HarmonisedScore/source/Rules.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li>FS</li><li>Select at "<span class="string">x-ozlib://duchier/cp/Select.ozf"
</span></li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>MUtils at "<span class="string">x-ozlib://anders/strasheela/source/MusicUtils.ozf"
</span></li><li>SMapping at "<span class="string">x-ozlib://anders/strasheela/source/ScoreMapping.ozf"
</span></li><li>Pattern at "<span class="string">x-ozlib://anders/strasheela/Pattern/Pattern.ozf"
</span></li><li><a href="node3.html">HS_Score</a> at "<span class="string">Score.ozf"
</span></li><li><a href="node2.html">DB</a> at "<span class="string">Database.ozf"
</span></li><li><a href="node7.html">Schoenberg</a> at "<span class="string">Schoenberg.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li><span class="variablename">Schoenberg</span>
</li><li>&lt;P/3:<a href="#entity233"><span class="functionname">GetFeature</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity234"><span class="functionname">UnequalParameter</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity235"><span class="functionname">UnequalParameterR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity236"><span class="functionname">NeighboursWithUnequalParameter</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity237"><span class="functionname">Distinct</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity238"><span class="functionname">DistinctR</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity239"><span class="functionname">DistinctNeighbours</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity240"><span class="functionname">PairwiseDistinct</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity241"><span class="functionname">ButNDistinct</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity242"><span class="functionname">DistinctForN</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity243"><span class="functionname">CommonPCs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity244"><span class="functionname">CommonPCs_Card</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity245"><span class="functionname">CommonPCsR</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity246"><span class="functionname">NeighboursWithCommonPCs</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity247"><span class="functionname">ParameterDistance</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity248"><span class="functionname">ParameterDistanceR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity249"><span class="functionname">LimitParameterDistanceOfNeighbours</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity250"><span class="functionname">Cadence</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity251"><span class="functionname">DiatonicChord</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity252"><span class="functionname">NoteInPCCollection</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity253"><span class="functionname">ExpressAllChordPCs</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity254"><span class="functionname">ExpressAllChordPCs_AtChordStart</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity255"><span class="functionname">ExpressEssentialChordPCs</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity256"><span class="functionname">ExpressEssentialPCs_AtChordStart</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity257"><span class="functionname">ClearHarmonyAtChordBoundaries</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity258"><span class="functionname">VoiceLeadingDistance</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity259"><span class="functionname">VoiceLeadingDistance_Percent</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity260"><span class="functionname">SmallIntervalProgressions</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity261"><span class="functionname">SmallIntervalProgressions_Percent</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity262"><span class="functionname">IsStep</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity263"><span class="functionname">IsStepR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity264"><span class="functionname">ResolveStepwiseR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity266"><span class="functionname">PassingNotePitches</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity267"><span class="functionname">PassingNotePitchesR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity268"><span class="functionname">IsPassingNoteR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity265"><span class="functionname">IsBetweenChordNotesR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity269"><span class="functionname">IsAuxiliaryR</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity270"><span class="functionname">IsBetweenStepsR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity271"><span class="functionname">ResolveNonharmonicNotesStepwise</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity272"><span class="functionname">ClearDissonanceResolution</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity273"><span class="functionname">IntervalBetweenNonharmonicTonesIsConsonant</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity274"><span class="functionname">MaxInterval</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity275"><span class="functionname">MaxNonharmonicNoteSequence</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity276"><span class="functionname">MaxNonharmonicNotePercent</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity277"><span class="functionname">MaxRepetitions</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity278"><span class="functionname">MinPercentSteps</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity279"><span class="functionname">GetInterval</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity280"><span class="functionname">ConstrainMaxIntervalR</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity233">
<span class="keyword">proc</span>{<span class="functionname">GetFeature</span> X Feat I}<br>
<span class="string"> Constraints the chord/scale X: the arbitrary (user defined) chord/scale database feature value at Feat is accessed/constrained to I (a FD int or FS var, depending on the feature). For instance, if X is a chord and the chord database defines a numeric 'dissonanceDegree' for each chord in the database, <code> {GetFeature X 'dissonanceDegree' 2} </code> constraints the index of X to point to a chord spec in the database which has a dissonanceDegree of 2.<BR>
 NB. GetFeature employs a selection constrain: multiple applications of GetFeature with the same Feat will accessed/constrain the same value I with multiple selection constraint propagators, which should be avoided..<BR>
<BR>
 !! NB: does not work for intervalDB, because there is no interval ADT which defines getDB and getIndex for interval.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity234">
<span class="keyword">proc</span>{<span class="functionname">UnequalParameter</span> X Y Fn}<br>
<span class="string"> The chords/scales X and Y differ in the parameter/attribute accessed by Fn (a unary function or method). For instance, <code> {UnequalParameter X Y getIndex} </code> constrains the indices of X and Y to differ.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity235">
<span class="keyword">proc</span>{<span class="functionname">UnequalParameterR</span> X Y Fn B}<br>
<span class="string"> Reified version of DistinctParameter: B=1 <-> chords/scales X and Y differ in the parameter/attribute accessed by Fn.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity236">
<span class="keyword">proc</span>{<span class="functionname">NeighboursWithUnequalParameter</span> Xs Fn}<br>
<span class="string"> All successive chord/scale pairs in list Xs differ in the parameter/attribute accessed by Fn.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity237">
<span class="keyword">proc</span>{<span class="functionname">Distinct</span> X Y}<br>
<span class="string"> The chords/scales X and Y have either different indices or different transpositions or both. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity238">
<span class="keyword">proc</span>{<span class="functionname">DistinctR</span> X Y B}<br>
<span class="string">  B=1 <-> The chords/scales X and Y have either different indices or different transpositions or both.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity239">
<span class="keyword">proc</span>{<span class="functionname">DistinctNeighbours</span> Xs}<br>
<span class="string"> All successive chord/scale pairs in list Xs have either different indices or different transpositions or both.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity240">
<span class="keyword">proc</span>{<span class="functionname">PairwiseDistinct</span> Xs}<br>
<span class="string"> All chords/scales in list Xs are pairwise distinct, i.e. they have either different indices or different transpositions or both.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity241">
<span class="keyword">proc</span>{<span class="functionname">ButNDistinct</span> Xs N}<br>
<span class="string"> All but N (a FD int) chords/scales in list Xs are pairwise distinct, i.e. they have either different indices or different transpositions or both. That is, N=4 <-> four chords/scales are not unique in Xs (either all four are the same or two different chords/scales repeated).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity242">
<span class="keyword">proc</span>{<span class="functionname">DistinctForN</span> Xs N}<br>
<span class="string"> Xs (a list of chords/scales) is split into sublists of length N: in each sublist, all chords/scales are pairwise distinct.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity243">
<span class="keyword">proc</span>{<span class="functionname">CommonPCs</span> X Y}<br>
<span class="string"> Constraints the chords/scales X and Y to have at least 1 common pitch class.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity244">
<span class="keyword">proc</span>{<span class="functionname">CommonPCs_Card</span> X Y N}<br>
<span class="string"> N (an FD int) is the cardiality of the set of common pitch classes between the chords/scales X and Y.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity245">
<span class="keyword">proc</span>{<span class="functionname">CommonPCsR</span> X Y B}<br>
<span class="string"> Reified version of CommonPCs: B=1 <-> chords/scales X and Y have at least 1 common pitch class. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity246">
<span class="keyword">proc</span>{<span class="functionname">NeighboursWithCommonPCs</span> Xs}<br>
<span class="string"> Each successive chord/scale pair in list Xs has at least 1 common pitch class.<BR>
 NB: The constraint introduces auxilary variables which possibly remain undetermined in the solution. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity247">
<span class="keyword">proc</span>{<span class="functionname">ParameterDistance</span> X Y Fn I}<br>
<span class="string"> Constraints the distance between the parameter/feature accessible with Fn of the chords/scales X and Y to I (a FD integer). For instance, if X and Y are chords and the chord database defines the numeric feature dissonanceDegree, the dissonanceDegree distance between X and Y is set to 1 by<BR>
 <code> {ParameterDistance X Y fun {$ X} {GetFeature X dissonanceDegree} end 1} </code><BR>
<BR>
</span>
</code><br>

<code>
<a name="entity248">
<span class="keyword">proc</span>{<span class="functionname">ParameterDistanceR</span> X Y Fn I B}<br>
<span class="string"> Reified version of ParameterDistance.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity249">
<span class="keyword">proc</span>{<span class="functionname">LimitParameterDistanceOfNeighbours</span> Xs Fn Max}<br>
<span class="string"> Limits the the distance between the parameter/feature accessible with Fn of the neigbouring chords/scales in Xs not to exceed Max (a FD integer, but in most cases an integer will do).<BR>
<BR>
 !! Better define LimitDistanceOfNeighbours as Pattern expecting list of FD ints..<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity250">
<span class="keyword">proc</span>{<span class="functionname">Cadence</span> MyScale Chords}<br>
<span class="string"> Constraints the union of the pitch classes of Chords (a list of chord objects) to be the same set as the set of pitch classes of MyScale (a scale object). In other words, all chords only use scale tones (diatonic chords) and all scale tones are played.  Also, the root of the last chord is constrained to the root of the scale.<BR>
 In common usage, Chords has length three and is applied to the last three chords of a progression.<BR>
 This constraint goes well with HS.rules.schoenberg.ascendingProgressionR and frieds (results in the common cadences for major in 12 ET, and plagal cadences for natural minor).<BR>
<BR>
 Note: this constraint implements a particular strict notion of a cadence, were all scale notes must sound. A less strict version would require that only pitch classes which distinguish a scale among all other likely scales are sufficient (e.g., the pitch classes G, B, and F are sufficient to distinguish C-major between all major scales). However, such a constraint is more context dependent and requires information on all scales which are alternatively possible (e.g., G, B, and F are not sufficient to confirm C-major if the scale could also be Dorian). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity251">
<span class="keyword">proc</span>{<span class="functionname">DiatonicChord</span> MyChord MyScale}<br>
<span class="string"> All pitch classes of MyChord are in MyScale (scale must of course not diatonic, procedure name uses the phrase "diatonic to" as a synonym for "belonging to"). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity252">
<span class="keyword">proc</span>{<span class="functionname">NoteInPCCollection</span> MyNote MyPCCollection}<br>
<span class="string"> The pitch class of MyNote is in MyPCCollection (a chord or a scale).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity253">
<span class="keyword">proc</span>{<span class="functionname">ExpressAllChordPCs</span> MyChord}<br>
<span class="string"> The union of the pitch classes of all notes notes simultaneous to MyChord fully expresses the pitch class set of this chord (more pitch classes are possibly, but all chord pitch classes must be played). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity254">
<span class="keyword">proc</span>{<span class="functionname">ExpressAllChordPCs_AtChordStart</span> MyChord}<br>
<span class="string"> More strict variant of ExpressAllChordPCs: all pitch classes must sound when chord starts.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity255">
<span class="keyword">proc</span>{<span class="functionname">ExpressEssentialChordPCs</span> MyChord}<br>
<span class="string"> The union of the pitch classes of all notes notes simultaneous to MyChord fully express at least all essential pitch classes of this chord.<BR>
 NB: the the essential pitch classes must be defined with the feature essentialPitchClasses in the chord DB.<BR>
<BR>
 BUG: this constraint failed where ExpressAllChordPCs worked -- so there is likely a serious bug.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity256">
<span class="keyword">proc</span>{<span class="functionname">ExpressEssentialPCs_AtChordStart</span> MyChord}<br>
<span class="string"> More strict variant of ExpressEssentialChordPCs: all essential pitch classes must sound when chord starts.<BR>
 Because constraint application is not delayed so long, this more strict version can actuallyt be more efficient. <BR>
<BR>
 BUG: this constraint failed where ExpressAllChordPCs worked -- so there is likely a serious bug.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity257">
<span class="keyword">proc</span>{<span class="functionname">ClearHarmonyAtChordBoundaries</span> Chords VoiceNotes}<br>
<span class="string"> Defines contrapuntal constraint which implements proper suspension and other things. Chords is a list of chord objects and VoiceNotes a list of note objects which all belong to a single voice. At the border between two chords, the last voice note simultaneous to the preceeding chord and the first note simultaneous to the succeeding chord, these two notes should not be both non-chord tones (note: these two notes can be the same or different score objects, and have the same or different pitches).<BR>
 If the first note of a chord is a non-chord tone, then it should have the same pitch as the last of the previous chord. In other words: if a chord starts with a non-chord tone, then it must be a suspension (suspension are of course less clear in a solo line...). <BR>
 NB: this constraint assumes that neighbouring chords differ (e.g., have a different root), otherwise it is too strict.<BR>
 NB: this constraint does not define that non-chord tones are resolved stepwise, but it can be combined, e.g.., with ResolveNonharmonicNotes.<BR>
<BR>
 Internally, each chord accesses its first/last simultaneous note within VoiceNotes. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity258">
<span class="keyword">proc</span>{<span class="functionname">VoiceLeadingDistance</span> Chord1 Chord2 N}<br>
<span class="string"> Harmonic constraint on directionless voice-leading distance N (FD int, measured in steps of the present equal temperament) between two chords Chord1 and Chord2. The distance N is the minimal sum of intervals between Chord1 and Chord2. The voice-leading distance is directionless in the sense that regardless whether a voice moves up or down, always the smaller interval is taken into account.  <BR>
 <BR>
 Example (in 12 ET): {VoiceLeadingDistance C_Major Ab_Major} = 2<BR>
 C->C=0 + E->Eb=1 + G->Ab=1, so the sum is 2<BR>
<BR>
 Note: Only the minimal intervals from all Chord2 pitch classes to Chord1 pitch classes are taking into account. Swapping the arguments can lead to different results: there may be pitch classes in Chord1 which are ignored as all pitch classes of Chord2 may be closer to some other pitch classes of Chord1.<BR>
<BR>
 Example: C-maj -> F#-maj = 4<BR>
 C->C#=1, C->A#=2, G->F#=1 -- the E of C-maj is ignored in the computation  <BR>
<BR>
 Note: relatively expensive constraint. Also, only effective after of both Chord1 and Chord2 are (mostly) determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity259">
<span class="keyword">fun</span>{<span class="functionname">VoiceLeadingDistance_Percent</span> Chord1 Chord2}<br>
<span class="string"> Like VoiceLeadingDistance, but returns a percentage value depending on the cardiality of both Chord1 and Chord2. 100 percent is the theoretical maximum that all intervals are halve octaves.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity260">
<span class="keyword">proc</span>{<span class="functionname">SmallIntervalProgressions</span> Chord1 Chord2 Args N}<br>
<span class="string"> Harmonic constraint for creating chord progressions where many pitch classes change by small intervals. N (FD int, implicitly declared) is the number of pitch class intervals between Chord1 and Chord2 which are =< some maximal interval, typically a semitone. <BR>
 Args:<BR>
 'maxInterval': the maximum size of the interval which counts into the percentage. Default is the septimal diatonic semitone (15#14).<BR>
 'ignoreUnisons': if true (the default), unisons do not count into the percentage.<BR>
 <BR>
 Examples:<BR>
<BR>
 {SmallIntervalProgression C_Major Ab_Major unit} = 2<BR>
 Small intervals counting: E->Eb, G->Ab <BR>
<BR>
 {SmallIntervalProgression C_Major Ab_Major unit(ignoreUnisons:false)} = 3<BR>
 Small intervals counting: C->C, E->Eb, G->Ab <BR>
<BR>
 Note: relatively expensive constraint. Also, only effective after of both Chord1 and Chord2 are (mostly) determined. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity261">
<span class="keyword">fun</span>{<span class="functionname">SmallIntervalProgressions_Percent</span> Chord1 Chord2 Args}<br>
<span class="string"> Like SmallIntervalProgressions, but returns a percentage value depending on the cardiality of both Chord1 and Chord2. 100 percent is the cardiality of the chord with more notes.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity262">
<span class="keyword">proc</span>{<span class="functionname">IsStep</span> Pitch1 Pitch2 MaxStep}<br>
<span class="string"> The interval between Pitch1 and Pitch2 is in [1, MaxStep].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity263">
<span class="keyword">proc</span>{<span class="functionname">IsStepR</span> Pitch1 Pitch2 MaxStep B}<br>
<span class="string"> In case B=1, the interval between Pitch1 and Pitch2 is in [1, MaxStep]. B is implicitly declared an 0/1 integer. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity264">
<span class="keyword">proc</span>{<span class="functionname">ResolveStepwiseR</span> Note Args B}<br>
<span class="string"> Constraints the interval between the pitches of Note and its successor to be in [0, MaxStep]. MaxStep defaults to 2 and can be set as optional feature of Args. Per default, the successor note is the successor of Note in the sequence of items contained in the temporal aspect of Note (i.e. the sequence/list returned by {GetTemporalAspectItems Note}). This setting can be changed with the optional Args feature getXs (e.g. to a function which does return the list of items recursively contained in the temporal aspect of the temporal aspect Note. Such setting would apply ResolveStepwiseR even across container boundaries when Note is the last element in its temporal aspect).<BR>
 In case Note has no successor, B=0.<BR>
<BR>
 BTW: ResolveStepwiseR defines a dissonance treatment simplification. Most of the conventional non-harmonic note pitch conditions identified by Piston (see above) are permitted: appoggiatura, passing note, suspension, anticipation, auxiliary, and cambiata. Only the echappee is excluded by ResolveStepwiseR.<BR>
 Nevertheless, the simplification ResolveStepwiseR allows also cases which are not permitted by the conventional non-harmonic note pitch treatment (e.g. an appoggiatura on an easy beat, or a long anticipation which preceeds a short note on an easy beat).<BR>
 Problem: if any note (even regardless of metric position) can be understood as appoggiatura, the implicit harmony is easily misread.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity266">
<span class="keyword">proc</span>{<span class="functionname">PassingNotePitches</span> [Pitch1 Pitch2 Pitch3] MaxStep}<br>
<span class="string"> Constraints [Pitch1 Pitch2 Pitch3] such that Pitch2 forms a passing note pitch. The intervals between neighbouring pitches are in [1, MaxStep] (usually, MaxStep = PitchesPerOctave div 6) and the pitch sequence is either monotonically increasing or decreasing. All pitches are FD ints, MaxStep is int.<BR>
 NB: for this rule, it is irrelevant whether any pitch is consonant, or dissonant and whether it is a chord pitch or not.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity267">
<span class="keyword">proc</span>{<span class="functionname">PassingNotePitchesR</span> [Pitch1 Pitch2 Pitch3] MaxStep B}<br>
<span class="string"> Reified version of PassingNotes (see above).<BR>
 NB: Introduces a FD int which may not be determined (in case B=0).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity268">
<span class="keyword">proc</span>{<span class="functionname">IsPassingNoteR</span> Note Args B}<br>
<span class="string"> In case B=1, Note is a passing note between its predecessor and successor. Args is a record of optional arguments: maxStep (defaults to 2) and getXs, a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note.<BR>
 See also PassingNotePitches and PassingNotePitchesR above.<BR>
 In case Note has no predecessor or successor, B=0.<BR>
 BTW: IsPassingNoteR is a generic passing note definition which can be applied, e.g., to a melody across container boundaries (e.g. a melody consisting in motifs which consist in note sequences) by returning the list of notes in this melody from getXs.<BR>
 NB: Predecessor and successor of Note must be notes as well!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity265">
<span class="keyword">proc</span>{<span class="functionname">IsBetweenChordNotesR</span> Note Args B}<br>
<span class="string"> In case B=1, both the predecessor and successor of Note return 1 (i.e. true) for the method isInChord (which means that both notes are harmonic notes: their pitch class is included in the pitch classes of their repsective chord).  Args is a record with the optional argument getXs, a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note.   <BR>
 In case Note has no predecessor or successor, B=0. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity269">
<span class="keyword">proc</span>{<span class="functionname">IsAuxiliaryR</span> Note Args B}<br>
<span class="string"> In case B=1, both the predecessor and successor of Note have the same pitch and the pitch of Note is only a step away.<BR>
 Args is a record with the optional argument maxStep (defaults to 2) and getXs (a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note). See also ResolveStepwiseR for an explaination of Args.<BR>
 In case Note has no predecessor or successor, B=0. <BR>
 NB: Predecessor and successor of Note must be notes as well!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity270">
<span class="keyword">proc</span>{<span class="functionname">IsBetweenStepsR</span> Note Args B}<br>
<span class="string"> In case B=1, both the pitches of the predecessor and successor are only a step away from Note's pitch.<BR>
 Args is a record with the optional argument maxStep (defaults to 2) and getXs (a unary function applied to Note returning the list of items in the melody including Note, defaults to the items in the temporal aspect of Note). See also ResolveStepwiseR for an explaination of Args.<BR>
 In case Note has no predecessor or successor, B=0.<BR>
<BR>
 BTW: This rule generalises passing note and auxiliary. Nevertheless, a further case is also permitted: pitch contour between three successive notes as for an auxiliary, but predecessor and successor have different pitches. For instance, in case maxStep=2, predecessor and successor differ by a semitone.<BR>
 NB: Predecessor and successor of Note must be notes as well!<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity271">
<span class="keyword">proc</span>{<span class="functionname">ResolveNonharmonicNotesStepwise</span> Notes Args}<br>
<span class="string"> Melodic constraint for list of Notes: non-chord tones are only permitted if they are reached and left by a step. The first and last element of Notes is constrained to a chord tone.<BR>
<BR>
 Args:<BR>
 'maxInterval': an ratio spec for the maximum step-size permitted. Default is a septimal second (8#7). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity272">
<span class="keyword">proc</span>{<span class="functionname">ClearDissonanceResolution</span> VoiceNotes}<br>
<span class="string"> Variant of ResolveNonharmonicNotesStepwise which accesses the predecessor and sucessor note from a given note explicitly. Non-chord tones are only permitted for MyNote if they are reached and left by a step. If no predecessor or successor is accessible for MyNote, then it must be a chord tone. <BR>
<BR>
 Args:<BR>
 'maxInterval': an integer specifying the maximum step-size permitted. Default is the interval corresponding to a septimal second (8/7). <BR>
 'getPredecessor' and 'getSuccessor': unary function returning the predecessor/successor for the given note. Default are the methods getTemporalPredecessor/getTemporalSuccessor.<BR>
 NOTE: If motifs are wrapped in containers, then the first (last) motif note has no predecessor (successor) and consequently must be a chord tone. This default behaviour can be changed using different 'getPredecessor' and 'getSuccessor' settings.<BR>
 NOTE: the default 'getPredecessor' and 'getSuccessor' do allow for pauses between chord tones and non-harmonic tones. Classical music theory does this as well, but not completely unrestricted. Again, this can be changed by using different 'getPredecessor' and 'getSuccessor' settings.<BR>
 */<BR>
 proc {ResolveNonharmonicNotesStepwise2 MyNote Args}<BR>
    Defaults = unit(getPredecessor: fun {$ N}<BR>
 				      X = {N getTemporalPredecessor($)}<BR>
 				   in <BR>
 replace X by comment if pauses should not occur between predecessor/successor and MyNote<BR>
 				      X<BR>
 				      if X == nil orelse {X isPause($)} orelse ({N getOffsetTime} >: 0) == 1<BR>
 				      then nil<BR>
 				      else X<BR>
 				      end<BR>
 				   end<BR>
 		   getSuccessor: fun {$ N}<BR>
 				    X = {N getTemporalSuccessor($)}<BR>
 				 in<BR>
 replace X by comment if pauses should not occur between predecessor/successor and MyNote<BR>
 				    X<BR>
 				    if X == nil orelse {X isPause($)} orelse ({X getOffsetTime} >: 0) == 1<BR>
 				    then nil<BR>
 				    else X<BR>
 				    end<BR>
 				 end<BR>
<BR>
 		   maxInterval: SeptimalSecond<BR>
 		  )<BR>
    As = {Adjoin Defaults Args}<BR>
    /** %% B=1 <-> MyNote is entered and left by a step.<BR>
 */<BR>
    proc {Aux MyNote B}<BR>
       Pre = {As.getPredecessor MyNote}<BR>
       Succ = {As.getSuccessor MyNote}<BR>
    in<BR>
       B = {FD.int 0#1}		% needed?<BR>
       if Pre \= nil andthen Succ \= nil<BR>
       then<BR>
 	 B = {FD.conj {ConstrainMaxIntervalR Pre MyNote As.maxInterval}<BR>
 	      {ConstrainMaxIntervalR MyNote Succ As.maxInterval}}<BR>
       else B=0			% otherwise always a consonance<BR>
       end<BR>
    end<BR>
 in<BR>
    thread			% accessors block<BR>
       {MyNote nonChordPCConditions([Aux])}<BR>
    end<BR>
 end<BR>
<BR>
<BR>
<BR>
<BR>
/** %% [contrapuntual constraint] If in one voice there occurs a non-chord tone followed by a chord tone (a dissonance resolution), then no other voice should obscure this resolution by a non-chord tone starting together with the tone resolving the dissonance. However, simultaneous dissonances can start more early or later.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity273">
<span class="keyword">proc</span>{<span class="functionname">IntervalBetweenNonharmonicTonesIsConsonant</span> Notes ConsonantIntervals}<br>
<span class="string"> [contrapuntual constraint] Constraints that all pairs of simultaneous non-harmonic tones (i.e. the inChordB parameter = 0) form consonant intervals among each other. Notes is the list of all notes which potentially are non-harmonic tones (e.g., all notes in the score). ConsonantIntervals is a FD int domain specification (e.g., a list of integers) which specifies the allowed intervals.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity274">
<span class="keyword">proc</span>{<span class="functionname">MaxInterval</span> Notes MaxInterval}<br>
<span class="string"> Constraints that no pitch interval between consecutive Notes (list of note objects) exceeds MaxInterval (FD int).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity275">
<span class="keyword">proc</span>{<span class="functionname">MaxNonharmonicNoteSequence</span> Notes N}<br>
<span class="string"> Restrict the number of consecutive non-harmonic Notes (list of note objects) to N at maximum. Non-harmonic notes are notes for which the method getInChordB returns 0 (i.e. false).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity276">
<span class="keyword">proc</span>{<span class="functionname">MaxNonharmonicNotePercent</span> Notes MaxPercent}<br>
<span class="string"> Restrict the maximum percentage of non-harmonic Notes (list of note objects) to MaxPercent.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity277">
<span class="keyword">proc</span>{<span class="functionname">MaxRepetitions</span> Notes N}<br>
<span class="string"> N specifies how many pitch repetitions occur at maximum between consecutive Notes (list of note objects), i.e. how many pitch intervals are 0. If N=0 then no repetitions are permitted.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity278">
<span class="keyword">proc</span>{<span class="functionname">MinPercentSteps</span> Notes MinPercent Args}<br>
<span class="string"> Constrains the interval between Notes (list of note objects): there are at least MinPercent steps. The optional argument 'step' sets the step size as a frequency ratio (default 8#7).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity279">
<span class="keyword">proc</span>{<span class="functionname">GetInterval</span> Note1 Note2 Interval}<br>
<span class="string"> Returns the absolute pitch interval (a FD int) between the note objects Note1 and Note2. Interval is implicitly declared a FD int.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity280">
<span class="keyword">proc</span>{<span class="functionname">ConstrainMaxIntervalR</span> Note1 Note2 MaxInterval B}<br>
<span class="string"> B=1 <-> constraints the absolute pitch interval between Note1 and Note2 (note objects) to MaxInterval (an integer) at most.<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>