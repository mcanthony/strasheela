<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>DB</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="18" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">HarmonisedScore</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">DB</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">HS_Score</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node4.html">Rules</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node5.html">DBs</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node6.html">HS_Distro</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node7.html">HS_Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node8.html">HS</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node9.html">Schoenberg</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node10.html">Default</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node11.html">Jazz</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node12.html">Partch</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node13.html">Johnston</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node14.html">Harrison</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node15.html">Chalmers</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node16.html">Catler</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node17.html">ArithmeticalSeriesChords</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Functor defines data abstraction for a user-defined database of settings like chord and scale structures which are used by the contribution HarmonisedScore. See SetDB of further details. <BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>DB ("<span class="string">/Users/torsten/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/HarmonisedScore/source/Database.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li>FS</li><li>RecordC</li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>MUtils at "<span class="string">x-ozlib://anders/strasheela/source/MusicUtils.ozf"
</span></li><li>Out at "<span class="string">x-ozlib://anders/strasheela/source/Output.ozf"
</span></li><li>Pattern at "<span class="string">x-ozlib://anders/strasheela/Pattern/Pattern.ozf"
</span></li><li><a href="node8.html">HS</a> at "<span class="string">../HarmonisedScore.ozf"
</span></li><li><a href="node3.html">HS_Score</a> at "<span class="string">Score.ozf"
</span></li><li><a href="node5.html">DBs</a> at "<span class="string">databases/Databases.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;P/1:<a href="#entity43"><span class="functionname">SetDB</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity44"><span class="functionname">GetEditChordDB</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity45"><span class="functionname">GetInternalChordDB</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity46"><span class="functionname">GetEditScaleDB</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity47"><span class="functionname">GetInternalScaleDB</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity48"><span class="functionname">GetEditIntervalDB</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity49"><span class="functionname">GetInternalIntervalDB</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity50"><span class="functionname">GetPitchesPerOctave</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity52"><span class="functionname">GetPitchUnit</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity51"><span class="functionname">GetAccidentalOffset</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity53"><span class="functionname">GetOctaveDomain</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity54"><span class="functionname">GetGenerators</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity55"><span class="functionname">GetGeneratorFactors</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity56"><span class="functionname">GetGeneratorFactorsOffset</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity57"><span class="functionname">GetTemperament</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity58"><span class="functionname">MakePitchClassFDInt</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity59"><span class="functionname">MakeOctaveFDInt</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity60"><span class="functionname">MakeAccidentalFDInt</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity61"><span class="functionname">MakeScaleDegreeFDInt</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity62"><span class="functionname">MakeChordDegreeFDInt</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity63"><span class="functionname">MakeFullDB</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity64"><span class="functionname">RatiosInDBEntryToPCs</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity65"><span class="functionname">RatiosInDBEntryToPCs2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity66"><span class="functionname">WasRatiosDBEntry</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity70"><span class="functionname">Pc2Ratios</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity67"><span class="functionname">GetChordIndex</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity68"><span class="functionname">GetScaleIndex</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity69"><span class="functionname">GetIntervalIndex</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity71"><span class="functionname">GetComment</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity72"><span class="functionname">GetName</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity73"><span class="functionname">GetAllNames</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity74"><span class="functionname">GetUntransposedRatios</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity75"><span class="functionname">GetUntransposedRootRatio</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity76"><span class="functionname">GetUntransposedRootRatio_Float</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity77"><span class="functionname">MakeRegularTemperament</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity78"><span class="functionname">AllTemperamentIntervals</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity79"><span class="functionname">RatioToRegularTemperamentPC</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity43">
<span class="keyword">proc</span>{<span class="functionname">SetDB</span> NewDB}<br>
<span class="string"> Sets the database which is used by the HarmonisedScore contribution (e.g., its music representation and rules).<BR>
 The syntax of the database is<BR>
      &lt;DB&gt; ==:: unit([chordDB:&lt;PCGroupDB&gt;]<BR>
			   [scaleDB:&lt;PCGroupDB&gt;]<BR>
			   [intervalDB:&lt;IntervalDB&gt;]<BR>
			   [pitchesPerOctave:&lt;PitchesPerOctave&gt;]<BR>
			   [accidentalOffset:&lt;AccidentalOffset&gt;]<BR>
			   [octaveDomain:&lt;OctaveDomain&gt;]<BR>
			   [generators:&lt;Generators&gt;]<BR>
			   [generatorFactors:&lt;generatorFactors&gt;]<BR>
			   [generatorFactorsOffset:&lt;GeneratorFactorsOffset&gt;]<BR>
			   [temperament:&lt;Temperament&gt;])<BR>
      &lt;PCGroupDB&gt; ==:: unit(&lt;PCGroupEntry&gt;+)<BR>
      &lt;PCGroupEntry&gt; ==:: unit(pitchClasses:&lt;IntList&gt;<BR>
				     roots:&lt;IntList&gt;<BR>
				     [&lt;FeatureValuePair&gt;*]<BR>
				     [comment:&lt;Value&gt;])<BR>
      &lt;IntervalDB&gt; ==:: unit([&lt;FeatureValuePair&gt;+]<BR>
				   [comment:&lt;Value&gt;])<BR>
      &lt;PitchesPerOctave&gt; ==:: &lt;Int&gt;<BR>
      &lt;AccidentalOffset&gt; ==:: &lt;Int&gt;<BR>
      &lt;OctaveDomain&gt; ==:: &lt;Int&gt;#&lt;Int&gt;<BR>
      <BR>
 All features of the DB and also of some sub-DBs (e.g. of the chordDB and scaleDB) are optional (as marked by square brackets). Missing features are set to the features of the default database (HS.dbs.default). However, in case PitchesPerOctave \= 12, then the following features are mandatory: chordDB, scaleDB and intervalDB.<BR>
 Note the above doc is unfinished: for further details read the doc of the aux accessors (available in the source file contributions/anders/HarmonisedScore/source/Database.oz).<BR>
<BR>
 'comment' feature of database entries: is either a single value (usually an atom) or a record.<BR>
 Naming database entries: either by an atom given to the 'comment' feature of a database, or an atom given to the 'name' feature of the record at the 'comment' feature, or -- for multiple alternative names -- a list of atoms given to the 'name' feature of the record at the 'comment' feature.<BR>
<BR>
 The optional settings 'generators', 'generatorFactors', 'generatorFactorsOffset' and 'temperament' are for bookkeeping when using regular temperaments.<BR>
<BR>
 TODO: write a better doc..<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity44">
<span class="keyword">fun</span>{<span class="functionname">GetEditChordDB</span> }
</code><br>

<code>
<a name="entity45">
<span class="keyword">fun</span>{<span class="functionname">GetInternalChordDB</span> }
</code><br>

<code>
<a name="entity46">
<span class="keyword">fun</span>{<span class="functionname">GetEditScaleDB</span> }
</code><br>

<code>
<a name="entity47">
<span class="keyword">fun</span>{<span class="functionname">GetInternalScaleDB</span> }
</code><br>

<code>
<a name="entity48">
<span class="keyword">fun</span>{<span class="functionname">GetEditIntervalDB</span> }
</code><br>

<code>
<a name="entity49">
<span class="keyword">fun</span>{<span class="functionname">GetInternalIntervalDB</span> }
</code><br>

<code>
<a name="entity50">
<span class="keyword">fun</span>{<span class="functionname">GetPitchesPerOctave</span> }
</code><br>

<code>
<a name="entity52">
<span class="keyword">fun</span>{<span class="functionname">GetPitchUnit</span> }
</code><br>

<code>
<a name="entity51">
<span class="keyword">fun</span>{<span class="functionname">GetAccidentalOffset</span> }
</code><br>

<code>
<a name="entity53">
<span class="keyword">fun</span>{<span class="functionname">GetOctaveDomain</span> }
</code><br>

<code>
<a name="entity54">
<span class="keyword">fun</span>{<span class="functionname">GetGenerators</span> }
</code><br>

<code>
<a name="entity55">
<span class="keyword">fun</span>{<span class="functionname">GetGeneratorFactors</span> }
</code><br>

<code>
<a name="entity56">
<span class="keyword">fun</span>{<span class="functionname">GetGeneratorFactorsOffset</span> }
</code><br>

<code>
<a name="entity57">
<span class="keyword">fun</span>{<span class="functionname">GetTemperament</span> }
</code><br>

<code>
<a name="entity58">
<span class="keyword">fun</span>{<span class="functionname">MakePitchClassFDInt</span> }<br>
<span class="string"> Return a FD integer representing a pitch class (range defined by PitchesPerOctave).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity59">
<span class="keyword">fun</span>{<span class="functionname">MakeOctaveFDInt</span> }<br>
<span class="string"> Return a FD integer representing an octave (range OctaveDomain).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity60">
<span class="keyword">fun</span>{<span class="functionname">MakeAccidentalFDInt</span> }<br>
<span class="string"> Return a FD integer representing an accidental (range 0#AccidentalOffset*2). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity61">
<span class="keyword">fun</span>{<span class="functionname">MakeScaleDegreeFDInt</span> }<br>
<span class="string"> Returns a FD integer representing a scale degree (range 1#MaxScaleLength).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity62">
<span class="keyword">fun</span>{<span class="functionname">MakeChordDegreeFDInt</span> }<br>
<span class="string"> Returns a FD integer representing a chord degree (range 1#MaxChordLength).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity63">
<span class="keyword">fun</span>{<span class="functionname">MakeFullDB</span> Args}<br>
<span class="string"> Returns a full database specification that can be given as argument to HS.db.setDB.<BR>
<BR>
 Args:<BR>
<BR>
 'chords'/'scales'/'intervals' (each tuple of records, default of each is unit): chord/scale/interval database entries that are appended before the entries defined internally in this functor. There features pitchClasses, essentialPitchClasses and roots can be declared as integers (depends on pitchesPerOctave), ratios (pairs of ints) or symbolic note names (as supported by arg symbolToPc, see below) .<BR>
 <BR>
 'chordFeatures'/'scaleFeatures'/'intervalFeatures' (each list of atoms, default of each is nil): additional features required in database entries (example: essentialPitchClasses). Database entries that do not contain all the required features are removed from the output (reported at standard out).<BR>
<BR>
 'symbolToPc' (default HS.pc): function that expects an atom (a symbolic pitch name) and returns the corresponding pitch class. <BR>
<BR>
 'pitchesPerOctave' (default 12) <BR>
 'accidentalOffset' (default 2)<BR>
 'octaveDomain' (default 0#9)<BR>
 <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity64">
<span class="keyword">proc</span>{<span class="functionname">RatiosInDBEntryToPCs</span> MyDBEntry KeysPerOctave Result}<br>
<span class="string"> Processes an entry for a HS database (e.g. for a chord database). HS depends on pitches as keynumbers and pitch classes (all represented by integers or FD ints), both depending on KeysPerOctave. RatiosInDBEntryToPCs2, on the other hand, permits also ratios (floats or fractions specs) which are transformed and rounded to the nearest pitch class (a ratio representing an interval exceeding an octave is transformed into an interval within an octave). <BR>
 MyDBEntry is a record with arbitrary features. Each feature value is either an interger, a list of integers, a ratio spec (either a float or a fraction spec in the form &lt;Int&gt;#&lt;Int&gt;), or a list of ratio specs. The output contains each integer/lists of integers unchanged but substitutes each ratio/list of ratios by the nearest pitch class interval (an integer), depending on KeysPerOctave (an integer).<BR>
 Additionally, a comment feature in MyDBEntry with arbitrary value is permitted. The returned record has always a comment feature with a record as value. The explanation of the comment in the return value is a bit complicated and depends on MyDBEntry. For features in MyDBEntry with a ratio, collect in comment the ratio, its pitch class plus the ji_error (i.e. the difference between the JI ratio and the pitch class it is mapped to), for other features in Test keep the orig value. In case MyDBEntry contains a feature comment as well, this value is preserved: in case MyDBEntry.comment is a record as well, its features are added to the comment record of the result. However, in case MyDBEntry.comment contains a feature 'comment' with the same feature as a feature in MyDBEntry itself, then the feature of MyDBEntry.comment is preferred. See the test file for examples.<BR>
 Because the comment feature of the returned DB entry is changed, the function WasRatiosDBEntry recognises a DB entry processed by RatiosInDBEntryToPCs2.<BR>
<BR>
 NB: in HS.db, an OctaveDomain is also specified as &lt;Int&gt;#&lt;Int&gt;, but must not be mixed up with a fraction spec.<BR>
 <BR>
<BR>
 BUG: reported error signs not correct -- check JI signs (you know what to expect..)<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity65">
<span class="keyword">proc</span>{<span class="functionname">RatiosInDBEntryToPCs2</span> MyDBEntry KeysPerOctave Temperament Args Result}<br>
<span class="string"> RatiosInDBEntryToPCs2 is a generalised version of RatiosInDBEntryToPCs that additionally expects Temperament, a sorted tuple of integers expressing a regular temperament (as explected by RatioToRegularTemperamentPC). If Temperament is unit (i.e. an empty tuple), then it defaults to an equal temperament depending on KeysPerOctave (which is the behaviour of RatiosInDBEntryToPCs).<BR>
<BR>
 Args:<BR>
 'minOccurrences': the minimum number an interval needs to occur in order to be taken into account. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity66">
<span class="keyword">fun</span>{<span class="functionname">WasRatiosDBEntry</span> MyDBEntry}<br>
<span class="string"> Returns true if MyDBEntry was processed by RatiosInDBEntryToPCs2.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity70">
<span class="keyword">fun</span>{<span class="functionname">Pc2Ratios</span> PC IntervalDB}<br>
<span class="string"> Returns a list of all ratios which match PC (an int) in IntervalDB (given in its edit form) which was defined using ratios (e.g. {HS.dbs.partch.getIntervals {HS.db.getPitchesPerOctave}}).<BR>
 A ratio consists in two integers and has the form Nom#Denom. If no entry in the database matches PC or non matching is defined as ratio, then nil is returned.<BR>
<BR>
 Two examples:<BR>
   {Pc2Ratios 9 {HS.dbs.partch.getIntervals 12}}<BR>
   {Pc2Ratios 53 {HS.dbs.partch.getIntervals 72}}<BR>
<BR>
 NB: Pc2Ratios is a deterministic function and no constraint.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity67">
<span class="keyword">fun</span>{<span class="functionname">GetChordIndex</span> MyName}<br>
<span class="string"> Convenience functions. ChordIndex expects a name (atom) for a chord and returns the corresponding index. This name is either the value stored under the edit database feature 'comment', or the value of a feature 'name' of a record stored under the edit database feature 'comment'. If no database entry with this name is defined, then nil is returned.<BR>
 ScaleIndex and IntervalIndex do the same for scales and intervals.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity68">
<span class="keyword">fun</span>{<span class="functionname">GetScaleIndex</span> MyName}
</code><br>

<code>
<a name="entity69">
<span class="keyword">fun</span>{<span class="functionname">GetIntervalIndex</span> MyName}
</code><br>

<code>
<a name="entity71">
<span class="keyword">fun</span>{<span class="functionname">GetComment</span> X}<br>
<span class="string"> Expects a chord, scale or interval object and returns the comment value in its internal database format.<BR>
 Blocks until the index parameter is determined.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity72">
<span class="keyword">fun</span>{<span class="functionname">GetName</span> X}<br>
<span class="string"> Returns the name of a chord, scale or interval specified in its database entry (a VS, usually an atom). The name is a list of atoms (its a list because there are sometimes multiple name alternatives). Returns nil if no name was found.<BR>
 Blocks until the index parameter is determined.<BR>
<BR>
 The name is often specified as an atom at the 'comment' feature of a database entry. Alternatively, the entry defines a record at the 'comment' feature, and then the name is and atom at the feature 'name' in this subrecord, or a list of atoms at the feature 'name' (for specifying multiple alternative names).  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity73">
<span class="keyword">fun</span>{<span class="functionname">GetAllNames</span> DB}<br>
<span class="string"> Returns a list of list of all the names (usually atoms) of the entries in the database DB (a database in the format of edit DBs, e.g., {HS.db.getEditScaleDB}). A list of lists is returned because some database entries have multiple names. Note that some entries have no names at all.<BR>
<BR>
 Example: how to return a list of all scale names of the named scales in the current database (only their first name).<BR>
   {LUtils.mappend {HS.db.getAllNames {HS.db.getEditScaleDB}}<BR>
    fun {$ Ns}<BR>
       case Ns of nil then nil<BR>
       else [Ns.1]<BR>
       end<BR>
    end}<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity74">
<span class="keyword">fun</span>{<span class="functionname">GetUntransposedRatios</span> X}<br>
<span class="string"> Returns the ratios specs by which X (chord or scale object) is declared in the database. If X was declared by pitch classes instead and thus no ratios are available then nil is returned.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity75">
<span class="keyword">fun</span>{<span class="functionname">GetUntransposedRootRatio</span> X}<br>
<span class="string"> Returns the ratio specs by which the roots of X (chord or scale object) are declared in the database. If the root was declared by a pitch class instead and thus no ratio is available then nil is returned.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity76">
<span class="keyword">fun</span>{<span class="functionname">GetUntransposedRootRatio_Float</span> X}<br>
<span class="string">  Returns the frequency ratio of the [first] root of X (chord or scale object) as a float. For example, if the ratio 1#1 or the pitch class 0 is declared as root, then 1.0 is returned; it it is 3#2 then 1.5 is returned.<BR>
<BR>
 NB: blocks until root and transposition of X are determined. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity77">
<span class="keyword">fun</span>{<span class="functionname">MakeRegularTemperament</span> Generators GeneratorFactors Args}<br>
<span class="string"> Returns sorted list of pitch classes (ints) that constitute a regular temperament, i.e. a temperament whose pitches are generated by a repeated transposition with the same interval(s) (http://en.wikipedia.org/wiki/Regular_temperament). Generators (list of integers) is the list of transposition intervals, the unit of measurement depends on the Arg pitchesPerOctave (e.g., if pitchesPerOctave is 1200, then the Generators and all temperament pitches are measured in cent). GeneratorFactors is a specification that denotes the generator transpositions. For each element in Generator, GeneratorFactors contains a pair of integers MinTranposition#MaxTransposition. For example, the generator factor ~1#2 indicates that the corresponding generator is transposed 1 time downwards and 2 times upwards (i.e. together with the start pitch 4 pitches are generated).<BR>
 The octave interval is always implicitly added as generator to a regular temperament: the result of MakeRegularTemperament is a list of pitch classes (i.e. generated pitches that "fell outside" the octave are automatically "folded back" into the octave). <BR>
<BR>
 Args:<BR>
 'pitchesPerOctave' (default {HS.db.getPitchesPerOctave}): denotes the unit of measurement for Generators and the resulting pitch classes of the temperament.<BR>
 'generatorFactorsOffset' (default 0): this argument is intended to avoid negative generator factors, in case generator factors are variables (e.g., if using the class HS.score.regularTemperamentMixinForNote). For example, if generatorFactorsOffset is 100, then the generator factors spec 99#102 indicates that the corresponding generator is transposed 1 time downwards and 2 times upwards.<BR>
 'transposition' (default 0): pitch class interval for transposing the whole temperament. With the default value 0, the temperament's "origin" is the pitch class 0 (always C).<BR>
<BR>
 See examples/RegularTemperaments.oz for usage examples.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity78">
<span class="keyword">fun</span>{<span class="functionname">AllTemperamentIntervals</span> Temperament Args}<br>
<span class="string"> Expects a regular temperament spec Temperament (tuple of ints) and returns a tuple that contains all intervals contained in this temperament (remember that Temperament contains all intervals available from PC 0, but in addition some intervals may only be available between other pitches).<BR>
<BR>
 Args: <BR>
 'minOccurrences' (default 1): the minimum number an interval needs to occur in order to be included. <BR>
 'pitchesPerOctave' (default {HS.db.getPitchesPerOctave}): the pitches per octave (i.e., pitch unit).<BR>
 'reportOccurrences' (default false): if true, AllTemperamentIntervals returns a completely different format that also reports the number of occurances of each interval in the temperament. AllTemperamentIntervals returns a record where the features are the intervals and the values are the number of occurrences.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity79">
<span class="keyword">fun</span>{<span class="functionname">RatioToRegularTemperamentPC</span> Ratio Args}<br>
<span class="string"> Expects a Ratio (float or pair of ints) and returns the corresponding tempered pitch class (an int), i.e. the pitch class that approximates the ratio closest in the temperament. Ratio is either pair of integers Nominator#Denomitator or a float that corresponds to the value of the ratio.<BR>
<BR>
 Args:<BR>
 'temperament' (default {HS.db.getTemperament}): a tuplet of pitch classes (ints), sorted in ascending order, which constitute the temperament.<BR>
 'pitchesPerOctave' (default {HS.db.getPitchesPerOctave}): denotes the unit of measurement for the pitch classes of the temperament.<BR>
 'showError' (Boolean, default false): if true, RatioToRegularTemperamentPC returns tuple PC#Error, where Error is the difference between the JI interval and the returned tempered interval (unit of measurement depends on Arg pitchesPerOctave).<BR>
 'minOccurrences': the minimum number an interval needs to occur in order to be taken into account. <BR>
<BR>
 See examples/RegularTemperaments.oz for usage examples.<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>