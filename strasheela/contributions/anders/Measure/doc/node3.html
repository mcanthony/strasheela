<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Measure</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="4" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Measure</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node2.html">Out</a>
</td></tr><tr><td bgcolor="#009cff" width="144"><a href="node3.html">Measure</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"></span>
</span>
<h3>Functor</h3>
<ul>Measure ("<span class="string">/Users/torsten/oz/music/Strasheela/strasheela/trunk/strasheela/contributions/anders/Measure/Measure.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li>FS</li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>Score at "<span class="string">x-ozlib://anders/strasheela/source/ScoreCore.ozf"
</span></li><li>Pattern at "<span class="string">x-ozlib://anders/strasheela/Pattern/Pattern.ozf"
</span></li><li>HS at "<span class="string">x-ozlib://anders/strasheela/HarmonisedScore/HarmonisedScore.ozf"
</span></li><li><a href="node2.html">Out</a> at "<span class="string">source/Output.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li><span class="variablename">Out</span>
</li><li>&lt;C:<a href="#entity128"><span class="type">Measure</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity129"><span class="functionname">IsMeasure</span></a>&gt;
</li><li>&lt;C:<a href="#entity131"><span class="type">UniformMeasures</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity132"><span class="functionname">IsUniformMeasures</span></a>&gt;
</li><li>&lt;C:<a href="#entity133"><span class="type">AccentRatingMixin</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity134"><span class="functionname">IsAccentRatingMixin</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity135"><span class="functionname">MakeAccentRatingClass</span></a>&gt;
</li><li><span class="variablename">Note</span>
</li><li>&lt;P/3:<a href="#entity136"><span class="functionname">Accent_If</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity137"><span class="functionname">Accent_If2</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity138"><span class="functionname">SetAccentRating</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity139"><span class="functionname">NoteAtMetricPosition</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity140"><span class="functionname">Make_HasAtLeastDuration</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity141"><span class="functionname">IsFirstItem</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity142"><span class="functionname">IsLongerThanDirectNeighbours</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity143"><span class="functionname">IsLongerThanPredecessor</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity144"><span class="functionname">IsLongerThanPredecessorSimple</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity145"><span class="functionname">IsLongerThanPredecessor_Rated</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity146"><span class="functionname">IsLongerThanSurrounding_Rated</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity147"><span class="functionname">IsFirstOfEqualNoteValues</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity148"><span class="functionname">IsHigherThanDirectNeighbours</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity149"><span class="functionname">IsHigherThanPredecessor</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity150"><span class="functionname">IsSkip</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity151"><span class="functionname">IsHigherThanPredecessor_Rated</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity152"><span class="functionname">IsHigherThanSurrounding_Rated</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity153"><span class="functionname">HasTextureAccent</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity154"><span class="functionname">WeightConstraint</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity155"><span class="functionname">Make_HasAnacrusis</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity156"><span class="functionname">Anacrusis_AccentLonger</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity157"><span class="functionname">Anacrusis_DirectionChange</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity158"><span class="functionname">Anacrusis_LocalMax</span></a>&gt;
</li><li><span class="variablename">Anacrusis_ShorterThanAccent</span>
</li><li><span class="variablename">Anacrusis_FirstNShorterThanAccent</span>
</li><li><span class="variablename">Anacrusis_NoLongerThanAccent</span>
</li><li><span class="variablename">Anacrusis_FirstNNoLongerThanAccent</span>
</li><li><span class="variablename">Anacrusis_PossibilyShorterTowardsAccent</span>
</li><li><span class="variablename">Anacrusis_FirstNPossibilyShorterTowardsAccent</span>
</li><li><span class="variablename">Anacrusis_EvenDurations</span>
</li><li><span class="variablename">Anacrusis_FirstNEvenDurations</span>
</li><li><span class="variablename">Anacrusis_UpwardPitchIntervals</span>
</li><li><span class="variablename">Anacrusis_FirstNUpwardPitchIntervals</span>
</li><li><span class="variablename">Anacrusis_SameDirectionPitchIntervals</span>
</li><li><span class="variablename">Anacrusis_FirstNSameDirectionPitchIntervals</span>
</li></ul></code>
<h3>Define</h3>

<a name="entity128">
<p class="margin"><div align="right"><a href="class4.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Measure is a silent timed element representing the meter of a score for the duration of the Measure. Measures are contained in a silent MeasureSeq/UniformMeasures and a MeasureSeq/UniformMeasures runs in parallel to the actual (i.e. sounding) score. That way, the metric structure is freely constrainable independent of other parameters and the hierarchic structure of the rest of the score. <BR>
 The Measure parameters 'beatNumber' and 'beatDuration' represent the meter of the measure. For instance, in case the time unit of the score is beats(4) and thus 4 represents a quarter note (see doc Score.timeMixin) then the meter 3/8 is represented by beatNumber=3 and beatDuration=2. Usually, beatDuration will equal the number of ticks per beat defined in the time unit of the score (exceptions are needed in case the score contains measures with different beat durations).<BR>
 The attribute 'beats' (a list of FD ints) represents the relative startTimes of the beats in the measure (i.e., the start times counting from the beginning of the measure). For instance, in case beatNumber=3 and beatDuration=2 then beats=[0 2 4].<BR>
 The attribute 'accents' (a list of FD ints) represents the relative startTimes of the strong beats in the measure. The strong beats depend on the beatNumber of the measure. The accent patterns in common praxis music are highly standardised (e.g. the meter 4/4 has strong beats on the first and the third beat). Nonetheless, Measure allows to freely define these accent patterns for each possible beatNumber value for each Measure at the optional init method argument 'accentIdxDB'. This argument expects a record (with only integer features) of lists of integers to specify an accent pattern for each beatNumber. For instance, the specification of the common praxis tripel and quadruple meter is unit(3:[1] 4:[1 3]).<BR>
 The default of 'accentIdxDB' defines the usual common praxis accent patterns for single (1/2, 1/4, 1/8), duple (2/2, 2/4, 2/8), triple (3/2, 3/4, 3/8), and quadruple (4/2, 4/4, 4/8) meter, as well as compound duple (6/2, 6/4, 6/8), compound triple (9/4, 9/8), and compound quadruple (12/4, 12/8, 12/16) meter. The compound meters may also be used to express 'prolatione perfecta' for old music, while the non-coumpound meters express 'prolatione imperfecta'. For the quintuple meter (5/4 etc.), the accent pattern 3/4 + 2/4 is the default. <BR>
  NB: the initialisation constraints for both beats and accents are delayed until beatNumber is determined (i.e. in a CSP the beatNumber of each beat is either predetermined or the distribution strategy should determine all beatNumbers before other parameter values which are related to the measure by constraints).<BR>
<BR>
 Note that the class UniformMeasures is more comprehensive than this class.<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">Measure</span>&nbsp;<span class="keyword">from</span>&nbsp;<span class="reference">Score.temporalElement</span>
<br>&nbsp;&nbsp;&nbsp;<span class="keyword">feat</span>&nbsp;!MeasureType&nbsp;label

<ul><li><span class="functionname">init</span>(accentIdxDB:AIs beatDuration:BeatDuration beatNumber:BeatNr&nbsp;...)<br>
</li><li><span class="functionname">getBeatNumber</span>(X)<br>
</li><li><span class="functionname">getBeatNumberParameter</span>(X)<br>
</li><li><span class="functionname">getBeatDuration</span>(X)<br>
</li><li><span class="functionname">getBeatDurationParameter</span>(X)<br>
</li><li><span class="functionname">getBeats</span>(X)<br>
</li><li><span class="functionname">getBeatsFS</span>(X)<br>
</li><li><span class="functionname">getAccents</span>(X)<br>
</li><li><span class="functionname">getAccentsFS</span>(X)<br>
</li><li><span class="functionname">getInitInfo</span>($&nbsp;...)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>

<code>
<a name="entity129">
<span class="keyword">fun</span>{<span class="functionname">IsMeasure</span> X}
</code><br>

<a name="entity131">
<p class="margin"><div align="right"><a href="class5.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> UniformMeasures is a silent timed element representing a constant meter of a score for the duration of the UniformMeasures. The parameter 'n' represents the number of measures. The parameter 'beatNumber' and 'beatDuration' represent the meter as in Measure. The further measure parameters and features (e.g. 'beats' and 'accents') are accessible by the same methods as in Measure. However, there is a difference between getDuration and getMeasureDuration: the first returns the duration of the whole UniformMeasures while the second the duration of a single measure.<BR>
 The similar class MeasureSeq allows to represent a sequence of measures which differ in beatNumber or beatDuration. However, this makes the constraints for MeasureSeq less efficient then the constraints for UniformMeasures.<BR>
<BR>
 NB: The constraints defined for UniformMeasures required both BeatNr and BeatDuration to be determined.<BR>
<BR>
 See the Measures doc for more info.<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">UniformMeasures</span>&nbsp;<span class="keyword">from</span>&nbsp;<span class="reference">Score.temporalElement</span>
<br>&nbsp;&nbsp;&nbsp;<span class="keyword">feat</span>&nbsp;!UniformMeasuresType&nbsp;label

<ul><li><span class="functionname">init</span>(beatDuration:BeatDuration beatNumber:BeatNr n:N&nbsp;...)<br>
</li><li><span class="functionname">getN</span>(X)<br>
</li><li><span class="functionname">getNParameter</span>(X)<br>
</li><li><span class="functionname">getBeatNumber</span>(X)<br>
</li><li><span class="functionname">getBeatNumberParameter</span>(X)<br>
</li><li><span class="functionname">getBeatDuration</span>(X)<br>
</li><li><span class="functionname">getBeatDurationParameter</span>(X)<br>
</li><li><span class="functionname">getBeats</span>(X)<br>
</li><li><span class="functionname">getBeatsFS</span>(X)<br>
</li><li><span class="functionname">getAccents</span>(X)<br>
</li><li><span class="functionname">getAccentsFS</span>(X)<br>
</li><li><span class="functionname">getMeasureDuration</span>(X)<br>
</li><li><span class="functionname">getMeasureDurationParameter</span>(X)<br>
</li><li><span class="functionname">getMeasureAt</span>(I Time)<br>
</li><li><span class="functionname">getAccentInMeasureAt</span>(I Time)<br>
</li><li><span class="functionname">getBeatAt</span>(I Time)<br>
</li><li><span class="functionname">getBeatInMeasureAt</span>(I Time)<br>
</li><li><span class="functionname">onMeasureStartR</span>(B Time)<br>
</li><li><span class="functionname">onMeasureStartDR</span>(B Time)<br>
</li><li><span class="functionname">onAccentR</span>(B Time)<br>
</li><li><span class="functionname">onBeatR</span>(B Time)<br>
</li><li><span class="functionname">onBeatDR</span>(B Time)<br>
</li><li><span class="functionname">overlapsBarlineR</span>(B Start End)<br>
</li><li><span class="functionname">measureSyncopationR</span>(B Start End)<br>
</li><li><span class="functionname">accentSyncopationR</span>(B Start End)<br>
</li><li><span class="functionname">beatSyncopationR</span>(B Start End)<br>
</li><li><span class="functionname">getInitInfo</span>($&nbsp;...)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>

<code>
<a name="entity132">
<span class="keyword">fun</span>{<span class="functionname">IsUniformMeasures</span> X}
</code><br>

<a name="entity133">
<p class="margin"><div align="right"><a href="class6.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> AccentRatingMixin extends note classes with an accent rating parameter. No further constraints are applied.<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">AccentRatingMixin</span>
<br>&nbsp;&nbsp;&nbsp;<span class="keyword">feat</span>&nbsp;!AccentRatingType

<ul><li><span class="functionname">initAccentRatingMixin</span>(accentRating:AR)<br>
</li><li><span class="functionname">getAccentRating</span>(X)<br>
</li><li><span class="functionname">getAccentRatingParameter</span>(X)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>

<code>
<a name="entity134">
<span class="keyword">fun</span>{<span class="functionname">IsAccentRatingMixin</span> X}
</code><br>

<code>
<a name="entity135">
<span class="keyword">fun</span>{<span class="functionname">MakeAccentRatingClass</span> SuperClass}<br>
<span class="string"> [concrete class constructor] Expects a note class, and a class that is extended  with an accent rating parameter (see AccentRatingMixin).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity136">
<span class="keyword">proc</span>{<span class="functionname">Accent_If</span> N AccentConstraints Args}<br>
<span class="string"> Imposes constraint on self which associates certain BeatNr values to their typical Accent pattern in common praxis. This constraint is applied to self if the init arg isClassic equals true, which is the default.<BR>
 For non-classical measure types (e.g. 9/8 as 2/8 + 2/8+ 2/8 + 3/8) don't use this constraint (i.e. init arg isClassic=false) and apply alternative constraints.<BR>
 Accents are 0 based, i.e. an accent at 0 is an accent at the measure start.<BR>
 */<BR>
       meth classicAccents<BR>
 !!?? could selection constraints help here to have better propagation (e.g. defining a database of beatNumber and accent patterns and deciding for an index)<BR>
<BR>
 	 BeatNr = {self getBeatNumber($)}<BR>
 	 Accents = {self GetAccents($)}<BR>
       in<BR>
 	 {Pattern.disjAll<BR>
 	  [{FD.conj <BR>
 	    (BeatNr=:4) % quadruple (4/2, 4/4, 4/8)<BR>
 	    {FS.reified.equal Accents {FS.value.make [0 2]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:3) % triple (3/2, 3/4, 3/8)<BR>
 	    {FS.reified.equal Accents {FS.value.make [0]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:2) % duple (2/2, 2/4, 2/8)<BR>
 	    {FS.reified.equal Accents {FS.value.make [0]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:1) % single (1/2, 1/4, 1/8)<BR>
 	    {FS.reified.equal Accents {FS.value.make [0]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:6) % compound duple (6/2, 6/4, 6/8)<BR>
 	    {FS.reified.equal Accents {FS.value.make [0 3]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:9) % compound triple (9/4, 9/8)<BR>
 	    {FS.reified.equal Accents {FS.value.make [0 3 6]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:12) % compound quadruple (12/4, 12/8, 12/16)<BR>
 	    {FS.reified.equal Accents {FS.value.make [0 3 6 9]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:5) % quintuple 2/4 + 3/4<BR>
 	    {FS.reified.equal Accents {FS.value.make [0 2]}}}<BR>
 	   {FD.conj <BR>
 	    (BeatNr=:5) % quintuple 3/4 + 2/4<BR>
 	    {FS.reified.equal Accents {FS.value.make [0 3]}}}<BR>
<BR>
 further meters may be defined here (adjust else case):<BR>
<BR>
 else case<BR>
 	   {FD.conj <BR>
 	    {FD.disj<BR>
 	     {FS.reified.include BendBeatNr {FS.value.make [7 8 10 11]}}<BR>
 	     (BendBeatNr>:12)}<BR>
 	    {FS.reified.equal Accents {FS.value.make [0]}}}]<BR>
 	  1}<BR>
       end<BR>
<BR>
<BR>
<BR>
<BR>
 Nachdenken:<BR>
<BR>
 attr beatNumber und beatDuration definieren measure vollstaendig (2 entscheidungen noetig)<BR>
<BR>
 implizit:<BR>
<BR>
 * beats (list, tuple of FD or FS): relative startZeiten der beats in measure<BR>
   Formalism: arithmetic series: number beatNumber, starts with 0, difference beatDuration<BR>
<BR>
 * accents (list, tuple of FD or FS): either relative startZeiten der akzentuierten/betonten beats oder indices der akzentuierten beats.<BR>
   Formalism: indices are selected dependent on beatNumber. the relative startTimes are then the beats at these indices<BR>
<BR>
<BR>
 Problemchen: wenn ich beats und accents entsprechend modelliere und per default constraine, dann gibt es keine billigere Variante mit weniger Propagatoren mehr.. -- verwende extra alternative Klasse UniformMeasureSeq instead of MeasureSeq.<BR>
<BR>
<BR>
 Benoetigte Constraints:<BR>
<BR>
 * propagiere beatNumber zu beats length/card (and indirectly to accents)<BR>
<BR>
   -> erledigt, wenn beatNumber erst determiniert sein muss<BR>
<BR>
   - FS: FS.card<BR>
<BR>
   - tuple: RecordC.width (what effect has this propagator?)<BR>
<BR>
   - list/stream ??<BR>
<BR>
 * numerische constraints (arithmetic series),<BR>
<BR>
   - FS ?? (FS.forAllIn needs determined set)<BR>
<BR>
   - OK: list/stream: Pattern constraint <BR>
<BR>
   - OK: tuple ?? (Record.forAll blocks for undetermined RecordC. However, when I somehow add features to RecordC I know these (and may also monitor them))<BR>
<BR>
 * propagiere beatNumber zu decision for accent indices into beats<BR>
<BR>
   Simplification: no constraint and no special case for different 5 meters: optional arg is tuple with accentPatterns (features represent beatNumber) and once beatNumber is determined the appropriate accentPattern is taken out of the tuple -- keep old constraint solution in a comment as an alternative more general proposal<BR>
<BR>
<BR>
<BR>
   -> erledigt, wenn beatNumber erst determiniert sein muss<BR>
<BR>
   - FS:<BR>
<BR>
      + large reified disj using FS.reified.equal and others<BR>
<BR>
      + Select from database with entries like unit(beatNumber accents)<BR>
<BR>
   - Tuple/List ?? (option as soon as beatNumber is determined: or combinator, also selection constraints)<BR>
   <BR>
<BR>
 * access accents in beats dependent on indices into beats,<BR>
<BR>
   - FS: ?? (how to access the ith element in a FS as a FD int -- there is no order in a set!: selection constraints?)<BR>
<BR>
   - OK? tuple/list: selection constraint (?? needs length of both beats and accents determined?)<BR>
<BR>
 * actual score item constraint: reified include/select some time in beats/accents (in onAccentR/onBeatR)<BR>
<BR>
   - OK: local (memorised ?) FS (matched to data): FS: FS.reified.include<BR>
 <BR>
   - tuple/list: ?? (crude reified Select?)<BR>
<BR>
<BR>
 -> Ergo: FS keine option: mir fehlt Reihenfolge (access at index in Set) und ich kann numerische constraints nicht recht anwenden<BR>
<BR>
 -> list / tuple sind moegl. aber blockieren bis beatsNr determiniert ist. Auch hier Problem: wie <BR>
<BR>
 -> sobald beatsNr determiniert ist kann ich representationen FS und list/tuple matchen (FS.int.match, braucht determinierten vector von FD ints) und so constraints aus beiden Welten haben (zusaetzl. vars, speicherhungrig..) <BR>
<BR>
 FS toot Chap. 4 kombiniert FS and RecordC, aber da ist width und aritity of RecordC bekannt und RecordC erlaubt nur ein etwas kuerzeres script.<BR>
<BR>
 -> !!!! Entscheidung: beatsNr muss moeglichst frueh determiniert werden: application of constraints wird bis dahin delayed (dies keinerlei Beschraenkung fuer alte Musik bis 1900, da hier Takt ueblicherweise ohnehin am Anfang des Kompositionsprozesses festgelegt wird)<BR>
<BR>
 Vague idea: I may use BeatNr as index for two selection constraints to select (a) the accents (FS) and (b) the beats (FS). Warscheinlich SchnapsIdee: beats abhaengig von sowohl beatNumber als auch beatDuration (kann nicht einfach selectiert werden) und die numerischen Constraints kann ich mit FS immer noch nicht ausdruecken<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
 Accent constraints<BR>
<BR>
<BR>
<BR>
<BR>
 Constraint applicators: Accent_If etc.<BR>
<BR>
<BR>
<BR>
/** %% With Accent_If various musical aspects and parameters can be constrained so that the resulting music expresses the underlying metric structure (simultaneous measure objects). This constraint applicator is inspired by the chapter on rhythm in Berry, Wallace. 1987. Structural Functions in Music. Courier Dover Publications. <BR>
 The start time of N coincides with the given "position" in a simultaneous measure (e.g., the measure's start or any accentuated beat), if given a list of given conditions is fulfilled well enough. These conditions (AccentConstraints) are a list of unary functions: the input is N and the return value is a rating of N (an FD int), where 0 means condition not fulfilled and higher values mean that the condition is increasingly better fulfilled. The sum of the return values of all conditions must be equal or exceed a given threshold (arg minRating) in order to trigger that the start time of N is constrained to a certain metric position. Predefined accent constraints include IsLongerThanSurrounding and IsHigherThanSurrounding (see their documentation for further details).<BR>
<BR>
 Args:<BR>
<BR>
 metricPosition (FD int or atom, default 'accent'): if N sufficiently meets the conditions, then its start time is constrained to this "position" in the measure. The following values are supported.<BR>
   measureStart: N starts with a measure<BR>
   accent: N starts with a strong beat (depends on the measure definition)<BR>
   beat: N starts with a beat<BR>
   an FD int: N starts at a specified time within a measure (e.g., if 0 then N starts on measure start, if 1 it starts on measure start + 1 etc.). Should not be larger than the measure duration.<BR>
<BR>
 minRating (FD int, default 1): Minimum accumulated rating of accent constraint outputs. If the sum of the return values of all accent constraints are equal or exceed a minRating, then in order the start time of N is constrained to the metric position metricPosition.<BR>
<BR>
 strictness (atom, default 'note'): Must the constrained be fulfilled for all notes meeting the criteria or for all given metric positions? There are three different cases.<BR>
   note: if note/item meets the accent criteria it must be on a specified metric position, but even if this constraint is applied to all notes there can be accentuated metric positions without notes meeting such criteria<BR>
   position: if note/item is at a specified metric position then it must meet the accent criteria, but even if this constraint is applied to all notes there can be accentuated notes at other positions. <BR>
   noteAndPosition: if note/item meets the accent criteria it is on a specified metric position and vice versa<BR>
 NOTE: none of the possible values for strictness enforces that there actually starts a note at any metric position specified in metricPosition. Use the constraint NoteAtMetricPosition for this purpose.<BR>
<BR>
 toplevel (default false): The container in which N is contained that should be considered the top level for finding the simultaneous measure object (if false, then the whole score is searched). This argument is for optimisation purposes only.<BR>
<BR>
 measureTest (default IsUniformMeasures): A Boolean function that returns true for the relevant measure objects. (currently only works with uniform measures?)<BR>
<BR>
 rating (an FD int): this argument is bound to the accumulated rating of accent constraint outputs for N. This variable can that way be constrained outside the call of Accent_If (e.g., to constrain the accent structure of some musical section, the number of occurances of some minumum rating or the minimum sum of ratings over multiple notes can be constrained).<BR>
<BR>
 Note: if N inherited from IsAccentRatingMixin then the rating is automatically added to its parameter accentRating. Therefore, Accent_If (or SetAccentRating) should only be called once for such a note.<BR>
 It is often good practice to combine all accent constraints into a single rating anyway. Exceptions would be special cases where, e.g., accents expressed by duration-relations and accents expressed by pitch-relations should fall on different metric positions. In such cases it is sufficient to avoid using notes that inherited from IsAccentRatingMixin.<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity137">
<span class="keyword">proc</span>{<span class="functionname">Accent_If2</span> N Args}<br>
<span class="string"> Same as Accent_If, but no accent constraints are applied (use SetAccentRating for this). This can be useful, e.g., to combine multiple calls of Accent_If2, say, with different values for Args.metricPosition and Args.minRating.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity138">
<span class="keyword">proc</span>{<span class="functionname">SetAccentRating</span> N AccentConstraints Args}<br>
<span class="string"> SetAccentRating sets an accumulated accent rating for the note N. AccentConstraints are a list of unary functions: the input is N and the return value is an accent rating of N (an FD int), where 0 means no accent and higher values mean a stronger accent. SetAccentRating sets the accent rating of N to the sum of all AccentConstraint results. Predefined accent constraints include IsLongerThanSurrounding and IsHigherThanSurrounding (see their documentation for further details).<BR>
<BR>
 Args:<BR>
<BR>
 'rating' (an FD int default {FD.decl}): this argument is bound to the accumulated rating of accent constraint outputs for N. This variable can that way be constrained outside the call of SetAccentRating (e.g., shared with Accent_If, or constrain the accent structure of some musical section, the number of occurances of some minumum rating or the minimum sum of ratings over multiple notes can be constrained).<BR>
<BR>
 If N inherited from IsAccentRatingMixin then the rating is automatically added to its parameter accentRating. Therefore, SetAccentRating (or Accent_If) should only be called once for such a note.<BR>
 It is often good practice to combine all accent constraints into a single rating anyway. Exceptions would be special cases where, e.g., accents expressed by duration-relations and accents expressed by pitch-relations should fall on different metric positions. In such cases it is sufficient to avoid using notes that inherited from IsAccentRatingMixin.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity139">
<span class="keyword">proc</span>{<span class="functionname">NoteAtMetricPosition</span> MyMeasure Notes Args}<br>
<span class="string"> TODO: doc<BR>
 Measure (a UniformMeasures instance) <BR>
 Args:<BR>
 metricPosition (FD int or atom, default 'accent'):<BR>
   measureStart: one or more element of Notes starts with Measure<BR>
   accent: one or more element of Notes starts with any accent of Measure<BR>
   beat: one or more element of Notes starts with any beat<BR>
   an FD int: one or more element of Notes starts at a specified time within a measure (e.g., if 0 then N starts on measure start, if 1 it starts on measure start + 1 etc.). Should not be larger than the measure duration.<BR>
<BR>
 allowRestsAtMetricPosition (Boolean, default false): if true, then instead a note start there can be a rest at the metric positions in question introduced by a note's offset time > 0. <BR>
<BR>
 ?? Note: constraint application delayed until Measure is fully determined.<BR>
<BR>
 BUG: unfinished definition. Only defined for case metricPosition:measureStart so far<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity140">
<span class="keyword">fun</span>{<span class="functionname">Make_HasAtLeastDuration</span> Dur}<br>
<span class="string"> Returns an accent constraint (a function execting a note/item and returning a rating FD int). This resulting function returns 1 for notes with a duration of Dur or longer, and 0 otherwise.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity141">
<span class="keyword">fun</span>{<span class="functionname">IsFirstItem</span> N}<br>
<span class="string"> B=1 <=> Note N is the first item in its container.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity142">
<span class="keyword">fun</span>{<span class="functionname">IsLongerThanDirectNeighbours</span> N}<br>
<span class="string"> B=1 <=> Note N is longer than both its preceeding and its succeeding note (duration + offsetTime used for calculating the perceived duration). If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity143">
<span class="keyword">fun</span>{<span class="functionname">IsLongerThanPredecessor</span> N}<br>
<span class="string"> B=1 <=> Note N is longer than the preceeding note and not shorter than succeeding note (duration + offsetTime used for calculating the perceived duration). If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity144">
<span class="keyword">fun</span>{<span class="functionname">IsLongerThanPredecessorSimple</span> N}<br>
<span class="string"> B=1 <=> Note N is longer than the preceeding note (duration + offsetTime used for calculating the perceived duration). If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity145">
<span class="keyword">proc</span>{<span class="functionname">IsLongerThanPredecessor_Rated</span> N Rating}<br>
<span class="string"> The higher the value of Rating, the more N is accented by its duration compared to its preceeding note (duration + offsetTime used for calculating the perceived duration).<BR>
 Rating=1: N is longer than its predecessor, or if there exists no predecessor.<BR>
 Rating=2: N is at least 2 times as long as its predecessor.<BR>
 Rating=3: N is at least 4 times as long as its predecessor.<BR>
 Rating is 0 otherwise. Rating is also 0 if N is shorter than its succeeding note.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity146">
<span class="keyword">proc</span>{<span class="functionname">IsLongerThanSurrounding_Rated</span> N Rating}<br>
<span class="string"> The higher the value of Rating, the more N is accented by its duration compared to its surrounding notes.<BR>
 <BR>
 Note: The rating of the first note in a temporal container is limited to the range [1,2]. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity147">
<span class="keyword">fun</span>{<span class="functionname">IsFirstOfEqualNoteValues</span> N}<br>
<span class="string"> B=1 <=> Note N is the first of 2 or more notes with equal note values (duration + offsetTime used for calculating the perceived note value), but the preceeding note value is different.<BR>
 If a preceeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled, but a succeeding note must exist for B=1.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity148">
<span class="keyword">fun</span>{<span class="functionname">IsHigherThanDirectNeighbours</span> N}<br>
<span class="string"> B=1 <=> Note N's pitch is higher than both its preceeding and its succeeding note. If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.<BR>
 TODO: ?? take offset times into account: a note with an offset time > 0 has "no predecessor". If the successor has an offset time > 0 then it has "no successor".<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity149">
<span class="keyword">fun</span>{<span class="functionname">IsHigherThanPredecessor</span> N}<br>
<span class="string"> B=1 <=> Note N's pitch is higher than the preceeding note and not lower than succeeding note. If a preceeding or succeeding note does not exist (in the same temporal container) then that part of the condition is considered to be fulfilled.<BR>
 TODO: ?? take offset times into account: a note with an offset time > 0 has "no predecessor". If the successor has an offset time > 0 then it has "no successor".<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity150">
<span class="keyword">fun</span>{<span class="functionname">IsSkip</span> N}<br>
<span class="string"> B=1 <=> Note N's pitch skips from its preceeding note by more than a minor third in either direction. If a preceeding note does not exist (in the same temporal container) then the condition is considered not to be fulfilled.<BR>
 TODO:<BR>
 - ?? take offset times into account: a note with an offset time > 0 has "no predecessor". If the successor has an offset time > 0 then it has "no successor".<BR>
 - !! Variant for large skips (see [Berry, 1987, p. 339, point 2]<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity151">
<span class="keyword">proc</span>{<span class="functionname">IsHigherThanPredecessor_Rated</span> N Rating}<br>
<span class="string"> The higher the value of Rating, the more N is accented by its pitch compared to its preceeding note.<BR>
 Rating=1: N is higher than its predecessor, or if there exists no predecessor.<BR>
 Rating=2: N is more than major second higher than predecessor<BR>
 Rating=3: N is more than fourth higher than predecessor<BR>
 Rating=4: N is more than major six higher than predecessor<BR>
 Rating is 0 otherwise. Rating is also 0 if N is lower than its succeeding note.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity152">
<span class="keyword">proc</span>{<span class="functionname">IsHigherThanSurrounding_Rated</span> N Rating}<br>
<span class="string"> The higher the value of Rating, the more N is accented by its pitch compared to its surrounding notes.<BR>
 <BR>
 Note: The rating of the first note in a temporal container is limited to the range [1,2]. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity153">
<span class="keyword">proc</span>{<span class="functionname">HasTextureAccent</span> MyNote Rating}<br>
<span class="string"> Rating (FD int) is the number of simultaneous notes that have the same start time as MyNote (a note object). There may be more simultaneous notes with a different start time, but these do /not/ count.<BR>
 Note: Constraint delayed until simultaneous notes are known.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity154">
<span class="keyword">fun</span>{<span class="functionname">WeightConstraint</span> C I}<br>
<span class="string"> Expects an accent constraint C (a function expecting a note and returning a rating FD int, and returns an accent constraint that is a variation of C, where the rating is multiplied by I (an FD int). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity155">
<span class="keyword">fun</span>{<span class="functionname">Make_HasAnacrusis</span> Args}<br>
<span class="string"> Make_HasAnacrusis returns an accent constraint, i.e. a function execting a note/item N and returning a rating FD int. The resulting function returns a positive rating for N preceeded by an anacrusis, and 0 otherwise.<BR>
<BR>
 Args:<BR>
 context (record or function, default predecessorsUpToRest): This argument specifies the score context that potentially forms an anacrusis of N. If 'predecessorsUpToRest', then the notes before N up to any rest (offset time or pause object) are taken into account (within the same temporal container). If predecessors(I), then the I (an int) notes before N are taken into account (within the same temporal container). The context can also be defined by a unary function expecting N and returning the items as a list.<BR>
 ratingPs (list of constraints {P Xs ?Rating}, default nil): This argument specifies how the quality (rating) of an anacrusis is measured. Each ratingP is a function that expects a list of notes (of at least length 2) starting with N, then its predecessor and so forth. Each function returns a rating (an FD int). The resulting accent constraint rating is the minimum rating of any ratingP (subject to requirements, see below). Example constraint: N predecessors are of equal length (Anacrusis_FirstNEvenDurations).<BR>
 requirements (list of reified constraints {P Xs B}, default nil): This argument specifies requirements that must be met by the score context if it should count at all as an anacrusis. Each requirement is a function that expects a list of notes (of at least length 2) starting with N, then its predecessor and so forth. Each function returns a 0/1-int. If any requirement returns 0 then the accent constraint returns 0 for this note. If all requirements returns 1, then the value resulting from the ratingPs is returned as rating. Example constraint: N longer than its predecessor (Anacrusis_LongerThanPrevious).<BR>
 maxRating (int, default 2): maximum rating for N. If the computed rating exceeds maxRating then maxRating is returned instead.<BR>
<BR>
 Note: if neither ratingPs nor requirements are given then the accent constraint returns the rating 1 for all notes. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity156">
<span class="keyword">fun</span>{<span class="functionname">Anacrusis_AccentLonger</span> Ns}<br>
<span class="string"> [anacrusis requirement] The duration of the accent (1st note in Ns) is longer then the first note of the anacrusis (the 2nd note in Ns).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity157">
<span class="keyword">fun</span>{<span class="functionname">Anacrusis_DirectionChange</span> Ns}<br>
<span class="string"> [anacrusis requirement] At the accent (1st note in Ns) happens a change in pitch direction.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity158">
<span class="keyword">fun</span>{<span class="functionname">Anacrusis_LocalMax</span> Ns}<br>
<span class="string"> [anacrusis requirement] The accent (1st note in Ns) is a local pitch maximum.<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>