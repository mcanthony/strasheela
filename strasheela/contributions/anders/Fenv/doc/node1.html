<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Fenv</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="2" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Fenv</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor defines an abstraction for using numerical functions as envelopes (function envelopes, or "fenvs"), and provides a rich set of functions/methods to generate, combine and transform these envelopes.<BR>
<BR>
 See testing/Fenv-test.oz for examples (using a Gnuplot interface for envelope visualisation).<BR>
<BR>
 NB: This functor aims for a high degree of flexilibity in envelope creation and manipulation instead of efficiency. But nowadays, machines are rather fast... <BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Fenv ("<span class="string">Fenv.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>Browser(browse:Browse)</li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>Out at "<span class="string">x-ozlib://anders/strasheela/source/Output.ozf"
</span></li><li>GPlot(plot:Plot) at "<span class="string">x-ozlib://anders/strasheela/Gnuplot/Gnuplot.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;C:<a href="#entity6"><span class="type">Fenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity7"><span class="functionname">IsFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity8"><span class="functionname">FenvSeq</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity9"><span class="functionname">FuncsToFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity10"><span class="functionname">Osciallator</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity11"><span class="functionname">PointsToFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity12"><span class="functionname">LinearFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity13"><span class="functionname">SinFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity14"><span class="functionname">SinFenv2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity15"><span class="functionname">ConstantFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity16"><span class="functionname">SinOsc</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity17"><span class="functionname">Saw</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity18"><span class="functionname">Triangle</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity19"><span class="functionname">Square</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity20"><span class="functionname">Pulse</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity21"><span class="functionname">ReverseFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity22"><span class="functionname">InvertFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity23"><span class="functionname">Reciprocal</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity24"><span class="functionname">CombineFenvs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity25"><span class="functionname">ScaleFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity26"><span class="functionname">RescaleFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity27"><span class="functionname">Waveshape</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity28"><span class="functionname">FenvSection</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity29"><span class="functionname">Integrate</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity30"><span class="functionname">TempoCurveToTimeMap</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity31"><span class="functionname">TimeShiftToTimeMap</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity32"><span class="functionname">ConcatenateTempoCurves</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity33"><span class="functionname">TemporalFenvY</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity34"><span class="functionname">ItemFenvY</span></a>&gt;
</li><li>&lt;P/8:<a href="#entity35"><span class="functionname">FenvToMidiCC</span></a>&gt;
</li><li>&lt;P/7:<a href="#entity36"><span class="functionname">ItemFenvToMidiCC</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<a name="entity6">
<p class="margin"><div align="right"><a href="class1.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Defines a data structure for envelopes based on the notion of numeric functions (a function envelope or "fenv").<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">Fenv</span>
<br>&nbsp;&nbsp;&nbsp;<span class="keyword">feat</span>&nbsp;!FenvType

<ul><li><span class="functionname">init</span>(env:Env max:Mx min:Mn rangeIsForArgumentFun:RangeIsForArgumentFun)<br>
</li><li><span class="functionname">getEnv</span>($)<br>
</li><li><span class="functionname">y</span>($ X)<br>
</li><li><span class="functionname">toList</span>($ N)<br>
</li><li><span class="functionname">toPairs</span>($ N)<br>
</li><li><span class="functionname">plot</span>(n:N&nbsp;...)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>

<code>
<a name="entity7">
<span class="keyword">fun</span>{<span class="functionname">IsFenv</span> X}<br>
<span class="string"> Returns true if X is a Fenv instance and false otherwise.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity8">
<span class="keyword">fun</span>{<span class="functionname">FenvSeq</span> FenvsAndPoints}<br>
<span class="string"> Combines an arbitrary number of fenvs to a single fenv. Expects its args as a list in the form [fenv num fenv num ... fenv]. The numbers between the fenvs specify the start resp. end point of a certain fenv. All numbers should be between 0--1 (exclusive).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity9">
<span class="keyword">fun</span>{<span class="functionname">FuncsToFenv</span> Funcs Args}<br>
<span class="string"> Converts a list of unary numeric functions to a single fenv. The arguments min and max a given for all functions and the functions are equally spaced in the fenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity10">
<span class="keyword">fun</span>{<span class="functionname">Osciallator</span> MyFenv N}<br>
<span class="string"> Defines a new fenv by repeating givenm fenv n times. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity11">
<span class="keyword">fun</span>{<span class="functionname">PointsToFenv</span> Func Points}<br>
<span class="string"> Converts a list of points into a single env. A point is an x-y-pair as [Xi Yi]. X values of the points range from 0--i (including), e.g., [[0.0 Y1] [X2 Y2] ... [1.0 Yn]]. The function Func defines the shape of the fenv segments and must return a fenv. It expects a list of four numeric arguments, which describe the start and end points of the segment in the form [X1 Y1 X2 Y2].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity12">
<span class="keyword">fun</span>{<span class="functionname">LinearFenv</span> Points}<br>
<span class="string"> Defines a fenv which interpolates the given points by a linear function. Expects a list of x-y-pairs as [[0.0 Y1] ... [1.0 Yn]].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity13">
<span class="keyword">fun</span>{<span class="functionname">SinFenv</span> Points}<br>
<span class="string"> Defines a fenv which interpolates the given points by a sin function, using a full wave length. This results in a fenv without edges, however, this fenv is rather 'curvy'. Expects a list of x-y-pairs as [[0.0 Y1] ... [1.0 Yn]].<BR>
 NB: in the lisp library, this was macro sin-env1.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity14">
<span class="keyword">fun</span>{<span class="functionname">SinFenv2</span> Points}<br>
<span class="string"> Defines a fenv which interpolates the given points by a sin function. Using only the intervals [0,pi/2] and [pi, 3pi/4], which results in edges but is less 'curvy' than SinFenv. Expects a list of x-y-pairs as [[0.0 Y1] ... [1.0 Yn]].<BR>
 NB: in the lisp library, this was macro sin-env.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity15">
<span class="keyword">fun</span>{<span class="functionname">ConstantFenv</span> Y}<br>
<span class="string"> Returns Fenv which outputs Y (a float) for any X.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity16">
<span class="keyword">fun</span>{<span class="functionname">SinOsc</span> N Args}<br>
<span class="string"> Defines a fenv of sin shape with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity17">
<span class="keyword">fun</span>{<span class="functionname">Saw</span> N Args}<br>
<span class="string"> Defines a fenv of saw shape (ascending) with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity18">
<span class="keyword">fun</span>{<span class="functionname">Triangle</span> N Args}<br>
<span class="string"> Defines a fenv of triangle shape with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity19">
<span class="keyword">fun</span>{<span class="functionname">Square</span> N Args}<br>
<span class="string"> Defines a fenv of square shape with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity20">
<span class="keyword">fun</span>{<span class="functionname">Pulse</span> N Args}<br>
<span class="string"> Defines a fenv of pulse shape with n periods. Args are min (lowest value), max (highest value), and width (pulse width between 0.0 and 1.0). The oscillator starts with the highest value. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity21">
<span class="keyword">fun</span>{<span class="functionname">ReverseFenv</span> MyFenv}<br>
<span class="string"> Reverses MyFenv (i.e. flips it at x=0.5).<BR>
 NB: ReverseFenv is defined only for the valid Fenv domain 0.0 .. 1.0.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity22">
<span class="keyword">fun</span>{<span class="functionname">InvertFenv</span> MyFenv}<br>
<span class="string"> Inverses MyFenv (i.e. flips it at y=0.0).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity23">
<span class="keyword">fun</span>{<span class="functionname">Reciprocal</span> MyFenv}<br>
<span class="string"> Returns a Fenv which is the reciprocal of the given Fenv, i.e., 1/fenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity24">
<span class="keyword">fun</span>{<span class="functionname">CombineFenvs</span> CombiFunc Fenvs}<br>
<span class="string"> Returns a fenv which combines the given fenvs with an n-ary numeric function. Fenvs is a list which consists of fenvs and floats (representing constant fenvs) in any order. The combine-func expects a list with as many floats as correspond to Fenv values (in their order and at the same x), and returns a float.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity25">
<span class="keyword">fun</span>{<span class="functionname">ScaleFenv</span> MyFenv Args}<br>
<span class="string"> Scale MyFenv with Args: arg mul is factor and arg add is summand (addend). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity26">
<span class="keyword">fun</span>{<span class="functionname">RescaleFenv</span> MyFenv Args}<br>
<span class="string"> Returns a new Fenv which rescales the given y-range of MyFenv (defaults: oldmin:~1.0, oldmax:1.0) into a new range (defaults: newmin:0.0, newmax:1.0).<BR>
 All these four arguments can be fenvs as well.<BR>
<BR>
 !! NB: RescaleFenv is buggy. Problems with neg. numbers (see examples). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity27">
<span class="keyword">fun</span>{<span class="functionname">Waveshape</span> Fenv1 Fenv2}<br>
<span class="string"> Returns a fenv which reads Fenv1 'through' Fenv2: the y value of Fenv2 (at a given x value) is used as x for Fenv1. to access the y of Fenv1 (the y of Fenv1 is returned). Compared with waveshaping in signal processing, Fenv1 is the "transfer function" and Fenv2 is the "input signal". <BR>
 NB: Take care to keep the output of fenv2 in interval [0,1].<BR>
<BR>
 NB: for more simple use, I should think about more complex def which allows for Fenv2 values going beyond the interval [0,1] (or be automatically scaled into that interval). I could use a plain function as transfer function, but using the tools for generating fenvs can be helpful. Alternatively, I can simply remove the condition which restricts fenvs to [0,1].  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity28">
<span class="keyword">fun</span>{<span class="functionname">FenvSection</span> MyFenv Args}<br>
<span class="string"> Returns fenv which is a section of given fenv. y value at 0/1 of returned fenv is y value of given fenv at min/max. Both min and max must be in the interval [0, 1].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity29">
<span class="keyword">fun</span>{<span class="functionname">Integrate</span> MyFenv Step}<br>
<span class="string"> Returns the integral fenv of fenv. <BR>
 Performs numerical integration internally whenever a value of the returned fenv is accessed, which can be computationally expensive.<BR>
 Step (a float in [0.0 0.5]) specifies the resolution of the numeric integration: the smaller Step, the more accurate the integration and the more expensive the computation. Step=0.01 results in 100 "function slices".<BR>
<BR>
 Note: implementation currently always uses Trapezoidal rule for the approximation (i.e. approximation by linear functions under given function), this can be made user-controllable if necessary (see implementation).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity30">
<span class="keyword">fun</span>{<span class="functionname">TempoCurveToTimeMap</span> MyFenv Step}<br>
<span class="string"> Transforms a fenv expressing a normalised tempo curve into a fenv expressing a normalised time map. Step (a float) specifies the precision (and efficiency!) of the transformation, see Integrate's doc for details. A tempo curve expresses a tempo factor, i.e., f(x) = 1 results in no tempo change. A normalised time map maps score time to performance time. <BR>
 Private Terminology: normalised time shift functions, time map functions and tempo curves: fenvs where x values denote the score time (usually of a temporal container) which is mapped into [0,1]: 0 corresponds to the container's start time, and 1 corresponds to the container's end time. See ContainerFenvY.<BR>
 NB: a normalised time map fenvs cannot be combined by function combination (x values for fenvs are always in [0,1]). Instead, either combine tempo curve and time shift fenvs, or combine plain and un-normalised time map functions (i.e. no fenvs).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity31">
<span class="keyword">fun</span>{<span class="functionname">TimeShiftToTimeMap</span> TS}<br>
<span class="string"> Expects a fenv representing a normalised time shift function and returns a fenv representing a normalised time map function. A time shift function expresses how much is added to a score time to yield a performance time, i.e., f(x) = 0 causes performance time to be score time. A normalised time map maps score time to performance time.<BR>
 Private Terminology: normalised time shift functions, time map functions and tempo curves: fenvs where x values denote the score time (usually of a temporal container) which is mapped into [0,1]: 0 corresponds to the container's start time, and 1 corresponds to the container's end time. See ContainerFenvY.<BR>
 NB: a normalised time map fenvs cannot be combined by function combination (x values for fenvs are always in [0,1]). Instead, either combine tempo curve and time shift fenvs, or combine plain and un-normalised time map functions (i.e. no fenvs).  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity32">
<span class="keyword">fun</span>{<span class="functionname">ConcatenateTempoCurves</span> Specs}<br>
<span class="string"> Concatenates a sequence of successive tempo curve fenvs. Specs is a list of pairs and has the form [Fenv1#Dur1 Fenv2#Dur2 ... FenvN#DurN], where FenvI is a tempo curve fenv and DurI (a float) is the score time duration of this tempo curve. Returned is a single tempo curve fenv.<BR>
 NB: in most use-cases the sequence of successive tempo curve fenvs should start at score time 0 and span over the entire score so that the global tempo curve fenv is the result. If you concatenate a tempo curve sequence which does not start at score time 0, you should decide whether the resulting tempo curve fenv starts at the performance or score start time of its first sub-tempo curve (i.e., whether a smooth continuation of previous tempo changes is intended or not). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity33">
<span class="keyword">fun</span>{<span class="functionname">TemporalFenvY</span> MyFenv Start Duration MyTime}<br>
<span class="string"> Accesses the y-value of MyFenv which starts at time point Start (a float) for time interval Duration (a float). The fenv x-value 0.0 corresponds to the start time and the fenv x-value 1.0 coresponds to the resulting end time. MyTime (a float) is any time between the start and end time. All times are score times measured in seconds.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity34">
<span class="keyword">fun</span>{<span class="functionname">ItemFenvY</span> MyFenv MyItem MyTime}<br>
<span class="string"> Accesses the y-value of MyFenv which is associated with a temporal item MyItem. The fenv x-value 0.0 corresponds to the container start time and the fenv x-value 1.0 coresponds to the container end time. MyTime (a float) is any time between MyContainer's start and end time. MyTime is a score time measured in seconds.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity35">
<span class="keyword">fun</span>{<span class="functionname">FenvToMidiCC</span> MyFenv N Track StartTime EndTime Channel Controller}<br>
<span class="string"> Transforms a Fenv into a list of continuous MIDI controller events. N events are output between StartTime and EndTime (two ints, given in MIDI ticks) at Channel (an int). <BR>
 Controller denotes which controller is output. Possible values are one of the atoms pitchbend, and channelAftertouch, or one of the pairs cc#Number (Number is the controller number) and polyAftertouch#Note (Note denotes the note pitch). <BR>
 Finally, Controller can be a function expecting 4 arguments and returning a MIDI event. For example, the volume Controller can be defined as follows<BR>
   fun {$ Track Time Channel Value}<BR>
      {Out.midi.makeCC Track Time Channel 7 Value}<BR>
   end<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity36">
<span class="keyword">fun</span>{<span class="functionname">ItemFenvToMidiCC</span> MyFenv N Track MyItem Channel Controller}<br>
<span class="string"> Like FenvToMidiCC, but here the Fenv is associated with a temporal item MyItem, whose start and end times are taken. <BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>