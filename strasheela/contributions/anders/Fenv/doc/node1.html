<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Fenv</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="2" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Fenv</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor defines an abstraction for using numerical functions as envelopes (function envelopes, or "fenvs"), and provides a rich set of functions/methods to generate, combine and transform these envelopes.<BR>
<BR>
 See testing/Fenv-test.oz for examples (using a Gnuplot interface for envelope visualisation).<BR>
<BR>
 NB: This functor aims for a high degree of flexilibity in envelope creation and manipulation instead of efficiency. But nowadays, machines are rather fast... <BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Fenv ("<span class="string">Fenv.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>Score at "<span class="string">x-ozlib://anders/strasheela/source/ScoreCore.ozf"
</span></li><li>Out at "<span class="string">x-ozlib://anders/strasheela/source/Output.ozf"
</span></li><li>GPlot(plot:Plot) at "<span class="string">x-ozlib://anders/strasheela/Gnuplot/Gnuplot.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;C:<a href="#entity6"><span class="type">Fenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity7"><span class="functionname">IsFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity8"><span class="functionname">FenvSeq</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity9"><span class="functionname">FuncsToFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity10"><span class="functionname">Osciallator</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity11"><span class="functionname">PointsToFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity12"><span class="functionname">LinearFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity13"><span class="functionname">SinFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity14"><span class="functionname">SinFenv2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity15"><span class="functionname">ConstantFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity16"><span class="functionname">SinOsc</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity17"><span class="functionname">Saw</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity18"><span class="functionname">Triangle</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity19"><span class="functionname">Square</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity20"><span class="functionname">Pulse</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity21"><span class="functionname">ReverseFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity22"><span class="functionname">InvertFenv</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity23"><span class="functionname">Reciprocal</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity24"><span class="functionname">CombineFenvs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity25"><span class="functionname">ScaleFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity26"><span class="functionname">RescaleFenv</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity27"><span class="functionname">Waveshape</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity28"><span class="functionname">FenvSection</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity29"><span class="functionname">Integrate</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity30"><span class="functionname">TempoCurveToTimeMap</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity31"><span class="functionname">TempoCurveToTimeShift</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity32"><span class="functionname">TempoCurveToTimeShift_KeepingDur</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity33"><span class="functionname">TimeShiftToTimeMap</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity34"><span class="functionname">TimeMapToTimeShift</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity35"><span class="functionname">ConcatenateTempoCurves</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity36"><span class="functionname">TemporalFenvY</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity37"><span class="functionname">ItemFenvY</span></a>&gt;
</li><li>&lt;P/8:<a href="#entity38"><span class="functionname">FenvToMidiCC</span></a>&gt;
</li><li>&lt;P/7:<a href="#entity39"><span class="functionname">ItemFenvToMidiCC</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity40"><span class="functionname">ItemFenvsToMidiCC</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity41"><span class="functionname">ItemTempoCurveToMidi</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity42"><span class="functionname">RenderAndPlayMidiFile</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity43"><span class="functionname">MakeRenderAndPlayMidiFile_Scala</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<a name="entity6">
<p class="margin"><div align="right"><a href="class1.html">[class info]</a></div></p>
<code>

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> Defines a data structure for envelopes based on the notion of numeric functions (a function envelope or "fenv").<BR>
<BR>
</span>
<span class="keyword">class</span> <span class="type">Fenv</span>
<br>&nbsp;&nbsp;&nbsp;<span class="keyword">feat</span>&nbsp;!FenvType

<ul><li><span class="functionname">init</span>(env:Env max:Mx min:Mn rangeIsForArgumentFun:RangeIsForArgumentFun)<br>
</li><li><span class="functionname">getEnv</span>($)<br>
</li><li><span class="functionname">y</span>($ X)<br>
</li><li><span class="functionname">toList</span>($ N)<br>
</li><li><span class="functionname">toList_Int</span>($ N add:Add mul:Mul)<br>
</li><li><span class="functionname">toPairs</span>($ N)<br>
</li><li><span class="functionname">plot</span>(n:N&nbsp;...)<br>
</li></ul>
<span class="keyword">end</span>
</code><br>

<code>
<a name="entity7">
<span class="keyword">fun</span>{<span class="functionname">IsFenv</span> X}<br>
<span class="string"> Returns true if X is a Fenv instance and false otherwise.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity8">
<span class="keyword">fun</span>{<span class="functionname">FenvSeq</span> FenvsAndPoints}<br>
<span class="string"> Combines an arbitrary number of fenvs to a single fenv. Expects its args as a list in the form [fenv num fenv num ... fenv]. The numbers between the fenvs specify the start resp. end point of a certain fenv. All numbers should be between 0--1 (exclusive).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity9">
<span class="keyword">fun</span>{<span class="functionname">FuncsToFenv</span> Funcs Args}<br>
<span class="string"> Converts a list of unary numeric functions to a single fenv. The arguments min and max a given for all functions and the functions are equally spaced in the fenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity10">
<span class="keyword">fun</span>{<span class="functionname">Osciallator</span> MyFenv N}<br>
<span class="string"> Defines a new fenv by repeating givenm fenv n times. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity11">
<span class="keyword">fun</span>{<span class="functionname">PointsToFenv</span> Func Points}<br>
<span class="string"> Converts a list of points into a single env. A point is an x-y-pair as [Xi Yi]. X values of the points range from 0--i (including), e.g., [[0.0 Y1] [X2 Y2] ... [1.0 Yn]]. The function Func defines the shape of the fenv segments and must return a fenv. It expects a list of four numeric arguments, which describe the start and end points of the segment in the form [X1 Y1 X2 Y2].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity12">
<span class="keyword">fun</span>{<span class="functionname">LinearFenv</span> Points}<br>
<span class="string"> Defines a fenv which interpolates the given points by a linear function. Expects a list of x-y-pairs as [[0.0 Y1] ... [1.0 Yn]].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity13">
<span class="keyword">fun</span>{<span class="functionname">SinFenv</span> Points}<br>
<span class="string"> Defines a fenv which interpolates the given points by a sin function, using a full wave length. This results in a fenv without edges, however, this fenv is rather 'curvy'. Expects a list of x-y-pairs as [[0.0 Y1] ... [1.0 Yn]].<BR>
 NB: in the lisp library, this was macro sin-env1.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity14">
<span class="keyword">fun</span>{<span class="functionname">SinFenv2</span> Points}<br>
<span class="string"> Defines a fenv which interpolates the given points by a sin function. Using only the intervals [0,pi/2] and [pi, 3pi/4], which results in edges but is less 'curvy' than SinFenv. Expects a list of x-y-pairs as [[0.0 Y1] ... [1.0 Yn]].<BR>
 NB: in the lisp library, this was macro sin-env.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity15">
<span class="keyword">fun</span>{<span class="functionname">ConstantFenv</span> Y}<br>
<span class="string"> Returns Fenv which outputs Y (a float) for any X.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity16">
<span class="keyword">fun</span>{<span class="functionname">SinOsc</span> N Args}<br>
<span class="string"> Defines a fenv of sin shape with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity17">
<span class="keyword">fun</span>{<span class="functionname">Saw</span> N Args}<br>
<span class="string"> Defines a fenv of saw shape (ascending) with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity18">
<span class="keyword">fun</span>{<span class="functionname">Triangle</span> N Args}<br>
<span class="string"> Defines a fenv of triangle shape with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity19">
<span class="keyword">fun</span>{<span class="functionname">Square</span> N Args}<br>
<span class="string"> Defines a fenv of square shape with n periods. Args are mul and add, as for ScaleFenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity20">
<span class="keyword">fun</span>{<span class="functionname">Pulse</span> N Args}<br>
<span class="string"> Defines a fenv of pulse shape with n periods. Args are min (lowest value), max (highest value), and width (pulse width between 0.0 and 1.0). The oscillator starts with the highest value. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity21">
<span class="keyword">fun</span>{<span class="functionname">ReverseFenv</span> MyFenv}<br>
<span class="string"> Reverses MyFenv (i.e. flips it at x=0.5).<BR>
 NB: ReverseFenv is defined only for the valid Fenv domain 0.0 .. 1.0.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity22">
<span class="keyword">fun</span>{<span class="functionname">InvertFenv</span> MyFenv}<br>
<span class="string"> Inverses MyFenv (i.e. flips it at y=0.0).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity23">
<span class="keyword">fun</span>{<span class="functionname">Reciprocal</span> MyFenv}<br>
<span class="string"> Returns a Fenv which is the reciprocal of the given Fenv, i.e., 1/fenv.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity24">
<span class="keyword">fun</span>{<span class="functionname">CombineFenvs</span> CombiFunc Fenvs}<br>
<span class="string"> Returns a fenv which combines the given fenvs with an n-ary numeric function. Fenvs is a list which consists of fenvs and floats (representing constant fenvs) in any order. The combine-func expects a list with as many floats as correspond to Fenv values (in their order and at the same x), and returns a float.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity25">
<span class="keyword">fun</span>{<span class="functionname">ScaleFenv</span> MyFenv Args}<br>
<span class="string"> Scale MyFenv with Args: arg mul is factor and arg add is summand (addend). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity26">
<span class="keyword">fun</span>{<span class="functionname">RescaleFenv</span> MyFenv Args}<br>
<span class="string"> Returns a new Fenv which rescales the given y-range of MyFenv (defaults: oldmin:~1.0, oldmax:1.0) into a new range (defaults: newmin:0.0, newmax:1.0).<BR>
 All these four arguments can be fenvs as well.<BR>
<BR>
 !! NB: RescaleFenv is buggy. Problems with neg. numbers (see examples). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity27">
<span class="keyword">fun</span>{<span class="functionname">Waveshape</span> Fenv1 Fenv2}<br>
<span class="string"> Returns a fenv which reads Fenv1 'through' Fenv2: the y value of Fenv2 (at a given x value) is used as x for Fenv1. to access the y of Fenv1 (the y of Fenv1 is returned). Compared with waveshaping in signal processing, Fenv1 is the "transfer function" and Fenv2 is the "input signal". <BR>
 NB: Take care to keep the output of fenv2 in interval [0,1].<BR>
<BR>
 NB: for more simple use, I should think about more complex def which allows for Fenv2 values going beyond the interval [0,1] (or be automatically scaled into that interval). I could use a plain function as transfer function, but using the tools for generating fenvs can be helpful. Alternatively, I can simply remove the condition which restricts fenvs to [0,1].  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity28">
<span class="keyword">fun</span>{<span class="functionname">FenvSection</span> MyFenv Args}<br>
<span class="string"> Returns fenv which is a section of given fenv. y value at 0/1 of returned fenv is y value of given fenv at min/max. Both min and max must be in the interval [0, 1].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity29">
<span class="keyword">fun</span>{<span class="functionname">Integrate</span> MyFenv Step}<br>
<span class="string"> Returns the integral fenv of fenv. <BR>
 Performs numerical integration internally whenever a value of the returned fenv is accessed, which can be computationally expensive.<BR>
 Step (a float in [0.0 0.5]) specifies the resolution of the numeric integration: the smaller Step, the more accurate the integration and the more expensive the computation. Step=0.01 results in 100 "function slices".<BR>
<BR>
 Note: implementation currently always uses Simpson's rule rule for the approximation (based on a polynomial of order 2, pretty good :), it case this is too computationally expensive, could be made user-controllable if necessary (see implementation).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity30">
<span class="keyword">fun</span>{<span class="functionname">TempoCurveToTimeMap</span> MyFenv Step}<br>
<span class="string"> Transforms a fenv expressing a normalised tempo curve into a fenv expressing a normalised time map. Step (a float) specifies the precision (and efficiency!) of the transformation, see Integrate's doc for details. A tempo curve expresses a tempo factor, i.e., f(x) = 1 results in no tempo change. A normalised time map maps score time to performance time. <BR>
 Private Terminology: normalised time shift functions, time map functions and tempo curves: fenvs where x values denote the score time (usually of a temporal container) which is mapped into [0,1]: 0 corresponds to the container's start time, and 1 corresponds to the container's end time. See ContainerFenvY.<BR>
 NB: normalised time map fenvs cannot be combined by function combination (x values for fenvs are always in [0,1]). Instead, either combine tempo curve and time shift fenvs, or combine plain and un-normalised time map functions (i.e. no fenvs).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity31">
<span class="keyword">fun</span>{<span class="functionname">TempoCurveToTimeShift</span> MyFenv Step}<br>
<span class="string"> ... this is probably not a good idea, but works for certain cases.<BR>
<BR>
 ?? BUG: slower tempo changes between fixed min/max tempo values result in larger [absolute] tempo changes. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity32">
<span class="keyword">fun</span>{<span class="functionname">TempoCurveToTimeShift_KeepingDur</span> MyFenv Args}<br>
<span class="string"> [Experimental] Transforms a fenv expressing a normalised tempo curve into a fenv expressing a normalised time shift function. However, the resulting time shift function is deformed such that it always ends in 0.0 (so it ends at score time).<BR>
 NB: the resulting time shift function does not faithfully express the tempos of the given tempo curve (this depends on the arg mul, see below), but the overall shape is similar and therefore (hopefully) simplifies creating natural time shift functions expressing tempo changes. <BR>
<BR>
 Args:<BR>
 step (default 0.01): stepsize for integration, see there.<BR>
 mul (default 1.0): scaling factor for the resulting fenv. Try setting it to some specific note duration... Depends on intended tempo change and also on duration of phrase time shifted.<BR>
<BR>
 ?? BUG: slower tempo changes between fixed min/max tempo values result in larger [absolute] tempo changes.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity33">
<span class="keyword">fun</span>{<span class="functionname">TimeShiftToTimeMap</span> TS}<br>
<span class="string"> Expects a fenv representing a normalised time shift function and returns a fenv representing a normalised time map function. A time shift function expresses how much is added to a score time to yield a performance time, i.e., f(x) = 0 causes performance time to be score time. A normalised time map maps score time to performance time.<BR>
 Private Terminology: normalised time shift functions, time map functions and tempo curves: fenvs where x values denote the score time (usually of a temporal container) which is mapped into [0,1]: 0 corresponds to the container's start time, and 1 corresponds to the container's end time. See ContainerFenvY.<BR>
 NB: normalised time map fenvs cannot be combined by function combination (x values for fenvs are always in [0,1]). Instead, either combine tempo curve and time shift fenvs, or combine plain and un-normalised time map functions (i.e. no fenvs).  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity34">
<span class="keyword">fun</span>{<span class="functionname">TimeMapToTimeShift</span> MyFenv}<br>
<span class="string"> ... this is perhaps not a good idea, but works for certain cases.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity35">
<span class="keyword">fun</span>{<span class="functionname">ConcatenateTempoCurves</span> Specs}<br>
<span class="string"> Concatenates a sequence of successive tempo curve fenvs. Specs is a list of pairs and has the form [Fenv1#Dur1 Fenv2#Dur2 ... FenvN#DurN], where FenvI is a tempo curve fenv and DurI (a float) is the score time duration of this tempo curve. Returned is a single tempo curve fenv.<BR>
 NB: in most use-cases the sequence of successive tempo curve fenvs should start at score time 0 and span over the entire score so that the global tempo curve fenv is the result. If you concatenate a tempo curve sequence which does not start at score time 0, you should decide whether the resulting tempo curve fenv starts at the performance or score start time of its first sub-tempo curve (i.e., whether a smooth continuation of previous tempo changes is intended or not). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity36">
<span class="keyword">fun</span>{<span class="functionname">TemporalFenvY</span> MyFenv Start Duration MyTime}<br>
<span class="string"> Accesses the y-value of MyFenv which starts at time point Start (a float) for time interval Duration (a float). The fenv x-value 0.0 corresponds to the start time and the fenv x-value 1.0 coresponds to the resulting end time. MyTime (a float) is any time between the start and end time. All times are score times measured in the same time unit.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity37">
<span class="keyword">fun</span>{<span class="functionname">ItemFenvY</span> MyFenv MyItem MyTime}<br>
<span class="string"> Accesses the y-value of MyFenv which is associated with a temporal item MyItem. The fenv x-value 0.0 corresponds to the item's start time and the fenv x-value 1.0 coresponds to the item's end time. MyTime (a float) is any time between MyItem's start and end time. MyTime is a score time measured in the time unit of MyItem.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity38">
<span class="keyword">fun</span>{<span class="functionname">FenvToMidiCC</span> MyFenv N Track StartTime EndTime Channel Controller}<br>
<span class="string"> Transforms a Fenv into a list of continuous MIDI controller events. N events are output between StartTime and EndTime (two ints, given in MIDI ticks) at Channel (an int). <BR>
 Controller denotes which controller is output. Possible values are one of the atoms pitchbend, and channelAftertouch, or one of the pairs cc#Number (Number is the controller number) and polyAftertouch#Note (Note denotes the note pitch). <BR>
 Finally, Controller can be a function expecting 4 arguments and returning a MIDI event. For example, the volume Controller can be defined as follows<BR>
   fun {$ Track Time Channel Value}<BR>
      {Out.midi.makeCC Track Time Channel 7 Value}<BR>
   end<BR>
 NOTE: no implicit support for any tempo curves etc. Instead, adapt StartTime and EndTime (and possibly transform MyFenv) outside FenvToMidiCC.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity39">
<span class="keyword">fun</span>{<span class="functionname">ItemFenvToMidiCC</span> MyFenv N Track MyItem Channel Controller}<br>
<span class="string"> Like FenvToMidiCC, but here the Fenv is associated with a temporal item MyItem, whose start and end times are taken. <BR>
 NOTE: no support for any tempo curves etc. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity40">
<span class="keyword">fun</span>{<span class="functionname">ItemFenvsToMidiCC</span> MyItem Args}<br>
<span class="string"> Expects a temporal item which defines fenvs in an info-tag 'fenvs', and returns a list of continuous MIDI controller events for all its fenvs. Each fenvs is defined by a pair Controller#Fenv, where Controller can take all values defined for FenvToMidiCC. Fenvs directly specify the controller values (e.g., if Controller is pitchBend, then the Fenv range is 0.0 to 16383.0, and the value 8192.0 means no pitchbend). Note that for any controller only a single Fenv should be defined at any time (otherwise they conflict with each other).<BR>
 Example: fenvs((cc#1)#{Fenv.linearFenv [[0.0 0.0] [1.0 127.0]]}) <BR>
<BR>
 Args:<BR>
 ccsPerSecond: how many CC events are created per second (a float).<BR>
 track: MIDI track to output, default 2 (suitable for more cases)<BR>
 channel: midi channel to output, default nil (if nil, MIDI note object CCs are output to its channel and all other to channel 0) <BR>
<BR>
 Timeshift fenvs affect the start and end of the continuous MIDI controller events, but not their "spacing".<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity41">
<span class="keyword">fun</span>{<span class="functionname">ItemTempoCurveToMidi</span> MyItem Args}<br>
<span class="string"> Expects a temporal item which defines a tempo curve Fenv in a info-tag 'globaltempo', and returns a list of MIDI tempo events. Returns nil in case MyItem defines no tempo curve. The tempo fenv values are in beats per minute. Due to restrictions of the MIDI protocoll, only a single global tempo is supported (note that sequencers may restrict the import of such data in a MIDI files). If multiple tempi are defined "in parallel" or nested, then "conflicting" MIDI tempo events are output.<BR>
 Example: globaltempo({Fenv.linearFenv [[0.0 30.0] [1.0 240.0]]})<BR>
<BR>
 Args:<BR>
 ccsPerSecond: how many tempo events are created per second (a float).<BR>
 track: MIDI track to output, default 2 (suitable for more cases)<BR>
<BR>
 Time shift fenvs affect the start and end of the tempo events, but not their "spacing".<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity42">
<span class="keyword">proc</span>{<span class="functionname">RenderAndPlayMidiFile</span> MyScore Args}<br>
<span class="string"> This procedure is like Out.midi.renderAndPlayMidiFile, but it additional supports continuous controllers and a global tempo curve, expressed in the score by fenvs. Also, microtonal music is supported (using pitchbends).<BR>
<BR>
 Supported score format:<BR>
 <BR>
 The info-tag 'channel', given to a note or temporal container, sets the MIDI channel for this item and all contained items. Example: channel(0). If a channel is defined multiple times, then a setting in a lower hierarchical level overwrites higher-level settings.<BR>
<BR>
 The info-tag 'program', given to a note or temporal container, results in a program change message with the specified program number at the beginning of the item. Example: program(64) given to a sequential container changes the program at the beginning of the container (note that programs are not automatically sitched back). Remember that many MIDI instruments number their patches (programs) from 1 to 128 rather than the range 0 to 127 actually used within MIDI files. When interpreting ProgramNum values, note that they may be one less than the patch numbers given in an instrument's documentation.<BR>
<BR>
 With the info-tag 'fenvs', given to a note or temporal container, you can specify a tuple of continuous controllers for the duration this item. Each Fenv spec is a pair Controller#Fenv, where Controller is defined as for Fenv.fenvToMidiCC. Example: fenvs((cc#1)#MyFenv). Fenvs directly specify the controller values (e.g., if Controller is pitchBend, then the Fenv range is 0.0 to 16383.0, and the value 8192.0 means no pitchbend). Note that for any controller only a single Fenv should be defined at any time (otherwise they conflict with each other).<BR>
<BR>
 The info-tag 'timeshift': see doc of Out.midi.outputMidiFile.<BR>
<BR>
 The info-tag 'globaltempo', given to a temporal container, specifies a tempo curve (a fenv) and is output as MIDI tempo events. Example: globaltempo(MyTempoFenv). Tempo values are specified in BPM. Due to restrictions of the MIDI protocoll, only a single global tempo is supported (note that sequencers may restrict the import of such data in a MIDI files). If multiple tempi are defined "in parallel" or nested, then "conflicting" MIDI tempo events are output.<BR>
<BR>
 All arguments of Out.midi.renderAndPlayMidiFile are supported. RenderAndPlayMidiFile is defined by calling Out.midi.renderAndPlayMidiFile with special clauses (namely for the tests isNote, and Score.isTemporalContainer). Clauses given to RenderAndPlayMidiFile are again appended at the beginning of the list of clauses (and so potentially overwrite the clauses defined by this procedure).<BR>
<BR>
 Args:<BR>
<BR>
 'ccsPerSecond' (float, default 10.0): how many continuous controller events are created per second for every Fenv (the spacing of CC events may be affected).<BR>
 'ccsPerEvent' (float or false, default false): how many continuous controller events are created per event. If this argument is not false, then its setting overwrites arg 'ccsPerSecond'.<BR>
 'resolution' (default 2): pitchbend resolution in semitones. Its default value 2 corresponds to the standard pitch bend range of -2..2 semitones, i.e., 4096 steps/100 cents.<BR>
 'channelDistributions' (record of lists with only int features including 0, default unit): Microtonal pitches are detuned by pitch bend, i.e. always all notes of a given channel are detuned. This arg specifies which score channel (midi note param, info tag or default 0) is output to which actual output channel. For example, for distributing the score channel 0 over the actual channels 0-7 set channelDistributions to unit(0: [0 1 2 3 4 5 6 7]). The number of output channels (8 in the example) should correspond to the maximum number of simultaneous notes in the score channel (0 in the example). Score channels for which no output channels are specified are output to themselves and thus are only suitable for a single monophonic voice. By default, no output channels are specified at all, so pitchbend always changes all notes of a channel (fine for microtonal music with only a monophonic voice per MIDI channel). Currently, only 16 MIDI chans are supported in total (no multiple ports).<BR>
<BR>
 Additionally, the args of Out.midi.outputMidiFile are supported.<BR>
<BR>
 NOTE: microtonal pitchbend and pitchbend given explicitly as fenv overwrite each other.<BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity43">
<span class="keyword">fun</span>{<span class="functionname">MakeRenderAndPlayMidiFile_Scala</span> TemperamentMapping Args}<br>
<span class="string"> MakeRenderAndPlayMidiFile_Scala returns a procedure for outputting microtonal music for MIDI instruments with statically detuned MIDI pitch classes (e.g. with a Scala file). For outputting more than 12 tones per octave, MakeRenderAndPlayMidiFile_Scala assumes that pitches are distributed over multiple MIDI channels with different tunings. The returned function customises RenderAndPlayMidiFile.<BR>
<BR>
 Supported score format: see RenderAndPlayMidiFile doc. The behaviour for the following info-tags is changed compared with Fenv.renderAndPlayMidiFile.<BR>
 The info-tag 'channel', given to a note or temporal container, sets the MIDI channels (plural!) for this item and all contained items. Because the function returned by MakeRenderAndPlayMidiFile distributes microtonal pitches over multiple MIDI channels, a list of multiple channels should be specified. Example: channel([0 1]). If a channel is defined multiple times, then a setting in a lower hierarchical level overwrites higher-level settings.<BR>
 <BR>
 The argument TemperamentMapping (record with int feats and pair values, required arg) specifies the mapping of tempered Strasheela pitch classes (unit of measurement depends on PitchesPerOctave) to pairs MidiPC#ChanOffset, where MidiPC is the corresponding MIDI pitch class and ChanOffset is the channel offset that should be added to output this pitch class to the correctly retuned channel. For example, if you implement 24-TET with your MIDI instrument by 12-TET in a first channel and a second 12-TET transposed up by 50 cent in a second channel, then the 24-TET PC 1 (C raised by 50 cent) would be mapped to the  MidiPC#ChanOffset pair of 0#1 (PC 0 on the second channel, which is raised by 50 cent). In other words, TemperamentMapping for 24-TET could be defined as follows<BR>
      unit(0:0#0 1:0#1 2:1#0 3:1#1 4:2#0 ...)<BR>
<BR>
 Optionally, an octave offset value can be given, so that a mapping specification becomes MidiPC#ChanOffset#OctaveOffset. For example, if OctaveOffset is ~1, then the resulting MIDI note will be transposed down by an octave.<BR>
<BR>
 optional Args (to both MakeRenderAndPlayMidiFile_Scala and the returned procedure, see doc of Fenv.renderAndPlayMidiFile for further args):<BR>
<BR>
 'file_postfix' (default nil): VS that is appended at end of the output filename. It is intended to clearly denote the Scale tuning file for the resulting MIDI file.<BR>
<BR>
<BR>
 NOTE: MakeRenderAndPlayMidiFile_Scala should not be used with MIDI notes (instances of Out.midi.midiNoteMixin), as their channel parameter would confuse the channel mapping. <BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>