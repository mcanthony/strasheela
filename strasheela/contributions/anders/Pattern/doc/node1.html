<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Pattern</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="2" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Pattern</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor defines constraints on lists which help to express pattern in music. To combine multiple patterns to motifs see the contribution Motifs.<BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Pattern ("<span class="string">Pattern.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>FD</li><li>FS</li><li>Combinator</li><li>Select(fd) at "<span class="string">x-ozlib://duchier/cp/Select.ozf"
</span></li><li>GUtils at "<span class="string">x-ozlib://anders/strasheela/source/GeneralUtils.ozf"
</span></li><li>LUtils at "<span class="string">x-ozlib://anders/strasheela/source/ListUtils.ozf"
</span></li><li>Score at "<span class="string">x-ozlib://anders/strasheela/source/ScoreCore.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;P/2:<a href="#entity8"><span class="functionname">PlainPattern</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity9"><span class="functionname">PlainPattern2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity10"><span class="functionname">Continuous</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity13"><span class="functionname">AllEqual</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity11"><span class="functionname">Increasing</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity12"><span class="functionname">Decreasing</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity14"><span class="functionname">NoRepetition</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity15"><span class="functionname">Arc</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity16"><span class="functionname">InInterval</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity18"><span class="functionname">Cycle</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity17"><span class="functionname">Cycle2</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity19"><span class="functionname">Rotation</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity126"><span class="functionname">Heap</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity23"><span class="functionname">Random</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity20"><span class="functionname">Palindrome</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity21"><span class="functionname">Line</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity22"><span class="functionname">Accumulation</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity24"><span class="functionname">Intervals</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity25"><span class="functionname">AbsIntervals</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity26"><span class="functionname">RestrictMaxInterval</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity27"><span class="functionname">ArithmeticSeries</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity28"><span class="functionname">GeometricSeries</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity29"><span class="functionname">Max</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity30"><span class="functionname">Min</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity31"><span class="functionname">DxsToXs</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity32"><span class="functionname">XsToDxs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity33"><span class="functionname">ArithmeticMean</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity34"><span class="functionname">Range</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity35"><span class="functionname">FirstToLastDistance</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity36"><span class="functionname">WindowedPattern</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity37"><span class="functionname">WindowedPatternRecursions</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity38"><span class="functionname">UseMotifs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity39"><span class="functionname">MakeIndexConstructor</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity40"><span class="functionname">GetMotifIndex</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity41"><span class="functionname">MarkovChain</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity42"><span class="functionname">MarkovChain_1</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity130"><span class="functionname">MakeLSystem</span></a>&gt;
</li><li>&lt;P/5:<a href="#entity131"><span class="functionname">MakeLSystem_B</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity132"><span class="functionname">MakeLSystem2</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity133"><span class="functionname">LSystemConstsToParams</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity135"><span class="functionname">OneOverFNoise</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity134"><span class="functionname">OneOverFNoiseDeterm</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity84"><span class="functionname">MapTail</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity85"><span class="functionname">MapTailInd</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity86"><span class="functionname">MapTailN</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity87"><span class="functionname">ForTail</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity88"><span class="functionname">ForTailInd</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity89"><span class="functionname">ForTailN</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity92"><span class="functionname">MapNeighbours</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity93"><span class="functionname">MapNeighboursInd</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity94"><span class="functionname">ForNeighbours</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity95"><span class="functionname">ForNeighboursInd</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity96"><span class="functionname">Map2Neighbours</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity97"><span class="functionname">For2Neighbours</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity98"><span class="functionname">ApplyToRange</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity99"><span class="functionname">ForRanges</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity100"><span class="functionname">MapRanges</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity101"><span class="functionname">ParallelForAll</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity102"><span class="functionname">ParallelMap</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity103"><span class="functionname">ForCartesianProduct</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity104"><span class="functionname">MapCartesianProduct</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity90"><span class="functionname">Sublists</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity91"><span class="functionname">AdjoinedSublists</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity105"><span class="functionname">ForPairwise</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity106"><span class="functionname">MapPairwise</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity107"><span class="functionname">ForSublists</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity108"><span class="functionname">MapSublists</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity109"><span class="functionname">CollectPM</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity110"><span class="functionname">ForPM</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity111"><span class="functionname">MapPM</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity112"><span class="functionname">Zip</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity113"><span class="functionname">TransformDisj</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity114"><span class="functionname">SelectList</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity115"><span class="functionname">SelectMultiple</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity116"><span class="functionname">ApplyToN</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity127"><span class="functionname">RotateList</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity128"><span class="functionname">RotateSublists</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity129"><span class="functionname">Average</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity43"><span class="functionname">HowManyDistinct</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity44"><span class="functionname">MinDistinct</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity45"><span class="functionname">HowManyAs</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity46"><span class="functionname">HowMany</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity47"><span class="functionname">Once</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity48"><span class="functionname">ForN</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity49"><span class="functionname">ForPercent</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity51"><span class="functionname">NDifferences</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity50"><span class="functionname">ForNEither</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity52"><span class="functionname">AllTrue</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity53"><span class="functionname">AllTrueR</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity54"><span class="functionname">OneTrue</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity55"><span class="functionname">OneTrueR</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity56"><span class="functionname">SomeTrue</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity57"><span class="functionname">SomeTrueR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity58"><span class="functionname">HowManyTrue</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity59"><span class="functionname">HowManyTrueR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity60"><span class="functionname">PercentTrue</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity61"><span class="functionname">PercentTrue_Range</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity62"><span class="functionname">PercentEqual_Range</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity63"><span class="functionname">WhichTrue</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity71"><span class="functionname">SymbolToDirection</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity72"><span class="functionname">DirectionToSymbol</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity73"><span class="functionname">Direction</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity74"><span class="functionname">DirectionR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity75"><span class="functionname">Contour</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity76"><span class="functionname">InverseContour</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity77"><span class="functionname">ContourMatrix</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity78"><span class="functionname">DirectionOfContour</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity79"><span class="functionname">Undulating</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity80"><span class="functionname">Hook</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity81"><span class="functionname">Stairs</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity64"><span class="functionname">DirectionChangeR</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity65"><span class="functionname">LocalMaxR</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity66"><span class="functionname">LocalMinR</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity67"><span class="functionname">GetLocalMax</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity68"><span class="functionname">GetLocalMin</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity69"><span class="functionname">ConstrainLocalMax</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity70"><span class="functionname">ConstrainLocalMin</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity82"><span class="functionname">FdInts</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity83"><span class="functionname">FdRanges</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity136"><span class="functionname">MkUniqueSeq</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity137"><span class="functionname">MkUniqueIntervalSeq</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity138"><span class="functionname">ConjAll</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity139"><span class="functionname">DisjAll</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity140"><span class="functionname">ZerosOnlyAtEnd</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity141"><span class="functionname">RelevantLength</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity117"><span class="functionname">ForAllItems</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity118"><span class="functionname">MapItems</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity119"><span class="functionname">EqualizeParam</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity120"><span class="functionname">FenvBoundaries</span></a>&gt;
</li><li>&lt;P/3:<a href="#entity121"><span class="functionname">FenvToContour</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity122"><span class="functionname">FenvContour</span></a>&gt;
</li><li>&lt;P/2:<a href="#entity123"><span class="functionname">FenvContour2</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity124"><span class="functionname">ApproximateContour</span></a>&gt;
</li><li>&lt;P/4:<a href="#entity125"><span class="functionname">Approximate</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity8">
<span class="keyword">proc</span>{<span class="functionname">PlainPattern</span> Xs Proc}<br>
<span class="string"> PlainPattern constraints Xs to a plain pattern (ie. no nesting or combination of patterns). The pattern is specified by the procedere Proc given to PlainPattern. Proc constraints a single pattern item and is called recursively. Proc expects two arguments: the current item and its predecessor in the list. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity9">
<span class="keyword">proc</span>{<span class="functionname">PlainPattern2</span> Xs Proc}<br>
<span class="string"> PlainPattern2 constraints Xs to a plain pattern (ie. no nesting or combination of patterns) and is a variant of PlainPattern which adds additional control. The pattern is specified by the procedere Proc given to PlainPattern2. Proc constraints a single pattern item and is called recursively. Proc expects three arguments: the current item, a list with all previous pattern items in reverse order (last is first), the number of generations processed so far. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity10">
<span class="keyword">proc</span>{<span class="functionname">Continuous</span> Xs A}<br>
<span class="string"> Constrain all elements in Xs to fulfill the relation: Predecessor A X. For instance, if A is '>:' then the relation Predecessor >: X  constraints all elements in Xs to decrease.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity13">
<span class="keyword">proc</span>{<span class="functionname">AllEqual</span> Xs}<br>
<span class="string"> Constrain all elements in the Xs to be equal.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity11">
<span class="keyword">proc</span>{<span class="functionname">Increasing</span> Xs}<br>
<span class="string"> Constrain all elements in Xs to be greater then their predecessor in Xs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity12">
<span class="keyword">proc</span>{<span class="functionname">Decreasing</span> Xs}<br>
<span class="string"> Constrain all elements in Xs to be less then their predecessor in Xs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity14">
<span class="keyword">proc</span>{<span class="functionname">NoRepetition</span> Xs}<br>
<span class="string"> Consecutive values in Xs are not equal.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity15">
<span class="keyword">proc</span>{<span class="functionname">Arc</span> Xs Args}<br>
<span class="string"> Constraints Xs to form an "arc", i.e. there is only a single change of direction. <BR>
<BR>
 Args:<BR>
 'firstRel' (default '<:'): a relation atom ('<:', '=<:', '>:', '>=:')<BR>
 'turningPointPos' (default mid): specifies at which position within Xs the arc changes direction, positive int or atom mid<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity16">
<span class="keyword">proc</span>{<span class="functionname">InInterval</span> Xs Min Max}<br>
<span class="string"> Constraints all elements in Xs to fall in interval [Min, Max], including.<BR>
</span>
</code><br>

<code>
<a name="entity18">
<span class="keyword">proc</span>{<span class="functionname">Cycle</span> Xs L}<br>
<span class="string"> Unifies every element in Xs with its Lth predecessor.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity17">
<span class="keyword">proc</span>{<span class="functionname">Cycle2</span> Xs Ys}<br>
<span class="string"> Constrains all elements in the list Xs (FD variables) to form a cycle pattern of the (shorter) list Ys (FD variables). I.e. Xs enumerates the elementes of Ys in sequential order and loops back to the first element of Ys after the last element has been reached.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity19">
<span class="keyword">proc</span>{<span class="functionname">Rotation</span> Xs Ys}<br>
<span class="string"> Constrains all elements in the list Xs (FD variables) to form a rotation pattern of the (shorter) list Ys (FD variables).<BR>
 ?? unfinished doc: I probably should just do an example...<BR>
 !! TODO: additional args/control, see CM<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity126">
<span class="keyword">proc</span>{<span class="functionname">Heap</span> Xs Ys}
</code><br>

<code>
<a name="entity23">
<span class="keyword">proc</span>{<span class="functionname">Random</span> Xs Ys}<br>
<span class="string"> Constraints the domain of each element in Xs to contain only the elements of Ys.<BR>
 !! Only a random distribution enforces a random ordering here.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity20">
<span class="keyword">proc</span>{<span class="functionname">Palindrome</span> Xs Ys Elide}<br>
<span class="string"> Constrains all elements in the list Xs (FD variables) to form a palindrome pattern of the (shorter) list Ys (FD variables).<BR>
 Elide (true | first | last | unit) allows to specify which elements in the pattern are not directly repeated when the pattern reverses direction.<BR>
 ?? unfinished doc: I probably should just do an example...<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity21">
<span class="keyword">proc</span>{<span class="functionname">Line</span> Xs Ys}<br>
<span class="string">Constrains all elements in the list Xs (FD variables) to form a line pattern of the (shorter) list Ys (FD variables). I.e. Xs enumerates the elements of Ys in sequential order and sticks on the last element once it has been reached.<BR>
</span>
</code><br>

<code>
<a name="entity22">
<span class="keyword">proc</span>{<span class="functionname">Accumulation</span> Xs Ys}
</code><br>

<code>
<a name="entity24">
<span class="keyword">proc</span>{<span class="functionname">Intervals</span> Xs Ys Offset}<br>
<span class="string"> Ys (a list of FD ints, implicitly declared) are the intervals between Xs (list of FD ints) plus an Offset (a FD int) in order to avoid negative intervals.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity25">
<span class="keyword">proc</span>{<span class="functionname">AbsIntervals</span> Xs Ys}<br>
<span class="string"> Ys (a list of FD ints, implicitly declared) are the absolute intervals between Xs (list of FD ints).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity26">
<span class="keyword">proc</span>{<span class="functionname">RestrictMaxInterval</span> Xs MaxInterval}<br>
<span class="string"> Restricts the maximum absolute interval between Xs (list of FD ints) to MaxInterval (FD int).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity27">
<span class="keyword">proc</span>{<span class="functionname">ArithmeticSeries</span> Xs Difference}<br>
<span class="string"> Constrains all elements in the list/stream Xs (FD variables) to form an arithmetic series, with the difference Difference (a FD variable) between the series members.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity28">
<span class="keyword">proc</span>{<span class="functionname">GeometricSeries</span> Xs Quotient}<br>
<span class="string"> Constrains all elements in the list/stream Xs (FD variables) to form an geometric series, with the quotient Quotient (a FD variable) between the series members.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity29">
<span class="keyword">proc</span>{<span class="functionname">Max</span> Xs Y}<br>
<span class="string"> Y is constrained to be the maximum element in Xs. Xs is a list of FD integers and Y is (implicitely declared) a FD integer. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity30">
<span class="keyword">proc</span>{<span class="functionname">Min</span> Xs Y}<br>
<span class="string"> Y is constrained to be the minimum element in Xs. Xs is a list of FD integers and Y is (implicitely declared) a FD integer. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity31">
<span class="keyword">fun</span>{<span class="functionname">DxsToXs</span> Dxs Start}<br>
<span class="string"> Expects a list of integers considered as distances and returns a list of integers beginning with Start where the given distances apply.<BR>
<BR>
 NB: no constraint, integers can be negative.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity32">
<span class="keyword">fun</span>{<span class="functionname">XsToDxs</span> Xs}<br>
<span class="string"> Expects a list of integers and returns the distances between them, also a list of integers.<BR>
 NB: no constraint, integers can be negative.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity33">
<span class="keyword">proc</span>{<span class="functionname">ArithmeticMean</span> Xs EncodedMean Quotient}<br>
<span class="string"> Constrains EncodedMean/Quotient (two FD int) to be the arithmetic means of Xs (a list of FD ints). Encoding the means by the expression EncodedMean/Quotient allows to represent means which are ratios by FD ints. In the following example, the mean is constrained to 1.5<BR>
   <code>{ArithmeticMean Xs 15 10}</code><BR>
<BR>
</span>
</code><br>

<code>
<a name="entity34">
<span class="keyword">proc</span>{<span class="functionname">Range</span> Xs A Y}<br>
<span class="string"> Y (a FD int) is the distance between the maximum and the minimum value in Xs (a list of FD ints). A is a relation such as '=:' etc.<BR>
 NB: this rule poses the Max and Min pattern on Xs. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity35">
<span class="keyword">proc</span>{<span class="functionname">FirstToLastDistance</span> Xs A Y}<br>
<span class="string"> Y (a FD int) is the distance between the first and the last value in Xs (a list of FD ints). A is a relation such as '=:' etc.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity36">
<span class="keyword">proc</span>{<span class="functionname">WindowedPattern</span> MyPattern Xs Yss Args}<br>
<span class="string"> 'Higher-level' pattern constraint: applies the pattern constraint MyPattern to sublists of Xs (a list of FD ints). MyPattern is a binary procedure which expects a list of FD ints as first arg, and one or more single FD ints as remaining args (but see args patternArgs and includeIndex below). Yss is a list of list of FD ints, which are the accumulated "remaining args" of MyPattern. The strength of WindowedPattern lies in the fact that Yss can be further constrained!  <BR>
 <BR>
 Args:<BR>
 'windowlength' (default 3): length of Xs sublists to which is MyPattern is applied. At the end, sublists can be shorter if minwindowlength < windowlength.<BR>
 'minwindowlength' (default same as windowlength): minimum length of Xs sublists permitted. This setting is used as an abort condition. If the last sublist is shorter than minwindowlength, the pattern constraint application is skipped.<BR>
 'windowoffset' (default same as windowlength): "offset" of Xs element positions between the first elements of consecutive sublists. windowoffset must be =< than windowlength, but > 0.<BR>
<BR>
 These arguments are integers (for a static setting), but windowlength and windowoffset can also be lists of integers. In the latter case, each integer is used for a single application of MyPattern. If the given list is too short to provide a value for each individual pattern constraint application, then the last value is simply used for the remaining calls as well. In any case, the given list must at least be of length 2 (otherwise it is a static setting, and no list is required).<BR>
<BR>
 'patternArgs' (default false): If this argument is *not* false, then MyPattern is a ternary procedure which expects a single value or a record of further args as third argument. Like for windowlength and windowoffset patternArgs, patternArgs supports a static setting (a single value, must not be a list) or a dynamic setting (a list of values). Note that static arguments can also be provided directly to the definition of MyPattern.<BR>
 'includeIndex' (default false): if true, then MyPattern is a ternary procedure which expects the accumulated number of recursive calls so far of as third argument. Only one of the arguments patternArgs and includeIndex must be non-false. <BR>
 <BR>
 Example:<BR>
<BR>
   {WindowedPattern proc {$ Xs Y} {Pattern.max Xs Y} end<BR>
    Xs [Ys]<BR>
    unit(windowlength:2<BR>
	 windowoffset:2)}<BR>
<BR>
 Results in the following constraint applications<BR>
   {Pattern.max {List.take Xs 2} {Nth Ys 1}}<BR>
   {Pattern.max {List.take {List.drop Xs 2} 2} {Nth Ys 2}}<BR>
 ...<BR>
<BR>
 See the test file for a few full examples.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity37">
<span class="keyword">fun</span>{<span class="functionname">WindowedPatternRecursions</span> N Args}<br>
<span class="string"> [Aux for WindowedPattern] Returns the number of recursive constraint applications caused by WindowedPattern. WindowedPatternRecursions is useful, for example, to obtain the length of lists of FD ints given in Yss to WindowedPattern.<BR>
<BR>
 N is length of Xs given to WindowedPattern, Args is args given to WindowedPattern.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity38">
<span class="keyword">proc</span>{<span class="functionname">UseMotifs</span> Xs Motifs Args}<br>
<span class="string"> UseMotifs constrains the list Xs to consist only of "motif instances" declared in the list Motifs, a list of motif specs. More specifically, UseMotifs constrains that Xs is quasi the result of elements in Motifs appended in any order and possibly with repetitions. However, UseMotifs is a constraint -- the order of Motif elements in Xs is not fixed by UseMotifs.<BR>
 Xs can be a list of FD ints. In this case, Motifs must be a list of list of FD its. Elements in Motifs can differ in length. For example, Xs can be the list of note pitches of a voice and Motifs defines possible "pitch motifs". Alternatively, Xs can be the list of intervals between note pitches and Motifs defines "interval motifs" which are transposable. Or Xs is a list of duration factors instead of durations and Motifs defines "duration factor motifs" which can be "stretched".<BR>
 However, Xs is not limited to a list of FD ints, a list of other values is possible as well. For example, elements in Xs can be pairs of Pitch#Duration. In this case, an element in Motifs would also be a list of FD integer pairs. Although the motifs can differ in length, all elements of Xs and all elements of each motif must be equally nested and only differ in constrained variables so that they can be unified.<BR>
 A motif spec can contain elements which should be ignored (i.e. don't result in any constraints). These elements are marked with '_'.<BR>
<BR>
 UseMotifs expects the following optional arguments<BR>
 'workOutEven': If 'workOutEven' is false (the default), then the end of Xs may only contain the beginning of a Motifs element. By contrast, Xs contains only full elements of Motifs if 'workOutEven' is true.<BR>
 'indices': an optional return value, a list of FD ints. For each element in Xs, indices contains an FD int which specifies to which motif index (e.g. position of its motif in Motifs) the Xs element belongs. These variables can be used, for example, to constrain that certain motifs should follow each other or to constrain how often some motif occurs.<BR>
 Note that the argument 'indices' is particular important in case the elements in Motifs do exclude each other, that is some element in Motifs is fully contained as the beginning in another element of Motifs. For example, if Motifs contains [1 2] and also [1 2 2]. In this case, UseMotif would block internally as it could not decide for any motif and would not apply motif constraints anymore. This behaviour is avoided when the variables at the argument 'indices' are propagated (e.g., add a parameter to the notes to which the parameter values in Xs belong).<BR>
<BR>
 Note that this constraint processes the elements of Xs "from left to right". Constraining the next motif is always delayed until the previous motif is known, because it depends on the length of the previous motif where the next motif starts. Consequently, the distribution strategy should determine variables in that order.  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity39">
<span class="keyword">fun</span>{<span class="functionname">MakeIndexConstructor</span> Constructor IndexParamNames}<br>
<span class="string"> [aux for UseMotifs] Returns a score item constructor (i.e. returns a function that returns score items) with added parameters for pattern motif indices. Constructor is the score item constructor to specialise (a unary function or class, e.g. HS.note). IndexParamNames is a list of atoms used to mark the added parameters (in an info tag motifIndex(IndexParamName) of these parameters).<BR>
 The added parameters are created implicitly and not supported by the textual representation (i.e. the method toInitRecord leaves them out as well), but accessible with the function GetMotifIndex (see below) or the method getParameters (which returns a list of all parameter objects).<BR>
<BR>
 Important: for efficiency, the distribution strategy should visit early parameters with info tab 'motifIndex'. Constructors created by MakeIndexConstructor add this info tab to all index parameters.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity40">
<span class="keyword">fun</span>{<span class="functionname">GetMotifIndex</span> X IndexParamName}<br>
<span class="string"> [aux for UseMotifs] Expects X, a score item with added index variable(s) and returns the index variable value associated with the name IndexParamName (an atom).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity41">
<span class="keyword">proc</span>{<span class="functionname">MarkovChain</span> Xs Decl}<br>
<span class="string"> Constraints Xs (a list of FD ints) to form an nth-order markov chain according to Decl. A Decl clause takes any number of predecessors into account and specifies a single successor. Decl is a list of list pairs in the form <code>PredecessorSeq#PossibleSucessors</code>: after the occurance of PredecessorSeq in a sublist of Xs follows a value in PossibleSucessors. For example, the first order markov chain <code>{MarkovChain Xs [[1]#[2 3] [2]#[1] [3]#[2]]}</code> causes any 1 in Xs to be followed by either 2 or 3 and any 2 by 1 etc.<BR>
 The list in PredecessorSeq can be of any length to specify any markov chain order. However, in all clauses the length should be equal.<BR>
 Additionally, the declaration can use the wildcard symbol 'x' which matches every FD int. For example, the clause <code>[x 1]#[2]</code> states that 1 is followed by 2.<BR>
 NB: The list of declarations in Decl specifies a number of disjunctions without any implicit 'otherwise' clause. An inappropriate Decl can cause no solution.<BR>
 Markov chains of order N pose constraints only on sublists of length N: a clauses <code>[x x 1]#[2]</code> does not simply constrain 1 to be followed by 2 but does constrain 1 with two predecessors be followed by 2. Workaround: append some aux FD ints in front of the list and remove them later again (this workaround is not automatically integrated in MarkovChain to avoid any undesired side effects -- its no foolproof trick and the user should thus be aware of it).<BR>
 NB: MarkovChain only specifies that certain elements follow each other. In opposite to the [usual / common] definition of a markov chain, however, MarkovChain does NOT constrain the probability of certain successors.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity42">
<span class="keyword">proc</span>{<span class="functionname">MarkovChain_1</span> Xs Decl}<br>
<span class="string"> Constraints Xs (a list of FD ints) to form a first order markov chain according to Decl. Decl is a record with only integers as features and lists of integers as fields. MarkovChain_1 poses the constraints that each element in Xs with the value of the Decl feature XVal is followed by an element whose value is one of the elements in the field of XVal. <BR>
 For example, <code>{MarkovChain_1 Xs unit(1:[2 3] 2:[1] 3:[2])}</code> causes any 1 in Xs to be followed by either 2 or 3 and any 2 by 1 etc.<BR>
 NB: MarkovChain_1 only specifies that certain elements follow each other. In opposite to the [usual / common] definition of a markov chain, however, MarkovChain_1 does NOT constrain the probability of certain successors.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity130">
<span class="keyword">fun</span>{<span class="functionname">MakeLSystem</span> Axiom N Rules}<br>
<span class="string"> Returns a list of determined values sorted according to an L-system. Axiom is the first pattern period (a list) and N is the number of periods (an integer). N=0 results in the axiom. Rules is a unary function, whose argument is the last pattern value and which returns the next period (a list). Rules can be defined, e.g., by a case expression.  <BR>
 NB: MakeLSystem works best with determined values and is thus no constraint as many other definitions in this functor. Nevertheless, symbols of the L-system can be replaced by variables (e.g. using LUtils.replace). See ./testing/Pattern-test.oz for examples.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity131">
<span class="keyword">fun</span>{<span class="functionname">MakeLSystem_B</span> N Constants Axiom Rules}<br>
<span class="string"> This function is a variant of MakeLSystem which is more convenient to use. It also returns a list of determined values sorted according to an L-system. As in MakeLSystem, N is the number of periods (an integer) and Axiom is the first pattern period (a list). Constants is a list of symbols which always remain fixed (a list of atoms). In contrast to MakeLSystem, Rules is a record which defines a mapping how a symbol is replaced in the following generation. The features in the record denote the L-system symbols for each mapping. The values at these features are typically unary functions. The function returns a list with the symbols of the next generation. For example, the Algae example (example 1 at http://en.wikipedia.org/wiki/Lindenmayer_system) is defined as follows.<BR>
   {MakeLSystem_B 5 nil [a] unit(a: fun {$ _} [a b] end<BR>
				 b: fun {$ _} [a] end)}<BR>
 <BR>
 The function expects the symbol it replaces as argument. This can be used, for example to hand over symbol arguments in parameterised L-systems. In case this function argument is not required, it is possibly for convenience to replace the function by its return value. The next example demonstrates a simple parameterised L-system.<BR>
   {MakeLSystem_B 5 nil [a(1)] unit(a: fun {$ a(I)} [a(I+1) b] end<BR>
				    b: [a(1)])}<BR>
 <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity132">
<span class="keyword">fun</span>{<span class="functionname">MakeLSystem2</span> Start N Rules}<br>
<span class="string"> Returns a list of determined values sorted according to an L-system. Similar to MakeLSystem, however MakeLSystem2 allows the definition of context sensitive L-systems, systems which look not only at single values, but also at predecessors and/or successors (in the former period/generation). Rules is function of three arguments: the whole pattern so far in reverse order (i.e. a list with the direct predecessor first), the current value and the succeeding values (a list). The first argument is nil in the very first iteration. The third arg of Rules is list with successors of X in proceeding generation (normal order) excluding later generations. This arg is nil at any end of a period. Rules may, e.g., define an if or a case statement and can freely access all its arguments (e.g. to define the current element is x and the butfirst is y).<BR>
 NB: MakeLSystem works best with determined values and is no constraint as most other definitions in this functor. Nevertheless, symbols of the L-system can be replaced by variables (e.g. using LUtils.replace). See ./testing/Pattern-test.oz for examples.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity133">
<span class="keyword">fun</span>{<span class="functionname">LSystemConstsToParams</span> Xs Vars}<br>
<span class="string"> [Convenience for L-systems] Transform the result of an L-system (Xs, a list of atoms or records) which contain constants into a result with parameters. Put differently, collects the constant symbols (atoms) as parameters into their preceeding L-system variable symbol (atom or record). The resulting parameterised L-system variables are records whose features are the constants following them before the next L-system variable. The feature values specify how often this constant occured before the next non-constant. The L-system variable labels are specified in Vars (a list of atoms), everything else is considered a constant.<BR>
 Note that this function requires that the first element is always an L-system variable. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity135">
<span class="keyword">proc</span>{<span class="functionname">OneOverFNoise</span> Xs}<br>
<span class="string"> Constraints a list of FD integers to random values according to 1/f noise (i.e. x_n = (x_{n-1} + x_{n-1}^2) mod 1). All Xs are in the domain 0#Max.<BR>
 This constraint is quasi deterministic -- determining a single variable determines the whole list only by constraint propagation.<BR>
 !! Currently, Max is fixed to 100<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity134">
<span class="keyword">proc</span>{<span class="functionname">OneOverFNoiseDeterm</span> L Start Xs}<br>
<span class="string"> Returns a list of determistically created floats according to 1/f noise (i.e. x_n = (x_{n-1} + x_{n-1}^2) mod 1). L is the length of the list and Start is the first list value.<BR>
 spectrum: 1/f noise falls -3dB per octave.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity84">
<span class="keyword">fun</span>{<span class="functionname">MapTail</span> Xs Fn}<br>
<span class="string"> Collects the results of applying the unary function Fn (expecting a list) to Xs and recursively to the tail of each list Fn was applied to.<BR>
 For instance, <code>{MapTail [1 2 3 4] fun {$ Xs} Xs end}</code> returns <code>[[1 2 3 4] [2 3 4] [3 4] [4]]</code>.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity85">
<span class="keyword">fun</span>{<span class="functionname">MapTailInd</span> Xs Fn}<br>
<span class="string"> Similar to MapTail, but Fn is a binary function expecting the index as first argument.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity86">
<span class="keyword">fun</span>{<span class="functionname">MapTailN</span> Xs N Fn}<br>
<span class="string"> Similar to MapTailInt, but Fn is only applied to the first N lists.<BR>
 In case N > {Length Xs}, an exception is raised.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity87">
<span class="keyword">proc</span>{<span class="functionname">ForTail</span> Xs P}<br>
<span class="string"> Applies the unary procedure P (expecting a list) to Xs and recursively to the tail of each list P was applied to.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity88">
<span class="keyword">proc</span>{<span class="functionname">ForTailInd</span> Xs P}<br>
<span class="string"> Similar to ForTail, but P is a binary procedure expecting the index as first argument.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity89">
<span class="keyword">proc</span>{<span class="functionname">ForTailN</span> Xs N P}<br>
<span class="string"> Similar to ForTail, but P is only applied to the first N lists.<BR>
 In case N > {Length Xs}, an exception is raised.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity92">
<span class="keyword">fun</span>{<span class="functionname">MapNeighbours</span> Xs N Fn}<br>
<span class="string"> Traverses through list Xs by mapping the unary function Fn (expecting a list) on each list of N (an int > 0) neighboring elements in Xs. The length of returned list is by N-1 shorter then Xs. <BR>
 For instance, <code>{MapNeighbours [1 2 3 4 5] 3 fun {$ Xs} Xs end}</code> returns <code>[[1 2 3] [2 3 4] [3 4 5]]</code>.<BR>
 NB: MapNeighbours returns nil for N > {Length Xs}<BR>
 BTW: this pattern substitutes the most common pattern matching rule application mechanism of PWConstraints.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity93">
<span class="keyword">fun</span>{<span class="functionname">MapNeighboursInd</span> Xs N Fn}<br>
<span class="string"> Similar to MapNeighbours, but Fn is a binary function expecting the index as first argument.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity94">
<span class="keyword">proc</span>{<span class="functionname">ForNeighbours</span> Xs N P}<br>
<span class="string"> Similar to MapNeighbours, but P is a unary procedure applied to each list of N neighboring elements in Xs without a return value.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity95">
<span class="keyword">proc</span>{<span class="functionname">ForNeighboursInd</span> Xs N P}<br>
<span class="string"> Similar to ForNeighbours, but P is a binary procedure expecting the index as first argument.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity96">
<span class="keyword">fun</span>{<span class="functionname">Map2Neighbours</span> Xs Fn}<br>
<span class="string"> Traverses through Xs by mapping the binary function Fn on neighboring elements in Xs. The length of returned list is by one shorter then Xs.<BR>
</span>
</code><br>

<code>
<a name="entity97">
<span class="keyword">proc</span>{<span class="functionname">For2Neighbours</span> Xs Proc}<br>
<span class="string"> Traverses through Xs by applying the binary procedure Proc on neighboring elements in Xs.<BR>
 {For2Neighbours [1 2 3] P} -> {P 1 2} {P 2 3}<BR>
</span>
</code><br>

<code>
<a name="entity98">
<span class="keyword">proc</span>{<span class="functionname">ApplyToRange</span> Xs Start#End P}<br>
<span class="string"> Applys P (a unary proc expecting a list) to the sublist of Xs (a list) that consists in the Start-th (and int) to the End-th (and int) elements (including).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity99">
<span class="keyword">proc</span>{<span class="functionname">ForRanges</span> Xs Ranges P}<br>
<span class="string"> Applies P (a unary proc expecting a list) to each sublist of Xs (a list) that is declared by a range in Ranges. Ranges is a list consisting in integers and/or pairs of the form Start#End (two integers). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity100">
<span class="keyword">fun</span>{<span class="functionname">MapRanges</span> Xs Ranges Fn}<br>
<span class="string"> Collects the results of applying Fn (a unary function expecting a list) to each sublist of Xs (a list) that is declared by a range in Ranges. Ranges is a list consisting in integers and/or pairs of the form Start#End (two integers). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity101">
<span class="keyword">proc</span>{<span class="functionname">ParallelForAll</span> Xss Proc}<br>
<span class="string"> Traverses all lists in Xss in parallel and sequentially applies the unary procedure Proc (which expects a list as arg) on all first list elements, all second list elements etc. All sublists in Xss must be of same length.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity102">
<span class="keyword">proc</span>{<span class="functionname">ParallelMap</span> Xss Fn Ys}<br>
<span class="string"> Traverses all lists in Xss in parallel and sequentially applies the unary function Fn (which expects a list as arg) on all first list elements, all second list elements etc. The results of Fn are bound sequentially to the elements in Ys. All sublists in Xss and Ys must be of same length.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity103">
<span class="keyword">proc</span>{<span class="functionname">ForCartesianProduct</span> Xs Ys P}<br>
<span class="string"> Applies the binary procedure P on all possible combinations of Xs and Ys. The order of applications is [{P X1 Y1} {P X1 Y2} ... {P X1 Yn} {P X2 Y1} ... {P Xn Yn}].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity104">
<span class="keyword">proc</span>{<span class="functionname">MapCartesianProduct</span> Xs Ys Fn Zs}<br>
<span class="string"> Collects in Zs the result of applying the binary function Fn on all possible combinations of Xs and Ys. The order in Zs is [{Fn X1 Y1} {Fn X1 Y2} ... {Fn X1 Yn} {Fn X2 Y1} ... {Fn Xn Yn}].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity90">
<span class="keyword">fun</span>{<span class="functionname">Sublists</span> Xs N}<br>
<span class="string"> Chop Xs into overlapping subsequences of length N. For example, {Sublists [a b c d] 2} results in [[a b] [b c] [c d]].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity91">
<span class="keyword">fun</span>{<span class="functionname">AdjoinedSublists</span> Xs N}<br>
<span class="string"> Chops Xs into non-overlapping subsequences of length N. For example, {AdjoinedSublists [a b c d e f] 2} results in [[a b] [c d] [e f]].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity105">
<span class="keyword">proc</span>{<span class="functionname">ForPairwise</span> Xs P}<br>
<span class="string"> Applies the binary procedure P on all pairwise combinations of Xs, i.e. {P Xs1 Xs2} .. {P Xs1 XsN} {P Xs2 Xs3} .. {P XsN-1 XsN}.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity106">
<span class="keyword">fun</span>{<span class="functionname">MapPairwise</span> Xs Fn}<br>
<span class="string"> Collects the result of applying the binary function Fn on all pairwise combinations of Xs, i.e. [{Fn Xs1 Xs2} .. {Fn Xs1 XsN} {Fn Xs2 Xs3} .. {Fn XsN-1 XsN}].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity107">
<span class="keyword">proc</span>{<span class="functionname">ForSublists</span> Xs P}<br>
<span class="string"> Applies P (a unary procedure expecting a list) to any sublist in Xs (i.e. any list of succeeding elements in Xs).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity108">
<span class="keyword">fun</span>{<span class="functionname">MapSublists</span> Xs Fn}<br>
<span class="string"> Applies Fn (a unary function expecting a list) to any sublist in Xs (i.e. any list of succeeding elements in Xs) and returns all collected results in a list.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity109">
<span class="keyword">fun</span>{<span class="functionname">CollectPM</span> Xs PatternExpr}<br>
<span class="string"> Implements a pattern matching language very similar to the pattern matching language of PMC from PWConstraints.<BR>
 CollectPM returns in a list any list of elements from Xs (a list) which match the PatternExpr (a list of pattern symbols).<BR>
 The pattern matching language of CollectPM introduces three symbols: '*' is a place-holder matching 0 or more elements, '?' is a place-holder matching exactly one element and 'x' represents a pattern matching 'variable' (see Anders PhD thesis: Sec on PMC in survey II). For example, the PatternExpr [? * x x] matches any pair of subsequent elements of Xs except for the first pair: {CollectPM [a b c d] [? * x x]} returns [[b c] [c d]].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity110">
<span class="keyword">proc</span>{<span class="functionname">ForPM</span> Xs PatternExpr P}<br>
<span class="string"> Applies P (a unary procedure expecting a list) on all lists of elements from Xs (a list) which match the pattern matching expression PatternExpr (a list of pattern symbols). See CollectPM for details.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity111">
<span class="keyword">fun</span>{<span class="functionname">MapPM</span> Xs PatternExpr Fn}<br>
<span class="string"> Applies Fn (a unary function expecting a list) on all lists of elements from Xs (a list) which match the pattern matching expression PatternExpr (a list of pattern symbols) and returns the results in a list. See CollectPM for details.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity112">
<span class="keyword">proc</span>{<span class="functionname">Zip</span> Xss Ys}<br>
<span class="string"> 'Zips' the sublists of Xss together in Ys by sequentially alternating between the sublists in Xss. E.g. {Zip [[1 2 3] [10 12 14]]} returns [1 10 2 12 3 14].<BR>
 NB: there is also List.zip which does something different. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity113">
<span class="keyword">proc</span>{<span class="functionname">TransformDisj</span> Xs Fns I Ys}<br>
<span class="string"> Ys is some transformation of Xs. Fns is a list of binary procedures (both arguments are lists) which represent possible transformations. I (an argument which may be interesting as an output) is an index into Fns, a decision for I is equivalent with a decision for a certain transformation function. The domain of I is implicitly constrained to 1#{Length Fns}. <BR>
 The length of the two arguments of each Fn must correspond with the lengths of Xs and Ys for a success. A mismatch causes the respective Fn to be ruled out in the disjuction.<BR>
<BR>
 See also GUtils.applySelected.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity114">
<span class="keyword">proc</span>{<span class="functionname">SelectList</span> Xss I Ys}<br>
<span class="string"> Out of a list of lists of FD ints in Xss the Ith (a FD int) list Ys is selected (a list of FD ints). All lists in Xss and Ys must be of the same length.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity115">
<span class="keyword">proc</span>{<span class="functionname">SelectMultiple</span> Xs Is Ys}<br>
<span class="string"> Is (a list of FD ints) are the indices into Xs (a list of FD ints) at whose positions the values are Ys (a list of FD ints).<BR>
 Is and Ys are of equal length, Xs will often be longer than Ys.<BR>
 NB: Is are always increasing to reduce symmetries (i.e. multiple solutions with the same Xs).<BR>
<BR>
 BTW: usage example: constrain only specific elements in Xs (i.e. Ys) by a pattern and constrain also the position of the elements to select (e.g. see examples/increasingTendency.oz).<BR>
 Or: constrain that at the Is values in Xs the direction changes (access predecessor and successor of each Y, e.g., by {Select.fd Xs I-1 Y}).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity116">
<span class="keyword">proc</span>{<span class="functionname">ApplyToN</span> Xs N P}<br>
<span class="string"> Applies P (a procedure expecting a list) to a sublist of N (an integer) elements out of Xs (a list of FD ints). Note that the sublist does not need to consist in neighbouring elements of Xs (but sublist elements are in the same order as in Xs). <BR>
 NB: Is and Ys is not necessaily fully determined. However, not determining these values also avoids fully exploring multiple symmetric solutions (i.e. solutions with equal Xs).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity127">
<span class="keyword">fun</span>{<span class="functionname">RotateList</span> Xs I}<br>
<span class="string"> Rotates Xs (a list of arbitrary elements) I times: each time the first element of Xs is put at the end of Xs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity128">
<span class="keyword">fun</span>{<span class="functionname">RotateSublists</span> Xs N I}<br>
<span class="string"> Expects a list Xs and returns a variant in which every Nth sublist is rotated. For example, if N=2 then every two elements are swapped. I specifies how far the rotation conducted. For example, if N=3 and I=1 then every sublist triple is rearranged such that the first in the triple becomes the last. If I=2 then this operation is done twice (in effect the last in the triple becomes the first). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity129">
<span class="keyword">proc</span>{<span class="functionname">Average</span> Xs Y}<br>
<span class="string"> Y (FD int, implicitly declared) is the average of Xs (list of FD ints).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity43">
<span class="keyword">proc</span>{<span class="functionname">HowManyDistinct</span> Xs N}<br>
<span class="string"> N elements in Xs are pairwise distinct. Xs is a list of FD integers, N is a FD integer.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity44">
<span class="keyword">proc</span>{<span class="functionname">MinDistinct</span> Xs N}<br>
<span class="string"> At least N elements in Xs are pairwise distinct. Xs is a list of FD integers, N is a FD integer.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity45">
<span class="keyword">proc</span>{<span class="functionname">HowManyAs</span> Xs Val A N}<br>
<span class="string"> N elements in Xs are 'as' Val, i.e. either equal, or greater etc. A states the relation of the N elements to Val (A is one of '=:', '>:', '>=:', '<:', '=<:', '\\=:').<BR>
 Xs is a list of FD integers, Val and N are FD integers.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity46">
<span class="keyword">proc</span>{<span class="functionname">HowMany</span> X Xs N}<br>
<span class="string"> X {FD int} occures N (FD int) times in Xs (list of FD ints).<BR>
 NB: weak propagation! In particular, there is NO propagation on X (except that it is explicitly limited to the union of all values in Xs).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity47">
<span class="keyword">proc</span>{<span class="functionname">Once</span> X Xs}<br>
<span class="string"> X {FD int} occures only once in Xs (list of FD ints).<BR>
 NB: weak propagation! In particular, there is NO propagation on X (except that it is explicitly limited to the union of all values in Xs).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity48">
<span class="keyword">proc</span>{<span class="functionname">ForN</span> Xs Fn N}<br>
<span class="string"> Constraint Fn (a unary function returning an 0/1 int) holds for N elements in Xs. N is a FD integer.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity49">
<span class="keyword">proc</span>{<span class="functionname">ForPercent</span> Xs Fn Min Max}<br>
<span class="string"> Constraint Fn (a unary function returning an 0/1 int) holds for between Min and Max percent. Min and Max are (determined) integers.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity51">
<span class="keyword">proc</span>{<span class="functionname">NDifferences</span> Xs Ys N}<br>
<span class="string"> Xs and Ys are similar lists of the same length, but N elements differ. Xs and Ys are lists of FD integers, N is a FD integer.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity50">
<span class="keyword">proc</span>{<span class="functionname">ForNEither</span> Xs Fn1 Fn2 N}<br>
<span class="string"> N elements of Xs hold the constraint Fn1, the rest holds Fn2.  Fn1 and Fn2 are unary functions returning an 0/1 int, N is a FD integer.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity52">
<span class="keyword">proc</span>{<span class="functionname">AllTrue</span> Bs}<br>
<span class="string"> Bs is a list of 0/1 integers (not implicitly declared). All elements in Bs are true (i.e. all elements are 1).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity53">
<span class="keyword">proc</span>{<span class="functionname">AllTrueR</span> Bs B}<br>
<span class="string"> Reified version of AllTrue.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity54">
<span class="keyword">proc</span>{<span class="functionname">OneTrue</span> Bs}<br>
<span class="string"> Bs is a list of 0/1 integers (not implicitly declared). Exactly on element in Bs is true (i.e. one element is 1 and the rest is 0).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity55">
<span class="keyword">proc</span>{<span class="functionname">OneTrueR</span> Bs B}<br>
<span class="string"> Reified version of OneTrue.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity56">
<span class="keyword">proc</span>{<span class="functionname">SomeTrue</span> Bs}<br>
<span class="string"> Bs is a list of 0/1 integers (not implicitly declared). At least one element in Bs is true (one element certainly is 1, the rest can be 0 or 1).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity57">
<span class="keyword">proc</span>{<span class="functionname">SomeTrueR</span> Bs B}<br>
<span class="string"> Reified version of SomeTrue.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity58">
<span class="keyword">proc</span>{<span class="functionname">HowManyTrue</span> Bs N}<br>
<span class="string"> Bs is a list of 0/1 integers (not implicitly declared) and N is a FD int (implicitly declared): N elements in Bs are true (i.e. 1).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity59">
<span class="keyword">proc</span>{<span class="functionname">HowManyTrueR</span> Bs N B}<br>
<span class="string"> Reified version of HowManyTrue.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity60">
<span class="keyword">proc</span>{<span class="functionname">PercentTrue</span> Bs Percent}<br>
<span class="string"> Bs is a list of 0/1 integers (not implicitly declared) and Percent is a FD int (implicitly declared): Percent % elements in Bs are true (i.e. 1).<BR>
 NOTE: Percent is rounded to integer value -- complementary percent values don't necessarily sum up to exactly 100 (e.g., 1/3 corresponds to 33 percent and 2/3 to 66 percent). Also, there is only a single solution for Percent for a specific determined list Bs (e.g., Bs = [1 1 0] <-> Percent = 66; Percent = 65 causes fail in this case).<BR>
 Summary: PercentTrue is highly restricted for defining soft of probabilistic CSPs -- I would need true soft multiplication and division propagators instead.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity61">
<span class="keyword">proc</span>{<span class="functionname">PercentTrue_Range</span> Bs MinPercent MaxPercent}<br>
<span class="string"> Like PercentTrue, but a range is specified: the percentage of true values in Bs is between MinPercent and MaxPercent (both FD ints, not implicitly declared).<BR>
 If MinPercent or MaxPercent are undetermined in the CSP, they might be undetermined in the solution too.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity62">
<span class="keyword">proc</span>{<span class="functionname">PercentEqual_Range</span> Xs Ys Min Max}<br>
<span class="string"> Constrains the percentage how many corresponding elements in Xs and Ys (lists of FD ints) are equal. The percentage is specifies by the range Min to Max (both FD ints, not implicitly declared).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity63">
<span class="keyword">proc</span>{<span class="functionname">WhichTrue</span> Bs I}<br>
<span class="string"> WhichTrue constraints the Ith element in Bs to be true. Bs is a list of 0/1 integers and  I is a FD int. Only a single element of Bs is true (i.e. 1).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity71">
<span class="keyword">fun</span>{<span class="functionname">SymbolToDirection</span> Symbol}<br>
<span class="string"> Transforms one of the three direction symbols '-', '=' and '+' to the corresponding integer from 0, 1, or 2 representing a direction as used by constraints such as Direction and Contour. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity72">
<span class="keyword">fun</span>{<span class="functionname">DirectionToSymbol</span> Direction}<br>
<span class="string"> Transforms one of the integers 0, 1, and 2 representing a direction to the corresponding symbol from '-', '=' and '+'.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity73">
<span class="keyword">proc</span>{<span class="functionname">Direction</span> X1 X2 Dir}<br>
<span class="string"> Dir is constrained to the direction of the interval between X1 and X2. An interval 'upwards' (the predecessor is smaller than the successor) is represented by 2, an 'horizontal' interval (the predecessor and the successor are equal) is represented by 1, and an interval 'downwards' by 0.<BR>
 X1, X2, and Dir are all FD integers, Dir is implicitly declared.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity74">
<span class="keyword">proc</span>{<span class="functionname">DirectionR</span> X1 X2 Dir B}<br>
<span class="string"> DirectionR is the reified version of Direction. B=1 <-> 'Dir represents the direction between X1 and X2'. An interval 'upwards' (the predecessor is smaller than the successor) is represented by 2, an 'horizontal' interval (the predecessor and the successor are equal) is represented by 1, and an interval 'downwards' by 0.<BR>
 X1, X2, and Dir are all FD integers. Dir is explicitly constrained to be in 0#2.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity75">
<span class="keyword">proc</span>{<span class="functionname">Contour</span> Xs Dirs}<br>
<span class="string"> Dirs is constrained to the contour of Xs: each element in Dirs represents the direction of an interval between two neighbouring elements in Xs. An interval 'upwards' (the predecessor is smaller than the successor) is represented by 2, an 'horizontal' interval (the predecessor and the successor are equal) is represented by 1, and an interval 'downwards' by 0. <BR>
 Xs and Dirs are both lists of FD integers. The list Xs is one element longer than the list Dirs. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity76">
<span class="keyword">proc</span>{<span class="functionname">InverseContour</span> Xs Ys}<br>
<span class="string"> Xs and Ys are both contours of equal length (i.e. both lists of FD ints with domain 0#2). Ys is the inversion of Xs (and vice versa). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity77">
<span class="keyword">proc</span>{<span class="functionname">ContourMatrix</span> Xs Dirs}<br>
<span class="string"> ContourMatrix is a constraint similar in concept to Contour, but is more precise (and computationally more expensive). Dirs (FD list, implicitly created) is constrained to the contour matrix of Xs (FD list), unfolded into a list. Each element in Dirs represents the direction of an interval between two elements in Xs, i.e. {Direction {Nth Xs Pos_I} {Nth Xs Pos_J}}. Dir collects the results of Pos_I#Pos_J in the order [1#2 1#3 .. 1#N 2#3 .. 2#N .. N-1#N].<BR>
 In Dirs, an interval 'upwards' is represented by 2, an 'horizontal' interval is represented by 1, and an interval 'downwards' by 0. <BR>
<BR>
 ?? This concept stems from [R. Morris, 1987].<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity78">
<span class="keyword">proc</span>{<span class="functionname">DirectionOfContour</span> Xs Dir Min}<br>
<span class="string"> Pattern that constraints contour of Xs, e.g., to be primarily ascending or descending. DirectionOfContour constrains that the minimum number of occurances of directions Dir (FD in 0#2) between elements in Xs (list of FD) is Min (FD int), measured in percent. For example, {DirectionOfContour Xs {SymbolToDirection '+'} 75} constrains that at least 75 percent of the intervals between elements in Xs are ascending. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity79">
<span class="keyword">proc</span>{<span class="functionname">Undulating</span> Xs Args}<br>
<span class="string"> Restricts the occurances of "changes of direction" (local min/max) in Xs.<BR>
<BR>
 Args:<BR>
 min (default 3): minimal number of elements in X without a direction change (i.e. change of direction occurs at position min+1 the earliest).<BR>
 max (default false): maximal number of elements in X without a direction change (ignored if false).<BR>
<BR>
 Note: if a local max/min is repeated, then this does not count as a change of direction! <BR>
<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity80">
<span class="keyword">proc</span>{<span class="functionname">Hook</span> Xs Args}<br>
<span class="string"> Contour constraint where all intervals go in the same directions except one. The interval which goes in the opposite direction always either goes up or down (no repetition).<BR>
<BR>
 Args<BR>
 'oppositePos' (default last): position of the interval which goes in opposite direction (integer or 'last')<BR>
 'oppositeDir': direction of the interval which goes in opposite direction (FD int).<BR>
 'repetition' (default false): Boolean specifying whether there can be repetitions among the "other" intervals.<BR>
<BR>
 Naming: value sequence forms a "hook" if oppositePos is last or 1.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity81">
<span class="keyword">proc</span>{<span class="functionname">Stairs</span> Xs Args}<br>
<span class="string"> Pattern where segments of Args.n elements in Xs (FD ints) follow continuous relation As.rel. For n=2, the result is similar to a common pitch sequence for Organ pedal.  <BR>
<BR>
 Args<BR>
 'n' (default 2): <BR>
 'rel' (default '<:'):<BR>
<BR>
 Note: presently only works if length of Xs is multiple of Args.n.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity64">
<span class="keyword">proc</span>{<span class="functionname">DirectionChangeR</span> X Y Z B}<br>
<span class="string"> Returns 0/1-int in B whether Y is either the maximum or the minimum in [X, Y, Z]. X, Y, Z and B are FD integers. Y must either be greater or smaller than both X and Z (i.e. the values 1 1 2 represent not a direction change). <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity65">
<span class="keyword">proc</span>{<span class="functionname">LocalMaxR</span> X Y Z B}<br>
<span class="string"> Variant of DirectionChangeR that addresses repetitions. Like DirectionChangeR, DirectionChange2R returns a 0/1-int in B whether Y is either the maximum or the minimum in [X, Y, Z]. X, Y, Z and B are FD integers. However, DirectionChange2R is defined such that X and Y might be equal values, but Y and Z must not be equal. For example, the values 1 1 2 do represent a direction change.<BR>
 So, if DirectionChange2R is used to identify direction changes in a longer list then the last element of a repeated local max/min is considered a direction change. However, also if there is no actual direction change, but at least one repeated value then the last  is considered the direction change.<BR>
 */<BR>
    proc {DirectionChange2R X Y Z ?B}<BR>
       {FD.disj<BR>
        {FD.conj (X =<: Y) (Y >: Z)}<BR>
        {FD.conj (X >=: Y) (Y <: Z)}<BR>
        B}<BR>
    end<BR>
<BR>
<BR>
<BR>
/** %%  Returns 0/1-int in B whether Y is the maximum in [X, Y, Z]. X, Y, Z and B are FD integers.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity66">
<span class="keyword">proc</span>{<span class="functionname">LocalMinR</span> X Y Z B}<br>
<span class="string">  Returns 0/1-int in B whether Y is the minimum in [X, Y, Z]. X, Y, Z and B are FD integers.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity67">
<span class="keyword">fun</span>{<span class="functionname">GetLocalMax</span> Xs}<br>
<span class="string"> Returns the local maxima in Xs (list of FD ints). The result is again a list of FD ints, shorter than Xs.<BR>
 NB: repeated local max are ignored completely (see Pattern.directionChangeR), and so are the first and last element in Xs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity68">
<span class="keyword">fun</span>{<span class="functionname">GetLocalMin</span> Xs}<br>
<span class="string"> Returns the local minima in Xs (list of FD ints). The result is again a list of FD ints, shorter than Xs.<BR>
 NB: repeated local min are ignored completely (see Pattern.directionChangeR), and so are the first and last element in Xs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity69">
<span class="keyword">proc</span>{<span class="functionname">ConstrainLocalMax</span> Xs P}<br>
<span class="string"> Apply the pattern constraint P (a unary proc expecting a stream of FD ints) to the local maxima in Xs.<BR>
 NOTE: This constraint can be expensive, because the constraint application is delayed until the local max are known. Also, note that elements in Xs are processed in their order. Predetermining which elements are local max improves efficiency (e.g., with a contour constraint). Moreover, P should be able to concurrently process a stream (instead of a list only).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity70">
<span class="keyword">proc</span>{<span class="functionname">ConstrainLocalMin</span> Xs P}<br>
<span class="string"> Same as ConstrainLocalMax for local minima.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity82">
<span class="keyword">proc</span>{<span class="functionname">FdInts</span> Xs Mins Maxs}<br>
<span class="string"> Constraints the domain bounderies of the elements in Xs (FD integers). Mins specifies the mininum and and Max the maximum domain value for each element in Xs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity83">
<span class="keyword">proc</span>{<span class="functionname">FdRanges</span> Xs Mids Ranges}<br>
<span class="string"> Constraints the domain bounderies of the elements in Xs (FD integers). Mids specifies the middle domain value and Ranges the width between the minimum and maximum domain value for each element in Xs.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity136">
<span class="keyword">fun</span>{<span class="functionname">MkUniqueSeq</span> MaxN MaxDeviation}<br>
<span class="string"> Returns a unary procedure which constraints its argument (a list of FD ints). The returned procedure is applied to multiple FD integer lists; the procedure pairwise 'unifies' the FD integers of each list. MaxDeviation (an integer) determines how far each constrained interval may differ from its restriction.<BR>
 This pattern can, e.g., be used to define a canon. <BR>
 Please note: MkUniqueSeq must be called within the constraint script, otherwise the rule blocks.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity137">
<span class="keyword">fun</span>{<span class="functionname">MkUniqueIntervalSeq</span> MaxN MaxDeviation}<br>
<span class="string"> Returns a unary procedure which constraints its argument (a list of FD ints). The returned procedure is applied to multiple FD integer lists; the procedure 'unifies' the interval sequence between the FD integers of each list. MaxDeviation (an integer) determines how far each constrained interval may differ from its restriction.<BR>
 This pattern can, e.g., be used to define a canon with a free transposition.<BR>
 Please note: MkUniquePitchSeqFn must be called within the constraint script, otherwise the rule blocks.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity138">
<span class="keyword">proc</span>{<span class="functionname">ConjAll</span> Xs B}<br>
<span class="string"> B is constrained to 1 in case the sum of all elements in Xs equals the length of Xs and B is 0 otherwise. This is a shorthand for multiple nested FD.conj<BR>
 !! All elements in Xs must be 0#1 integers (i.e. no more than 1), as this constraint computes simply the sum.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity139">
<span class="keyword">proc</span>{<span class="functionname">DisjAll</span> Xs B}<br>
<span class="string"> B is constrained to 1 in case  the sum of all elements in Xs is >= 1 and B is 0 otherwise. This is a shorthand for multiple nested FD.disj.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity140">
<span class="keyword">proc</span>{<span class="functionname">ZerosOnlyAtEnd</span> Xs}<br>
<span class="string"> Constrains Xs (list of FD ints) such that any zeros only occur at the end of Xs.<BR>
 Possible usage: when constraining the 'length' of a list, 'non existing' list elements are encoded by zeros. This constraint avoids symmeries in such a CSP: 'non-existing' list elements occur at the end of the list.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity141">
<span class="keyword">proc</span>{<span class="functionname">RelevantLength</span> Xs N}<br>
<span class="string"> Constrains N (a FD int, implicitly declared) to the position of the first occurence of a zero in Xs (list of FD ints).<BR>
 Possible usage: when constraining the 'length' of a list, 'non existing' list elements are encoded by zeros. This constraint returns the effectiv length of the list.<BR>
 This pattern rule implies the semantics of ZerosOnlyAtEnd.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity117">
<span class="keyword">proc</span>{<span class="functionname">ForAllItems</span> Items Meth}<br>
<span class="string"> Performs List.forAll on a list of items, but Meth can be a method or procedure. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity118">
<span class="keyword">fun</span>{<span class="functionname">MapItems</span> Items Meth}<br>
<span class="string"> Performs List.map on a list of items, but Meth can be a method or function. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity119">
<span class="keyword">proc</span>{<span class="functionname">EqualizeParam</span> Items1 Items2 Accessor}<br>
<span class="string"> Expects two lists of items (both of the same length) and an Accessor (unary function or method). The variables returned by the Accessor are constrained to be equal for Items at corresponding positions in the two lists. Example: items at corresponding positions in the two lists are constrained to start at the same time.  <BR>
<BR>
   {EqualizeParam Items1 Items2 getStartTime}<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity120">
<span class="keyword">proc</span>{<span class="functionname">FenvBoundaries</span> Xs FenvUpperDom FenvLowerDom}<br>
<span class="string"> Pattern constraint applicator for parameter of a list of Items (a list of Items). Accessor is a unary method or function, and MyPattern is a procedure expecting a list of FD ints. <BR>
<BR>
 Example:<BR>
    {ForParams MyNotes getPitch Increasing}<BR>
 */<BR>
    proc {ForParams Items Accessor MyPattern} <BR>
       {ForParams2 Items Accessor MyPattern nil}<BR>
    end<BR>
    /** %% Like ParamPattern, but MyPattern can expect more arguments. More specifically, MyPattern is a procedure expecting a list of FD ints as first arguments and zero or more furher arguments. OtherPatternArgs is a list of additional arguments to MyPattern. <BR>
<BR>
 Example:<BR>
    {ForParams2 MyNotes getPitch Continuous ['<:']}<BR>
 */<BR>
    proc {ConstrainParams2 Items Accessor MyPattern OtherPatternArgs} <BR>
       {Procedure.apply MyPattern<BR>
        {MapItems Items Accessor} | OtherPatternArgs}<BR>
    end<BR>
<BR>
<BR>
<BR>
<BR>
 Using Fenvs<BR>
<BR>
<BR>
<BR>
/** %% Restricts the upper and lower domain boundary of a list of FD ints (Xs) by two Fenvs. Each fenv is "sampled" where the number of samples is the lengt of Xs, and these samples are then used as domain boundaries. <BR>
 Remember that fenv values are always floats, these are internally rounded to integers.  <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity121">
<span class="keyword">fun</span>{<span class="functionname">FenvToContour</span> MyFenv N}<br>
<span class="string"> Expects a fenv, and returns its contour with N (int) directions encoded as expected by Pattern.direction.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity122">
<span class="keyword">proc</span>{<span class="functionname">FenvContour</span> Xs MyFenv}<br>
<span class="string"> Constraints the contour of the elements in Xs (FD ints) to follow the contour of MyFenv (a fenv). Internally, Pattern.contour is used.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity123">
<span class="keyword">proc</span>{<span class="functionname">FenvContour2</span> Xs MyFenv}<br>
<span class="string"> Variant of FenvContour: each interval either follows the direction of MyFenv -- or performs a repetition. For example, if for a certain interval the corresponding subsection of MyFenv ascends then the interval has either the direction '+' or '=' (expressed with the symbols supporterd by SymbolToDirection). Nevertheless, horizontal sections of MyFenv constrain interval directions to '=' only.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity124">
<span class="keyword">proc</span>{<span class="functionname">ApproximateContour</span> Dirs1 Dirs2 MinPercentError MaxErrorPercent}<br>
<span class="string"> Contour Dirs2 (List of FD ints) quasi paraphrases original contour Dirs1 (List of FD ints). In at maximum MaxErrorPercent (FD int) and at least MinPercentError (FD int) cases, an ascending or descending value of Dir1 can be a constant value in Dir2 while constant values can be ascending or descending. In other words the direction values are either the same or differ by one. Dirs1 and Dirs2 must be of same length. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity125">
<span class="keyword">proc</span>{<span class="functionname">Approximate</span> Xs Ys MinPercentError MaxErrorPercent}<br>
<span class="string"> Ys (List of FD ints) quasi paraphrases original Xs (List of FD ints). At maximum MaxErrorPercent (FD int) and at least MinPercentError (FD int) values of Ys can arbitrarily differ from Xs. Xs and Ys must be of same length.<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>