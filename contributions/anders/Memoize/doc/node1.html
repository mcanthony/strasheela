<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
 <head>
  <title>Memoize</title>
  <style>BODY {
 background: url(page.gif) repeat-y white;
}
#slidemenubar, #slidemenubar2{
 position:absolute;
 left:-144px;
 width:160px;
 top:10px;
 border:0px solid black;
 font:bold 12px Verdana;
 line-height:10px;
}
.margin {
 position: absolute;
 left: 10px;
 width: 130px;
}
BODY, P, H1, H2, H3, A {
 font-family: sans-serif;
}
PRE, CODE {
 font-family: courier, monospace;
}
P {
 text-align: justify;
}
H1     { color: #9B0000; }
H2     { color: #FF9933; }
H3, H4 { color: #881155; }
CODE              { color: #663366; }
.code CODE        { color: #000000; }
SPAN.comment      { color: #B22222; }
SPAN.keyword      { color: #A020F0; }
SPAN.string       { color: #BC8F8F; }
SPAN.functionname { color: #0000FF; }
SPAN.type         { color: #228B22; }
SPAN.variablename { color: #B8860B; }
SPAN.reference    { color: #5F9EA0; }
SPAN.builtin      { color: #DA70D6; }
A:link {
 color: #666666;
}
A:visited {
 color: black;
}
A.pre { font-family: courier, monospace;
 color: #228B22;
}
</style>
 </head>
<body>
<script language="JavaScript1.2">
if (document.all)
document.write('<div id="slidemenubar2" style="left:-144" onMouseover="pull()" onMouseout="draw()">')
</script>
<layer id="slidemenubar" onMouseover="pull()" onMouseout="draw()">
<table border="0" cellpadding="0" cellspacing="0" width="161"><tr><td bgcolor="#009cff" width="144"><a href="index.html">Index</a>
</td><td rowspan="2" valign="top" width="16"><img src="menu.gif" width="16"></td></tr><tr><td bgcolor="#009cff" width="144"><a href="node1.html">Memoize</a>
</td></tr></table></layer>
<script language="JavaScript1.2">
function regenerate(){
window.location.reload()
}
function regenerate2(){
if (document.layers)
setTimeout("window.onresize=regenerate",400)
}
window.onload=regenerate2
if (document.all){
document.write('</div>')
themenu=document.all.slidemenubar2.style
rightboundary=0
leftboundary=-144
}
else{
themenu=document.layers.slidemenubar
rightboundary=144
leftboundary=0
}
function pull(){
if (window.drawit)
clearInterval(drawit)
pullit=setInterval("pullengine()",20)
}
function draw(){
clearInterval(pullit)
drawit=setInterval("drawengine()",50)
}
function pullengine(){
if (document.all&&themenu.pixelLeft<rightboundary)
themenu.pixelLeft+=5
else if(document.layers&&themenu.left<rightboundary)
themenu.left+=5
else if (window.pullit)
clearInterval(pullit)
}
function drawengine(){
if (document.all&&themenu.pixelLeft>leftboundary)
themenu.pixelLeft-=5
else if(document.layers&&themenu.left>leftboundary)
themenu.left-=5
else if (window.drawit)
clearInterval(drawit)
}
</script>

<div style="margin-left:160px"><span class="string">

<table border="0" cellpadding="2" cellspacing="2"><tr bgcolor="#eeeecc">




</tr></table>
<span class="string"> This functor provides memoization of functions. <BR>
<BR>
</span>
</span>
<h3>Functor</h3>
<ul>Memoize ("<span class="string">Memoize.oz</span>")<br></ul>
<h3>Import</h3>
<code><ul><li>MRecord at "<span class="string">x-ozlib://anders/strasheela/MultiRecord/MultiRecord.ozf"
</span></li></ul></code>
<h3>Export</h3>
<code><ul><li>&lt;P/2:<a href="#entity4"><span class="functionname">Memoize</span></a>&gt;
</li><li>&lt;P/0:<a href="#entity5"><span class="functionname">ClearAll</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity2"><span class="functionname">SetGetID</span></a>&gt;
</li><li>&lt;P/1:<a href="#entity3"><span class="functionname">SetMinID</span></a>&gt;
</li></ul></code>
<h3>Define</h3>

<code>
<a name="entity4">
<span class="keyword">proc</span>{<span class="functionname">Memoize</span> Fn MemoFn}<br>
<span class="string"> Expects a unary function Fn (expecting a list of values and returning a value) and returns the corresponding memoized function MemoFn (ie. a function which caches the result for specific arguments and returns this pre-computed value again when called with the same arguments instead of computing the value again, see 'Norvig. Paradigms of Aritificial Intelligence Programming, 1992' for details).<BR>
 Function attributes must be values for which a key can be computed. The function returning this key can be set by SetGetID.<BR>
<BR>
 NB: The definition of the original function is not changed (in contrast to the Lisp implementation of Norvig) and thus recursive functions are not well memoized. Only the top-level call of the recursive function would get memoized but internally the function would call the original unmemoized version.<BR>
<BR>
 NB: Memoize itself (and clearing the cache of a memoized function) performs a stateful operation. Still, calling the memo-function (and caching results) is stateless. Thus, memo-functions can be used freely in CSP, even if they are defined in the top-level space.<BR>
<BR>
 NB: Memoize determines the ID of any value given as argument to a memo-function to an integer (as long as that ID is not already determined). The minimal ID can be set by SetMinID.<BR>
<BR>
 NB: Memo-functions are not thread save. In case the result for a particular set of arguments is not yet cached and the function is called with the same args (args with the same keys) in parallel, the cache will be set twice (in case of inconsistent values, an exception will be raised).<BR>
 Similarily, setting the ID of a value is not thread-save either.<BR>
<BR>
 Reason: these operations could be made thread-save by locking multiple sub-operations. Problem: locks in a top-level space not not be 'entered' by statements in other spaces (i.e. during search). <BR>
<BR>
 NB: Efficiency of memo-functions lookup is only linear time (!) depending on the number of results already cached (i.e. not constant time as perhaps expected, because currently there is no constant time RecordC.reflectHasFeature).<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity5">
<span class="keyword">proc</span>{<span class="functionname">ClearAll</span> }<br>
<span class="string"> Clears the cache of all memoized functions. <BR>
<BR>
</span>
</code><br>

<code>
<a name="entity2">
<span class="keyword">proc</span>{<span class="functionname">SetGetID</span> Fn}<br>
<span class="string"> Sets the function which accesses the unique ID of an argument to a memoization function. This must be a name, atom or an integer. Alternatively, the value returned by Fn my be a free variable. In that case, this variable gets implicitly bound to a unique integer (see SetMinID).<BR>
 The default GetIdFn is fun {$ X} {X getID($)} end.<BR>
<BR>
</span>
</code><br>

<code>
<a name="entity3">
<span class="keyword">proc</span>{<span class="functionname">SetMinID</span> Min}<br>
<span class="string"> A memo-function created by Memoize recognises values by their ID. In case this ID is a free variable, it is determined to a unique integer.<BR>
 SetMinId sets the minimum ID. This allows to avaid conflicts of automatically created IDs with IDs created by hand. The default min ID is 0.<BR>
<BR>
</span>
</code><br>
<h3>End</h3>
</div></body>
</html>