<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Strasheela Tutorial (by Torsten Anders)</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
<div id="header">
  <ul class="nav">
    <li class="nav1"><a href="index.html">home</a></li>
    <li class="navn"><a href="https://sourceforge.net/projects/strasheela/">download at sourceforge</a></li>
    <li class="navn"><a href="IndexOfPages.html">site map</a></li>
    <li class="navn"><a href="contact.html">contact</a></li>
  </ul>
  <div id="logo">
    <a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=167225&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </div>
</div>
    <h1>Strasheela Tutorial (by Torsten Anders)</h1>
    <!-- Page published by Emacs Muse begins here -->
<p><a href="http://www.torsten-anders.de">Torsten Anders</a></p>


<p><a href="??%20Introduction">?? Introduction</a></p>

<blockquote>
<p class="quoted">brief..</p>
</blockquote>

<blockquote>
<p class="quoted">full installation assumed...</p>
</blockquote>





<p><a href="First%20Steps%20/%20The%20OPI">First Steps / The OPI</a></p>

<blockquote>
<p class="quoted">how to start OPI</p>
</blockquote>

<blockquote>
<p class="quoted">most important OPI commands: demonstrate with tiny musical examples (call existing Strasheela functionality)</p>
</blockquote>

<blockquote>
<p class="quoted">pointers to Oz tutorial + manual</p>
</blockquote>

<blockquote>
<p class="quoted">pointer to Emacs doc</p>
</blockquote>


<p><a href="Constraint%20Programming%20in%20Oz">Constraint Programming in Oz</a></p>

<blockquote>
<p class="quoted">NB: no Oz tutorial, but some guided tour on Oz constraint programming features</p>
</blockquote>

<blockquote>
<p class="quoted">;; see /home/t/texte/PhD/Viva/Demo/StrasheelaDemo.oz</p>
</blockquote>

<blockquote>
<p class="quoted">pointers to Oz doc [Strasheela-doc Ozdoc page]</p>
</blockquote>


<p><a href="The%20Strasheela%20Music%20Representation">The Strasheela Music Representation</a></p>

<blockquote>
<p class="quoted">;; ... see /home/t/texte/PhD/Viva/Demo/StrasheelaDemo.oz</p>
</blockquote>

<blockquote>
<p class="quoted">score objects, hierarchic nesting, ADT interface (pointer to Strasheela API doc)
<ul>
<li>&gt; explain by small examples + demonstrate output to various formats</p>
</blockquote></li>
</ul>


<p><a href="Constraining%20a%20Score">Constraining a Score</a></p>

<blockquote>
<p class="quoted">score information can be unknown: musical CSP</p>
</blockquote>

<blockquote>
<p class="quoted">when to use plain Oz data structures and when Strasheela</p>
</blockquote>

<blockquote>
<p class="quoted">pointers to Thesis</p>
</blockquote>


<p><a href="Rule%20Applicators">Rule Applicators</a></p>

<blockquote>
<p class="quoted">motivation [point to Thesis]</p>
</blockquote>

<blockquote>
<p class="quoted">using predefined applicators</p>
</blockquote>

<blockquote>
<p class="quoted">defining applicators</p>
</blockquote>


<p><a href="??%20Pattern%20Constraints">?? Pattern Constraints</a></p>

<blockquote>
<p class="quoted">Demonstrate usage by examples</p>
</blockquote>

<blockquote>
<p class="quoted">User-defined pattern constraint: show to simple example is defined</p>
</blockquote>


<p><a href="Music%20Representation%20Extensions">Music Representation Extensions</a></p>

<blockquote>
<p class="quoted">Harmony Model: demonstrate usage by examples</p>
</blockquote>

<blockquote>
<p class="quoted">?? Motif Model [pointer to paper]</p>
</blockquote>

<blockquote>
<p class="quoted">User-defined extensions of the music representation
?? example: trumpet line [suggested by Kilian Sprotte]</p>
</blockquote>


<p><a href="Defining%20Distribution%20Strategies">Defining Distribution Strategies</a></p>

<blockquote>
<p class="quoted">motivation [point to Thesis]</p>
</blockquote>

<blockquote>
<p class="quoted">using distribution strategies in plain Oz</p>
</blockquote>

<blockquote>
<p class="quoted">using score distribution strategies</p>
</blockquote>

<blockquote>
<p class="quoted">defining distribution strategies</p>
</blockquote>


<p><a href="Techniques%20for%20Organising%20Complex%20CSPs">Techniques for Organising Complex CSPs</a></p>

<blockquote>
<p class="quoted">CSPs consisting of Sub-CSPs [see L-system example..]</p>
</blockquote>

<blockquote>
<p class="quoted">Memoization</p>
</blockquote>

<blockquote>
<p class="quoted">..</p>
</blockquote>


<p><a href="Strasheela%20Output">Strasheela Output</a></p>

<blockquote>
<p class="quoted">controlling output formats &mdash; explain interfaces</p>
</blockquote>

<blockquote>
<p class="quoted">defining new output formats: explain, e.g., how interface to Fomus is defined</p>
</blockquote>


<p><a href="Interfacing%20Other%20Systems">Interfacing Other Systems</a></p>

<blockquote>
<p class="quoted">OzServer</p>
</blockquote>

<blockquote>
<p class="quoted">Using Oz from Lisp / Common Music</p>
</blockquote>



<hr>

<h2>!! This contains unfinished material !!</h2>



<p>Extend the previous example to simple two-voice counterpoint</p>



<p>declare
local
<blockquote>
<p class="quoted">MIDI pitch domain reduction: only 'wite keys' (c major)
proc {InCMajor MyNote}
{List.forAll [1 3 6 8 10]	list of 'black' pitch classes (c=0)
proc {$ BlackKey}
{FD.modI {MyNote getPitch($)} 12} \=: BlackKey
end}
end
Determine the pitch of the first and last note of MyVoice
proc {StartAndEndWithFundamental MyVoice}
Notes = {MyVoice getItems($)}
in
{Notes.1 getPitch($)} = 60
{{List.last Notes} getPitch($)} = 60
end
voice leading: only intervals up to a fifth, no pitch repetition
proc {NoBigJump Pitch1 Pitch2}
all intervals between minor second and fourth are allowed
{FD.distance Pitch1 Pitch2 '&gt;=:' 1}
{FD.distance Pitch1 Pitch2 '<code>&lt;:' 5}
end
harmony: only consonants
proc {NoDissonance [Note1 Note2]}
Consonance </code> {FD.int [3 4 7 8 9 12 15 16]}
in
Note1 is bass note
{Note1 getPitch($)} + Consonance <code>: {Note2 getPitch($)}
end
in
proc {SimpleCounterpoint MyScore}
N </code> 9 Voice1 Voice2
in
MyScore =
{Score.makeScore
sim(items: {LUtils.collectN 2
fun {$}
seq(items: {LUtils.collectN N
fun {$}
note(duration: 1
pitch: {FD.int 53#72}
amplitude: 80)
end})
end}
startTime: 0
timeUnit:beats)
unit}
Voice1 = {MyScore getItems($)}.1
Voice2 = {Nth {MyScore getItems($)} 2}</p>
</blockquote>

<center>
<p>Apply compositional rules:</p>
</center>

<center>
<p>rule on single notes
{MyScore forAll(test: isNote InCMajor)}
rule on pitch pair
{Pattern.for2Neighbours {Voice1 mapItems($ getPitch)}
NoBigJump}
{Pattern.for2Neighbours {Voice2 mapItems($ getPitch)}
NoBigJump}
rule on notes of Voice1 and their simultaneous notes</p>
</center>

<center>
<p>NB: SMapping.forContexts only works for a predetermined context
(here, the context of simultaneous notes is determined
because the rhythmic structure is determined in the CSP def.)
{SMapping.forContexts {Voice1 getItems($)}
<table class="muse-table" border="2" cellpadding="5">
<tbody>
<tr>
<td>fun {$ X} X</td>
<td>{X getSimultaneousItems($ test:isNote)} end</td>
</tr>
</tbody>
</table>
NoDissonance}
rule on first (bass) voice
{StartAndEndWithFundamental Voice1}
end
end</p>
</center>


<p>{SDistro.exploreOne SimpleCounterpoint
<blockquote>
<p class="quoted">unit(order:size value:random)}</p>
</blockquote>






<p>simple rhythmic rule:</p>


<h2>predefine allowed rythmic values: 4, 2, 1</h2>


<h2>Either repeat duration or double or halve it.</h2>


<h2>Start and end are predefined to be max. duration (4)</h2>


<p>NB: most rule definitions in the following examples apply a different 'style': instead of called the rules with a rule context (i.e. the set of score objects the rule constraints) &mdash; see rules NoDissonance and NoBigJump and their application above &mdash; the context is partly accessed within the rule definition (e.g. by accessing the simultaneous or precedessing note).</p>



<p>simple monophonic and purely rhythmic example</p>



<p>declare
local
<blockquote>
<p class="quoted">proc {StartAndEndWithLongest Note}
C = {Note getTemporalAspect($)}
in
if {Note isFirstItem($ C)} orelse
{Note isLastItem($ C)}
then
{Note getDuration($)} = 4
end
end
proc {SlowRhythmChanges Note}
C = {Note getTemporalAspect($)}
in
if {Note hasPredecessor($ C)}
then
Dur1 = {{Note getPredecessor($ C)} getDuration($)}
Dur2 = {Note getDuration($)}
HalveDur1
in
{FD.decl HalveDur1}
{FD.times HalveDur1 2 Dur1}
{FD.times HalveDur1 {FD.int [1 2 4]} Dur2}
end
end
in
proc {SmoothRhythm MyScore}
N = 9
in
MyScore = {Score.makeScore
seq(items: {LUtils.collectN N
fun {$}
note(duration: {FD.int [1 2 4]}
pitch: 60
amplitude: 80)
end}
startTime: 0
timeUnit:beats)
unit}</p>
</blockquote>

<center>
<p>Apply compositional rules:</p>
</center>

<center>
<p>{MyScore forAll(test: isNote
proc {$ Note}
{StartAndEndWithLongest Note}
{SlowRhythmChanges Note}
end)}
search strategy (i.e. distribution strategy)
{FD.distribute
{SDistro.makeFDDistribution unit(order:size value:random)}
{MyScore collect($ test:isParameter)}}
end
end</p>
</center>

<p>{ExploreOne SmoothRhythm}</p>




<p>Two parallel rhythmic sequences</p>

<p>declare
local
<blockquote>
<p class="quoted">Durations = [1 2 4]
proc {StartAndEndWithLongest Note}
C = {Note getTemporalAspect($)}
in
if {Note isFirstItem($ C)} orelse
{Note isLastItem($ C)}
then
{Note getDuration($)} = {List.last Durations}
end
end
proc {SlowRhythmChanges Note}
C = {Note getTemporalAspect($)}
in
if {Note hasPredecessor($ C)}
then
Dur1 = {{Note getPredecessor($ C)} getDuration($)}
Dur2 = {Note getDuration($)}
HalveDur1
in
{FD.decl HalveDur1}
{FD.times HalveDur1 2 Dur1}
{FD.times HalveDur1 {FD.int [1 2 4]} Dur2}
end
end
in
proc {SmoothRhythm2 MyScore}
N = 17 EndTime
in
{FD.decl EndTime}
MyScore =
{Score.makeScore
sim(items: [seq(items: {LUtils.collectN N
fun {$}
note(duration: {FD.int Durations}
pitch: 48
amplitude: 80)
end}
offsetTime:0
endTime:EndTime)
seq(items: {LUtils.collectN N
fun {$}
note(duration: {FD.int Durations}
pitch: 70
amplitude: 80)
end}
offsetTime:{List.last Durations}
endTime:EndTime)]
startTime:0
timeUnit:beats)
unit}</p>
</blockquote>

<center>
<p>Apply compositional rules:</p>
</center>

<center>
<p>{MyScore forAll(test: isNote
proc {$ Note}
{StartAndEndWithLongest Note}
{SlowRhythmChanges Note}
end)}
search strategy (i.e. distribution strategy)
{FD.distribute
{SDistro.makeFDDistribution unit(order:size value:random)}
{MyScore collect($ test:isParameter)}}
end
end</p>
</center>

<p>{ExploreOne SmoothRhythm2}</p>





<p>To define IsSimultaneous with free rhythmic structure in an
efficient and sound way, I need to go into reified constraints</p>



<p>declare
local
<blockquote>
<p class="quoted">Durations = [1 2 4]
proc {StartAndEndWithLongest Note}
C = {Note getTemporalAspect($)}
in
if {Note isFirstItem($ C)} orelse
{Note isLastItem($ C)}
then
{Note getDuration($)} = {List.last Durations}
end
end
proc {SlowRhythmChanges Note}
C = {Note getTemporalAspect($)}
in
if {Note hasPredecessor($ C)}
then
Dur1 = {{Note getPredecessor($ C)} getDuration($)}
Dur2 = {Note getDuration($)}
HalveDur1
in
{FD.decl HalveDur1}
{FD.times HalveDur1 2 Dur1}
{FD.times HalveDur1 {FD.int [1 2 4]} Dur2}
end
end
MIDI pitch domain reduction: only 'wite keys' (c major)
proc {InCMajor Note}
{List.forAll [1 3 6 8 10]	list of 'black' pitch classes (c=0)
proc {$ BlackKey}
{FD.modI {Note getPitch($)} 12} \=: BlackKey
end}
end
proc {StartAndEndWithFundamental Note}
C = {Note getTemporalAspect($)}
in
if {Note isFirstItem($ C)} orelse
{Note isLastItem($ C)}
then
{Note getPitch($)} = 60
end
end
voice leading: only intervals up to a fifth, no pitch repetition
(context dependent constraint &mdash; getPredecessor &mdash; but this
context is predetermined by predetermined hierarchic structure)
proc {NoBigJump Note}
C = {Note getTemporalAspect($)}
in
if {Note hasPredecessor($ C)}
then
Pitch1 = {{Note getPredecessor($ C)} getPitch($)}
Pitch2 = {Note getPitch($)}
in
all intervals between minor second and fourth are allowed
{FD.distance Pitch1 Pitch2 '&gt;:' 0}
{FD.distance Pitch1 Pitch2 '&lt;:' 6}
end
end
harmony: only consonants
proc {NoDissonance Note1}
OtherVoiceNotes = {{Note1 find($ fun {$ X}
{X hasThisInfo($ voice2)}
end
mode:graph)}
getItems($)}
Pitch1 = {Note1 getPitch($)}
in
{ForAll OtherVoiceNotes
proc {$ Note2}
Pitch2 = {Note2 getPitch($)}
Consonance
in
!! Consonance does not necessarily get determined: the
solution diamond in the explorer are light green
Consonance = {FD.int [3 4 7 8 9 12 15 16]}
{FD.impl
{Note1 isSimultaneousItemR($ Note2)}
( Pitch1 + Consonance =: Pitch2 )
1}
end}
end
in
proc {RhythmicCounterpoint MyScore}
N=17 EndTime
in
MyScore =
{Score.makeScore
sim(items: [seq(info:voice1
items: {LUtils.collectN N
fun {$}
note(duration: {FD.int Durations}
pitch: {FD.int 53#72}
amplitude: 80)
end}
offsetTime:0
endTime:EndTime)
seq(info:voice2
items: {LUtils.collectN N
fun {$}
note(duration: {FD.int Durations}
pitch: {FD.int 53#72}
amplitude: 80)
end}
offsetTime:{List.last Durations}
endTime:EndTime)]
startTime: 0
timeUnit:beats)
unit}</p>
</blockquote>

<center>
<p>Apply compositional rules:</p>
</center>

<center>
<p>rules for al notes
{MyScore forAll(test: isNote
proc {$ Note}
{InCMajor Note}
{NoBigJump Note}
{StartAndEndWithLongest Note}
{SlowRhythmChanges Note}
end)}
rules for notes of first voice
{{MyScore find($ fun {$ X}
{X hasThisInfo($ voice1)}
end)}
forAll(test: isNote
proc {$ Note}
{StartAndEndWithFundamental Note}
{NoDissonance Note}
end)}
search strategy (i.e. distribution strategy)
{FD.distribute
{SDistro.makeFDDistribution unit(order:startTime value:random)}
{MyScore collect($ test:fun {$ X}
{X isParameter($)} andthen
{Not {X isTimePoint($)}} andthen
{Not {{X getItem($)} isContainer($)}}
end)}}
end
end</p>
</center>

<p>{ExploreOne RhythmicCounterpoint}</p>






<p>Canon</p>


<p>declare
local
<blockquote>
<p class="quoted">Durations = [1 2 4]
proc {StartAndEndWithLongest Note}
C = {Note getTemporalAspect($)}
in
if {Note isFirstItem($ C)} orelse
{Note isLastItem($ C)}
then
{Note getDuration($)} = {List.last Durations}
end
end
proc {SlowRhythmChanges Note}
C = {Note getTemporalAspect($)}
in
if {Note hasPredecessor($ C)}
then
Dur1 = {{Note getPredecessor($ C)} getDuration($)}
Dur2 = {Note getDuration($)}
HalveDur1
in
{FD.decl HalveDur1}
{FD.times HalveDur1 2 Dur1}
{FD.times HalveDur1 {FD.int [1 2 4]} Dur2}
end
end
MIDI pitch domain reduction: only 'wite keys' (c major)
proc {InCMajor Note}
{List.forAll [1 3 6 8 10]	list of 'black' pitch classes (c=0)
proc {$ BlackKey}
{FD.modI {Note getPitch($)} 12} \=: BlackKey
end}
end
proc {StartAndEndWithFundamental Note}
C = {Note getTemporalAspect($)}
in
if {Note isFirstItem($ C)} orelse
{Note isLastItem($ C)}
then
{Note getPitch($)} = 60
end
end
voice leading: only intervals up to a fifth, no pitch repetition
(context dependent constraint &mdash; getPredecessor &mdash; but this
context is predetermined by predetermined hierarchic structure)
proc {NoBigJump Note}
C = {Note getTemporalAspect($)}
in
if {Note hasPredecessor($ C)}
then
Pitch1 = {{Note getPredecessor($ C)} getPitch($)}
Pitch2 = {Note getPitch($)}
in
all intervals between minor second and fourth are allowed
{FD.distance Pitch1 Pitch2 '&gt;:' 0}
{FD.distance Pitch1 Pitch2 '&lt;:' 6}
end
end
harmony: only consonants
proc {NoDissonance Note1 Voice2}
Voice2Notes = {Voice2 getItems($)}
Pitch1 = {Note1 getPitch($)}
in
{ForAll Voice2Notes
proc {$ Note2}
Pitch2 = {Note2 getPitch($)}
Consonance
in
!! Consonance does not necessarily get determined: the
solution diamond in the explorer are light green
Consonance = {FD.int [3 4 7 8 9 12 15 16]}
{FD.impl
{Note1 isSimultaneousItemR($ Note2)}
( Pitch1 + Consonance <code>: Pitch2 )
1}
end}
end
in
proc {SimpleCanon MyScore}
fun {GetVoice MyScore ScoreName}
{MyScore find($ fun {$ X}
{X hasThisInfo($ ScoreName)}
end)}
end
EndTime Voice1 Voice2
in
MyScore </code>
{Score.makeScore
sim(items: [seq(info:voice1
items: {LUtils.collectN 17
fun {$}
note(duration: {FD.int Durations}
pitch: {FD.int 53#67}
amplitude: 80)
end}
offsetTime:0
endTime:EndTime)
seq(info:voice2
items: {LUtils.collectN 15
fun {$}
note(duration: {FD.int Durations}
pitch: {FD.int 53#72}
amplitude: 80)
end}
offsetTime:{List.last Durations}*2
endTime:EndTime)]
startTime: 0
timeUnit:beats)
unit}
Voice1 = {GetVoice MyScore voice1}
Voice2 = {GetVoice MyScore voice2}</p>
</blockquote>

<center>
<p>Apply compositional rules:</p>
</center>

<center>
<p>rules for al notes
{MyScore forAll(test: isNote
proc {$ Note}
{InCMajor Note}
{NoBigJump Note}
{StartAndEndWithLongest Note}
{SlowRhythmChanges Note}
end)}
rules for notes of first voice
{Voice1 forAll(test: isNote
proc {$ Note}
{StartAndEndWithFundamental Note}
{NoDissonance Note Voice2}
end)}
The first 12 notes of each voice form a canon in a fifth
for
Note1 in {List.take {Voice1 getItems($)} 12}
Note2 in {List.take {Voice2 getItems($)} 12}
do
{Note1 getPitch($)} + 7 <code>: {Note2 getPitch($)}
{Note1 getDuration($)} </code>: {Note2 getDuration($)}
end
search strategy (i.e. distribution strategy)
{FD.distribute
{SDistro.makeFDDistribution unit(order:startTime value:random)}
{MyScore collect($ test:fun {$ X}
{X isParameter($)} andthen
{Not {X isTimePoint($)}} andthen
{Not {{X getItem($)} isContainer($)}}
end)}}
end
end</p>
</center>

<p>{ExploreOne SimpleCanon}</p>



<!-- Page published by Emacs Muse ends here -->
<!-- Footer -->
<div id="footer">
<div id="author">&copy; 
Torsten Anders</div>
<div id="date">Last time edited: 2007.02.13</div>
</div>
  </body>
</html>
